/* ex: set expandtab ts=3:                                                 */
/* -*- Mode: C; tab-width:3 -*-                                            */
/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik Staerfeldt, Tom Madsen, and Katja Nyboe.  *
 *                                                                         *
 *  Merc Diku Mud improvements copyright (C) 1992, 1993 by Michael         *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************
 *     ROM 2.4 is copyright 1993-1996 Russ Taylor                          *
 *     ROM has been brought to you by the ROM consortium                   *
 *         Russ Taylor (rtaylor@pacinfo.com)                               *
 *         Gabrielle Taylor (gtaylor@pacinfo.com)                          *
 *         Brian Moore (rom@rom.efn.org)                                   *
 *     By using this code, you have agreed to follow the terms of the      *
 *     ROM license, in the file Rom24/doc/rom.license                      *
 ***************************************************************************/

/***************************************************************************



 ***************************************************************************/

static const char rcsid[] = "$Id: fight.c,v 1.446 2004/03/30 05:16:29 fizzfaldt Exp $";

#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "merc.h"
#include "tables.h"
#define HITS (dt==gsn_kick||dt==gsn_lunge||dt==gsn_downstrike||dt==gsn_throw||dt==gsn_crush||dt==gsn_bash)

/* command procedures needed */
void remove_obj_genocide(CHAR_DATA *ch, OBJ_DATA *obj);
DECLARE_SPELL_FUN(spell_null);
DECLARE_DO_FUN(do_return);
DECLARE_DO_FUN(do_quit);
DECLARE_DO_FUN(do_killer_instinct);
DECLARE_DO_FUN(do_lunge);
DECLARE_DO_FUN(do_pugil);
DECLARE_DO_FUN(do_say);
DECLARE_DO_FUN(do_ambush);
DECLARE_DO_FUN(do_backstab);
DECLARE_DO_FUN(do_emote);
DECLARE_DO_FUN(do_berserk);
DECLARE_DO_FUN(do_deathstyle);
DECLARE_DO_FUN(do_bash);
DECLARE_DO_FUN(do_trip);
DECLARE_DO_FUN(do_dirt);
DECLARE_DO_FUN(do_smoke_screen);
DECLARE_DO_FUN(do_flee);
DECLARE_DO_FUN(do_kick);
DECLARE_DO_FUN(do_disarm);
DECLARE_DO_FUN(do_get);
DECLARE_DO_FUN(do_recall);
DECLARE_DO_FUN(do_sleep);
DECLARE_DO_FUN(do_yell);
DECLARE_DO_FUN(do_myell);
DECLARE_DO_FUN(do_permnameban);
DECLARE_DO_FUN(do_sacrifice);
DECLARE_DO_FUN(do_circle_stab);
DECLARE_DO_FUN(do_battlecry);
DECLARE_DO_FUN(do_whirlwind);
DECLARE_DO_FUN(do_steel_nerves);
DECLARE_DO_FUN(do_breath_morph);
DECLARE_DO_FUN(do_look);
DECLARE_DO_FUN(do_crush);
DECLARE_DO_FUN(do_tail);
DECLARE_DO_FUN(do_undead_drain);
DECLARE_DO_FUN(do_surround);
DECLARE_DO_FUN(do_iron_palm);
DECLARE_DO_FUN(do_cast);
DECLARE_DO_FUN(do_rescue);
DECLARE_DO_FUN(do_hecho);
void nap_start(CHAR_DATA* ch);

DECLARE_SPELL_FUN(spell_evil_eye);
DECLARE_SPELL_FUN(spell_power_word_kill);
DECLARE_SPELL_FUN(spell_power_word_fear);
DECLARE_DO_FUN(do_dismount);

bool    check_spellcraft args( (CHAR_DATA *ch, int sn) );
int    spellcraft_dam    args( ( int num, int dice) );
/* Awaken - Cirdan
DECLARE_SPELL_FUN(spell_awaken);
*/
bool    check_social    args( ( CHAR_DATA *ch, char *command,
char *argument ) );
void house_entry_trigger   args( (CHAR_DATA* ch, bool update) );
void check_changeling_desc args( (CHAR_DATA* ch) );

/*
* External functions
*/
void free_affect        args( (AFFECT_DATA* af) );
AFFECT_DATA* new_affect args( (void) );
/*
* Local functions.
*/
int     powtwo          args( ( int,  int ) );
void check_caltrops   args( (CHAR_DATA* ch) );
void check_charging_retreat args( (CHAR_DATA *ch, CHAR_DATA *victim) );
bool check_tanking    args( (CHAR_DATA *ch) );
void check_doublestrike args( (CHAR_DATA *ch, CHAR_DATA *victim, int dam_type) );
void check_downstrike    args( (CHAR_DATA *ch, CHAR_DATA *victim) );
void    check_assist    args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
bool    check_side_step args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ));
bool    check_dance_venom args((CHAR_DATA *ch, CHAR_DATA *victim));
bool    check_acrobatics args(( CHAR_DATA *ch, CHAR_DATA *victim, int dt));
bool    check_tumble args(( CHAR_DATA *ch, CHAR_DATA *victim, int dt));
CHAR_DATA *check_evasive args( ( CHAR_DATA *ch, CHAR_DATA *victim ));
bool    check_taichi    args((CHAR_DATA* ch, CHAR_DATA* victim, int dt));
bool    check_judo    args((CHAR_DATA* ch, CHAR_DATA* victim, int dt));
bool    check_counter_defense args((CHAR_DATA *ch,CHAR_DATA *victim));
void    check_rage    args( ( CHAR_DATA *ch, CHAR_DATA *victim) );
bool    check_dodge     args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
bool    check_evasive_defense  args((CHAR_DATA* ch, CHAR_DATA* victim, int dt));
bool    check_void      args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
bool    check_drinlinda_defense_brand      args((CHAR_DATA* ch, CHAR_DATA* victim, int dt));
bool    check_drithentir_vampiric_brand    args((CHAR_DATA* ch, CHAR_DATA* victim, int dt));
bool    check_utara_brand_blur args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) ); /* Wicket */
bool    check_block     args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
void    check_killer    args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
bool    check_parry     args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
bool    check_shield_block     args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
void    dam_message     args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dam,
int dt, bool immune ) );
void    dam_message2    args( ( int type, CHAR_DATA *victim, int dam,
int dt, bool immune ) );
void    death_cry       args( ( CHAR_DATA *ch ) );
void    group_gain      args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
int     xp_compute      args( ( CHAR_DATA *gch, CHAR_DATA *victim, int group_amount, int glevel, bool mage ) );
void    make_corpse     args( ( CHAR_DATA *killer, CHAR_DATA *ch ) );
void    one_hit         args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ));
void    mob_hit         args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
void    raw_kill        args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
void    set_fighting    args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
void    disarm          args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
void    off_disarm          args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
float    battlecry_multiplier     args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt) );
void do_counter_parry    args( (CHAR_DATA *ch,CHAR_DATA *victim, int dt,int dam) );
void     check_ground_control args( (CHAR_DATA *ch,CHAR_DATA *victim,int
chance,int dam) );
void    check_ranger_staff    args( (CHAR_DATA *ch,OBJ_DATA *wield) );
void    check_outlaw_badge    args( (CHAR_DATA *ch) );
void    check_high_herb    args( (CHAR_DATA *ch) );
bool    check_counter    args( (CHAR_DATA *ch,CHAR_DATA *victim, int dam,int dt) );
bool     check_palm    args( (CHAR_DATA *ch ) );
int     check_kung_fu   args((CHAR_DATA* ch, CHAR_DATA* victim));
void check_follow_through    args( ( CHAR_DATA *ch, CHAR_DATA *victim,
int dam) );
bool     check_roll    args( (CHAR_DATA *ch,CHAR_DATA *victim,int dt) );
int     check_draconian_eq args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *wield));
void    check_red_shield args(( CHAR_DATA *ch) );
void check_honor_bracer args((CHAR_DATA *ch));
void check_sword_demons args((CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DATA *obj));
void check_genocide_axe args((CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DATA *obj));
void check_bracelets args((CHAR_DATA *ch));
void check_medusa    args((CHAR_DATA *ch));
void wing_beating args((CHAR_DATA *ch) );
bool check_crown_blood args((CHAR_DATA *ch,CHAR_DATA *victim,int dt, int dam, int dam_type));
void check_adorno_brand args((CHAR_DATA *ch, OBJ_DATA *obj));
void check_robe_light args((CHAR_DATA *ch, OBJ_DATA *obj));
void check_staff_gardener args((CHAR_DATA *ch, OBJ_DATA *obj));
void check_silver_hammer args((CHAR_DATA *ch, OBJ_DATA *obj));
void check_mace_blessed args((CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DATA *obj));
void check_thm_sword args((CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DATA *obj));
void check_sword_marcil args((CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DATA *obj));
void check_water_symbol args((CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DATA *obj));
void check_blue_talon args((CHAR_DATA *ch, CHAR_DATA *victim));
void check_runge_brand args((CHAR_DATA *ch, CHAR_DATA *victim));
int     check_cutter args((CHAR_DATA *ch,CHAR_DATA *victim));
bool     eye_of_beholder_absorb args((CHAR_DATA *ch,CHAR_DATA *victim,
int dt, int dam, int dam_type));
void     check_basilica_weapon_decay args((CHAR_DATA *victim));
void check_aura args((CHAR_DATA *ch, CHAR_DATA *victim));
void    obj_fight_27035 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void    obj_fight_27036 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void    obj_fight_27037 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void    obj_fight_27038 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void    obj_fight_27039 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void    obj_fight_27040 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void    obj_fight_27041 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void    obj_fight_27042 args((CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj));
void check_battleaxe_brand args( (CHAR_DATA *ch, CHAR_DATA *victim) );
void check_hector_brand args( (CHAR_DATA *ch, CHAR_DATA *victim) );
int  check_ring_focus args( (CHAR_DATA *ch,CHAR_DATA *victim,int dam,int dt));
/* void check_gremlin_misdirection args( (CHAR_DATA *ch, CHAR_DATA *victim) ); */
void check_xeonauz_brand args( (CHAR_DATA *ch, CHAR_DATA *victim) );
void check_vrrin_brand args( (CHAR_DATA *ch, CHAR_DATA *victim) );
void check_cysts args( (CHAR_DATA* ch, CHAR_DATA* victim) );
void check_drinlinda_attack_brand args((CHAR_DATA* ch, CHAR_DATA* victim));
void check_drithentir_attack_brand args((CHAR_DATA* ch, CHAR_DATA* victim));

/* file global variable to assist with counter defense. -- Mael */
bool defense_not_countered = TRUE;

/*
* Control the fights going on.
* Called periodically by update_handler.
*/
void violence_update( void )
{
   CHAR_DATA *ch;
   CHAR_DATA *ch_next;
   CHAR_DATA *victim;
   int regen, to_heal;
   AFFECT_DATA* paf;

   for ( ch = char_list; ch != NULL; ch = ch->next )
   {
      ch_next = ch->next;
      if
      (
         !ch->on_line ||
         (
            ch->in_room == NULL &&
            !IS_NPC(ch) &&
            ch->desc &&
            ch->desc->connected != CON_PLAYING
         )
      )
      {
         continue;
      }

      if (IS_NPC(ch))
      {
         /* MOB STUFF */
         if
         (
            ch->wait > 0 ||
            ch->daze > 0
         )
         {
            /* Allow MOBs to decrement timers. */
            ch->wait -= PULSE_VIOLENCE;
            ch->daze -= PULSE_VIOLENCE;
            if (ch->wait < 0)
            {
               ch->wait = 0;
            }
            if (ch->daze < 0)
            {
               ch->daze = 0;
            }
         }
         /* Conclave phantasmal force-decoy */
         if
         (
            ch->pIndexData->vnum == MOB_VNUM_PHANTOM &&
            ch->mprog_target != NULL &&
            (
               paf = affect_find(ch->affected, gsn_phantasmal_force)
            ) != NULL &&
            --paf->level < 0  /* Level is round counter */
         )
         {
            if (ch->in_room != ch->mprog_target->in_room)
            {
               send_to_char
               (
                  "Your fighting illusion has fallen apart.\n\r",
                  ch->mprog_target
               );
            }
            act("$n fades into nothingness.", ch, NULL, NULL, TO_ROOM);
            extract_char(ch, TRUE);
            continue;
         }
      }
      else
      {
         /* PC ONLY THINGS */
         /* troll regen */
         if
         (
            (
               regen = get_skill(ch, gsn_regeneration)
            ) > 0
         )
         {
            to_heal = (ch->max_hit - ch->hit);

            if (number_percent() <= ch->level * 2)
            {
               if
               (
                  ch->hit < ch->max_hit &&
                  ch->noregen_dam < to_heal &&
                  number_percent() < regen
               )
               {
                  if (number_percent() < 3)
                  {
                     check_improve(ch, gsn_regeneration, TRUE, 4);
                  }
                  ch->hit += number_range(1, 3);
               }
            }
         }
         /* NAP! */
         if
         (
            IS_AFFECTED2(ch, AFF_NAP) &&
            (
               paf = affect_find(ch->affected, gsn_nap)
            ) != NULL
         )
         {
            if (--paf->level < 0)  /* Level is round counter */
            {
               if (ch->in_room)
               {
                  act("$n wiggles about and wakes up.", ch, NULL, NULL, TO_ROOM);
               }
               check_improve(ch, gsn_nap, FALSE, 1);
               send_to_char(get_herb_spell_name(paf, FALSE, 0), ch);
               send_to_char("\n\r", ch);
               affect_remove(ch, paf);
               ch->position = POS_STANDING;
               update_pos(ch);
            }
            else
            {
               check_improve(ch, gsn_nap, TRUE, 4);
            }
         }
         /* HYPER! */
         if
         (
            IS_AFFECTED2(ch, AFF_HYPER) &&
            (
               paf = affect_find(ch->affected, gsn_hyper)
            ) != NULL
         )
         {
            if (--paf->level < 0)  /* Level is round counter */
            {
               check_improve(ch, gsn_hyper, FALSE, 1);
               send_to_char(get_herb_spell_name(paf, FALSE, 0), ch);
               send_to_char("\n\r", ch);
               affect_remove(ch, paf);
               affect_strip(ch, gsn_nap_timer);
               nap_start(ch);
            }
            else
            {
               check_improve(ch, gsn_hyper, TRUE, 5);
            }
         }
         if
         (
            !ch->fighting &&
            ch->in_room &&
            ch->in_room->house &&
            ch->house != ch->in_room->house
         )
         {
            house_entry_trigger(ch, TRUE);
         }
      }
      /* Conclave intangibility */
      if
      (
         IS_AFFECTED2(ch, AFF_INTANGIBILITY) &&
         (
            paf = affect_find(ch->affected, gsn_intangibility)
         ) != NULL &&
         --paf->level < 0  /* Level is round counter */
      )
      {
         if (ch->in_room)
         {
            act("$n becomes more solid.", ch, NULL, NULL, TO_ROOM);
         }
         send_to_char(get_herb_spell_name(paf, FALSE, 0), ch);
         send_to_char("\n\r", ch);
         affect_remove(ch, paf);
      }
      /* rip tide */
      if
      (
         IS_AFFECTED2(ch, AFF_RIPTIDE) &&
         (
            paf = affect_find(ch->affected, gsn_rip_tide)
         ) != NULL &&
         --paf->level < 0  /* Level is round counter */
      )
      {
         if (ch->in_room)
         {
            act("$n has uprighted $mself.", ch, NULL, NULL, TO_ROOM);
         }
         send_to_char(get_herb_spell_name(paf, FALSE, 0), ch);
         send_to_char("\n\r", ch);
         affect_remove(ch, paf);
      }

      /*
      if (is_affected (ch, gsn_reserved))
      {
         sprintf(log_buf,  "[%s] is affected by reserved.  Stripping.", ch->name);
         log_string (log_buf);
         affect_strip (ch, gsn_reserved);
      }
      Removed by Fizzfaldt.  No longer needed
      */

      /* blindfold, gag, bind */
      if
      (
         !IS_AFFECTED2(ch, AFF_BIND) &&
         !ch->fighting &&
         IS_AWAKE(ch)
      )
      {
         if
         (
            IS_AFFECTED2(ch, AFF_BLINDFOLD) &&
            is_affected(ch, gsn_blindfold) &&
            number_range(1, 3) == 1
         )
         {
            affect_strip(ch, gsn_blindfold);
            send_to_char("You rip away your blindfold!\n\r",ch);
         }
         if
         (
            IS_AFFECTED2(ch, AFF_GAG) &&
            is_affected(ch, gsn_gag) &&
            number_range(1, 3) == 1
         )
         {
            affect_strip(ch, gsn_gag);
            send_to_char("You rip away your gag!\n\r",ch);
         }
      }
      /* meteor storm */
      if
      (
         ch->in_room != NULL &&
         IS_SET(ch->in_room->extra_room_flags, ROOM_METEOR_STORM) &&
         !IS_IMMORTAL(ch) &&
         is_affected_room(ch->in_room, gsn_meteor_storm) &&
         number_range(1,7) == 1
      )
      {
         ROOM_AFFECT_DATA *raf;
         CHAR_DATA *damager;
         int dam;

         raf = affect_find_room(ch->in_room, gsn_meteor_storm);
         if (!is_safe_room(ch, raf, IS_SAFE_SILENT))
         {
            raf->duration--;
            if (raf->duration <= 0)
            {
               affect_strip_room(ch->in_room, gsn_meteor_storm);
               act("The ominous darkness lifts.", ch, 0, 0, TO_ALL);
            }
            damager = get_damager_room(ch,raf);
            dam = dice(raf->level,6);
            if (number_range(1,3) == 1)
            {
               act("A flaming rock drops from the sky but hits no one.", ch, 0, 0, TO_ALL);
            }
            else
            {
               damage(damager,ch,dam,gsn_meteor_storm,DAM_FIRE,METEOR_STORM_DAM_TYPE);
            }
         }
      }
      /* spring rains */
      if
      (
         ch->in_room != NULL &&
         IS_SET(ch->in_room->extra_room_flags, ROOM_SPRING_RAINS) &&
         is_affected_room(ch->in_room, gsn_spring_rains)
      )
      {
         if (ch->hit < ch->max_hit && number_range(1, 3) == 1)
         send_to_char("The gentle rain soothes and rejuvenates you.\n\r",ch);
         ch->hit += number_range(1,10);
         ch->mana += number_range(1,10);
         ch->move += number_range(1,10);
         if (ch->hit > ch->max_hit) ch->hit = ch->max_hit;
         if (ch->mana > ch->max_mana) ch->mana = ch->max_mana;
         if (ch->move > ch->max_move) ch->move = ch->max_move;
         update_pos(ch);
      }

      if (ch->regen_rate != 0)
      {
         if (ch->regen_rate > 0)
         regen = number_range(ch->regen_rate/2,ch->regen_rate);
         else
         regen = number_range(ch->regen_rate,ch->regen_rate/2);
         if (ch->hit < ch->max_hit || regen < 0)
         {
            if (regen > 0)
            ch->hit = UMIN(ch->hit + regen, ch->max_hit);
            else
            ch->hit = UMAX(ch->hit + regen, 1);
         }
      }
      if (ch->mn_regen_rate != 0)
      {
         if (ch->mn_regen_rate > 0)
         {
            regen = number_range(1, ch->mn_regen_rate);
         }
         else
         {
            regen = number_range(ch->mn_regen_rate, -1);
         }
         if (ch->mana < ch->max_mana || regen < 0)
         {
            if (regen > 0)
            {
               ch->mana = UMIN(ch->mana + regen, ch->max_mana);
            }
            else
            {
               ch->mana = UMAX(ch->mana + regen, 0);
            }
         }
      }

      /* hang drain */
      if (IS_AFFECTED2(ch, AFF_HANG))
      {
         MESSAGE * hung_message;
         char buf[MAX_STRING_LENGTH], arg[MAX_STRING_LENGTH];
         int totalmana=0, mana, sn;
         bool found = FALSE;

         if ( (hung_message = get_message_char(ch, MM_HANG1)) != NULL)
         {
            found = TRUE;
            ch->mana -= number_range(1, 5);
            if (ch->mana < 0)
            {
               ch->mana = 0;
            }
            strcpy(arg,hung_message->message_string);
            one_argument(arg, buf);
            sn = find_spell(ch, buf);
            mana = mana_cost(ch, skill_table[sn].min_mana, sn);
            totalmana += mana;
         }
         if ( (hung_message = get_message_char(ch, MM_HANG2)) != NULL)
         {
            found = TRUE;
            ch->mana -= number_range(1, 5);
            if (ch->mana < 0)
            {
               ch->mana = 0;
            }
            strcpy(arg,hung_message->message_string);
            one_argument(arg, buf);
            sn = find_spell(ch, buf);
            mana = mana_cost(ch, skill_table[sn].min_mana, sn);
            totalmana += mana;
         }
         if ( (hung_message = get_message_char(ch, MM_HANG3)) != NULL)
         {
            found = TRUE;
            ch->mana -= number_range(1, 5);
            if (ch->mana < 0)
            {
               ch->mana = 0;
            }
            ch->mana = UMAX(ch->mana - number_range(3,10), 0);
            strcpy(arg,hung_message->message_string);
            one_argument(arg, buf);
            sn = find_spell(ch, buf);
            mana = mana_cost(ch, skill_table[sn].min_mana, sn);
            totalmana += mana;
         }
         if ( (hung_message = get_message_char(ch, MM_HANG4)) != NULL)
         {
            found = TRUE;
            ch->mana -= number_range(1, 5);
            if (ch->mana < 0)
            {
               ch->mana = 0;
            }
            strcpy(arg,hung_message->message_string);
            one_argument(arg, buf);
            sn = find_spell(ch, buf);
            mana = mana_cost(ch, skill_table[sn].min_mana, sn);
            totalmana += mana;
         }
         if
         (
            found &&
            ch->mana < totalmana
         )
         {
            if ( (hung_message = get_message_char(ch, MM_HANG1)) != NULL) message_remove(hung_message);
            if ( (hung_message = get_message_char(ch, MM_HANG2)) != NULL) message_remove(hung_message);
            if ( (hung_message = get_message_char(ch, MM_HANG3)) != NULL) message_remove(hung_message);
            if ( (hung_message = get_message_char(ch, MM_HANG4)) != NULL) message_remove(hung_message);
            REMOVE_BIT(ch->affected_by2, AFF_HANG);
            send_to_char("Your hung spells dissipate into nothingness.\n\r", ch);
            act
            (
               "The tension in the charged air around $n eases suddenly.",
               ch,
               NULL,
               NULL,
               TO_ROOM
            );
         }
      }

      /* Wervdon was having troubles with this. Works now? -- Wicket */
      if
      (
         ch->position == POS_FIGHTING &&
         ch->fighting == NULL
      )
      {
         ch->position = POS_STANDING;
      }

      if
      (
         !(
            victim = ch->fighting
         ) ||
         ch->in_room == NULL
      )
      {
         continue;
      }

      if
      (
         IS_NPC(ch) &&
         !IS_NPC(ch->fighting) &&
         !IS_SET(ch->off_flags, NO_TRACK) &&
         !IS_AFFECTED(ch, AFF_CHARM) &&
         !IS_SET(ch->act, ACT_IS_HEALER) &&
         !IS_SET(ch->act, ACT_BANKER)
      )
      {
         ch->last_fought = ch->fighting->id;
      }

      if
      (
         IS_AWAKE(ch) &&
         ch->in_room == victim->in_room
      )
      {
         /*
         In round combat Nullified for certain players
         some chose to be peaceful, some were punished.
         */
         if
         (
            !(
               !IS_NPC(ch) &&
               IS_SET(ch->act2, PLR_NO_FIGHT)
            )
         )
         {
            multi_hit(ch, victim, TYPE_UNDEFINED);
         }
      }
      else
      {
         stop_fighting(ch, FALSE);
      }

      if ( IS_GUARDIAN_ANGEL(ch) )
      {
         if ( !ch->master || !IS_AFFECTED(ch, AFF_CHARM) )
         {
            act( "$n spreads $s wings and flies away.", ch, NULL, NULL, TO_ROOM );
            stop_fighting( ch, TRUE );
            char_from_room( ch );
            extract_char( ch, TRUE );
            continue;
         }

         if ( (ch->hit < ch->max_hit) && (number_percent() < 5) )
         {
            do_cast( ch, "heal" );
         }
      }

      if ( ( victim = ch->fighting ) == NULL )
      {
         continue;
      }

      if ( IS_NPC( ch ) )
      {
         if ( HAS_TRIGGER( ch, TRIG_FIGHT ) )
         {
            mp_percent_trigger( ch, victim, NULL, NULL, TRIG_FIGHT );
         }
         if ( HAS_TRIGGER( ch, TRIG_HPCNT ) )
         {
            mp_hprct_trigger( ch, victim );
         }
      }

      /*
      * Fun for the whole family!
      */
      check_assist(ch, victim);
   }

   return;
}

/* for auto assisting */
void check_assist(CHAR_DATA* ch, CHAR_DATA* victim)
{
   CHAR_DATA* rch;
   CHAR_DATA* rch_next;

   if (!check_room(ch, TRUE, "Purge in check_assist()"))
   {
      return;
   }
   if
   (
      IS_NPC(ch) &&
      IS_AFFECTED(ch, AFF_CHARM) &&
      ch->master != NULL &&
      ch->master == victim
   )
   {
      return;
   }

   for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
   {
      rch_next = rch->next_in_room;

      if (!IS_NPC(rch) && rch->ghost > 0)
      {
         continue;
      }

      if (IS_AFFECTED(rch, AFF_CALM))
      {
         continue;
      }
      if (IS_AWAKE(rch) && rch->fighting == NULL)
      {

         /* NPC assisting group (for charm, zombies, elementals..added by Ceran */
         if
         (
            IS_NPC(rch) &&
            IS_AFFECTED(rch, AFF_CHARM)
         )
         {
            if
            (
               (
                  /* Do not assist against master */
                  rch->master == NULL ||
                  rch->master != victim
               ) &&
               is_same_group(rch, ch)
            )
            {
               multi_hit(rch, victim, TYPE_UNDEFINED);
            }
            /* Charmed mobs only help group, done with assist */
            continue;
         }

         /* PCs next */
         if (!IS_NPC(ch) || IS_AFFECTED(ch, AFF_CHARM))
         {
            /* First check defending */
            if (rch->defending != NULL)
            {
               CHAR_DATA* fch;

               fch = ch->fighting;
               if
               (
                  rch->defending != NULL &&
                  rch->defending == ch &&
                  fch != NULL &&
                  fch->fighting == ch &&
                  number_percent() <
                  UMAX
                  (
                     get_skill
                     (
                        rch,
                        gsn_defend
                     ),
                     2
                  ) &&
                  number_percent() > 40 &&
                  number_percent() < UMAX(get_skill(rch, gsn_rescue), 2)
               )
               {
                  act
                  (
                     "$n leaps to $N's rescue!",
                     rch,
                     NULL,
                     ch,
                     TO_NOTVICT
                  );
                  act
                  (
                     "$n leaps to your rescue!",
                     rch,
                     NULL,
                     ch,
                     TO_VICT
                  );
                  act
                  (
                     "You leap to $N's rescue!",
                     rch,
                     NULL,
                     ch,
                     TO_CHAR
                  );

                  if (is_safe(rch, fch, IS_SAFE_SILENT))
                  {
                     continue;
                  }

                  WAIT_STATE(rch, skill_table[gsn_rescue].beats);
                  WAIT_STATE(ch, 12);
                  check_improve
                  (
                     rch,
                     gsn_corrupt("defend", &gsn_defend),
                     TRUE,
                     1
                  );

                  stop_fighting(fch, FALSE);
                  stop_fighting(ch, FALSE);

                  set_fighting(rch, fch);
                  set_fighting(fch, rch);
                  if
                  (
                     IS_NPC(fch) &&
                     (fch->house != 0)
                  )   /* Is this where to fix it? - Kye - duh*/
                  {
                     set_fighting(ch, fch);
                  }

                  continue;
               }
            }


            if
            (
               (
                  (
                     !IS_NPC(rch) &&
                     IS_SET(rch->act, PLR_AUTOASSIST)
                  ) ||
                  IS_AFFECTED(rch, AFF_CHARM)
               ) &&
               is_same_group(ch, rch) &&
               !is_safe(rch, victim, IS_SAFE_SILENT) &&
               !is_safe(victim, rch, IS_SAFE_SILENT)
            )
            {
               if (!IS_NPC(victim))
               {
                  /*
                  No yelling about assisting
                  char buf[MAX_STRING_LENGTH];
                  sprintf
                  (
                  buf,
                  "Help! %s is assisting %s!",
                  PERS(rch, victim),
                  PERS(ch, victim)
                  );
                  do_myell(victim,buf);
                  */
                  sprintf
                  (
                     log_buf,
                     "[%s] assisted [%s] against [%s] at %d",
                     rch->name,
                     ch->name,
                     victim->name,
                     ch->in_room->vnum
                  );
                  log_string(log_buf);
               }
               multi_hit(rch, victim, TYPE_UNDEFINED);
               continue;
            }
         }

         /* now check the NPC cases */
         if
         (
            IS_NPC(rch) &&
            (
               (
                  rch->in_room->house != 0 &&
                  (
                     rch->pIndexData->vnum < rch->in_room->area->min_vnum ||
                     rch->pIndexData->vnum > rch->in_room->area->max_vnum
                  )
               ) ||
               IS_AFFECTED(rch, AFF_CHARM)
            )
         )
         {
            /* Summoned help does not assist. */
            continue;
         }
         /* quick check for ASSIST_PLAYER */
         if
         (
            !IS_NPC(ch) &&
            IS_NPC(rch) &&
            IS_SET(rch->off_flags, ASSIST_PLAYERS) &&
            rch->level + 6 > victim->level
         )
         {
            do_emote(rch, "screams and attacks!");
            multi_hit(rch, victim, TYPE_UNDEFINED);
            continue;
         }

         if
         (
            IS_NPC(ch) &&
            !IS_AFFECTED(ch, AFF_CHARM) &&
            !is_affected(ch, gsn_propaganda)
         )
         {
            if
            (
               (
                  IS_NPC(rch) &&
                  IS_SET(rch->off_flags, ASSIST_ALL)
               ) ||
               (
                  IS_NPC(rch) &&
                  rch->group &&
                  rch->group == ch->group
               ) ||
               (
                  IS_NPC(rch) &&
                  rch->race == ch->race &&
                  IS_SET(rch->off_flags, ASSIST_RACE)
               ) ||
               (
                  IS_NPC(rch) &&
                  IS_SET(rch->off_flags, ASSIST_ALIGN) &&
                  (
                     (
                        IS_GOOD(rch) &&
                        IS_GOOD(ch)
                     ) ||
                     (
                        IS_EVIL(rch) &&
                        IS_EVIL(ch)
                     ) ||
                     (
                        IS_NEUTRAL(rch) &&
                        IS_NEUTRAL(ch)
                     )
                  )
               ) ||
               (
                  rch->pIndexData == ch->pIndexData &&
                  IS_SET(rch->off_flags, ASSIST_VNUM)
               )
            )
            {
               CHAR_DATA* vch;
               CHAR_DATA* target;
               int number;

               if (number_bits(1) == 0)
               {
                  continue;
               }

               target = NULL;
               number = 0;
               for (vch = ch->in_room->people; vch; vch = vch->next)
               {
                  if
                  (
                     can_see(rch, vch) &&
                     is_same_group(vch, victim) &&
                     number_range(0, number) == 0
                  )
                  {
                     target = vch;
                     number++;
                  }
               }

               if (target != NULL)
               {
                  do_emote(rch, "screams and attacks!");
                  multi_hit(rch, target, TYPE_UNDEFINED);
               }
            }
         }
      }
   }
}

bool check_tanking(CHAR_DATA *ch){
   bool is_tanking=FALSE;
   CHAR_DATA *victim;

   /* archery hack so mobs can use it */
   if (IS_NPC(ch))
   return FALSE;

   for (victim = ch->in_room->people;victim != NULL;victim =victim->next_in_room)
   if (victim->fighting == ch)
   is_tanking = TRUE;
   return is_tanking;
}

bool fire_volley(CHAR_DATA* ch, CHAR_DATA* victim, bool check_only)
{
   OBJ_DATA* obj;
   OBJ_DATA* wield;
   OBJ_DATA* bow;
   AFFECT_DATA* af = NULL;
   int n_attacks;
   int n_arrows;
   int accuracy;
   int cnt;
   int dt;
   int dam_type;
   int dam = 0;
   int dam_mod = 0;
   bool dont_extract = FALSE;
   bool result;
   long id;
   int chance;

   bow = get_eq_char(ch, WEAR_WIELD);
   if (bow == NULL)
   {
      if (!check_only)
      {
         bug("Fire Volley: no bow in room %d", ch->in_room->vnum);
      }
      return FALSE;
   }
   if
   (
      victim == NULL &&
      !check_only
   )
   {
      bug("Fire Volley: no victim", 0);
      return FALSE;
   }
   if
   (
      (
         obj = get_eq_char(ch, WEAR_ABOUT)
      ) == NULL ||
      obj->item_type != ITEM_CONTAINER ||
      !IS_SET(obj->value[1], CONT_IS_QUIVER) ||
      obj->contains == NULL
   )
   {
      return FALSE;
   }
   if (obj->pIndexData->vnum == OBJ_VNUM_ENDLESS_QUIVER)
   {
      dont_extract = TRUE;
   }
   obj = obj->contains;
   if
   (
      obj->item_type != ITEM_WEAPON ||
      obj->value[0] != WEAPON_ARROWS
   )
   {
      return FALSE;
   }
   /* at this point obj is the arrows to fire and bow is the bow */
   n_arrows = obj->weight;
   if (n_arrows <= 0)
   {
      bug("Fire Volley: no arrows %d", obj->pIndexData->vnum);
      return FALSE;
   }
   /* Prevent use of arrows that are not yours */
   if
   (
      obj->owner &&
      str_cmp(obj->owner, "none") &&
      str_cmp(obj->owner, ch->name)
   )
   {
      if (!check_only)
      {
         act("You are zapped by $p and drop it.", ch, obj, NULL, TO_CHAR);
         act("$n is zapped by $p and drops it.",  ch, obj, NULL, TO_ROOM);
         obj_from_obj(obj);
         if (ch->in_room)
         {
            obj_to_room(obj, ch->in_room);
         }
         else
         {
            extract_obj(obj, FALSE);
            act("$p dissolves into smoke.", ch, obj, NULL, TO_CHAR);
         }
      }
      return FALSE;
   }
   if (check_only)
   {
      return TRUE;
   }
   /* find number of attacks and accuracy */
   n_attacks = 1;
   chance = get_weapon_skill(ch, gsn_archery);
   accuracy = chance - 60;
   if (IS_AFFECTED(ch, AFF_HASTE))
   {
      n_attacks++;
   }
   if (IS_AFFECTED(ch, AFF_SLOW))
   {
      n_attacks--;
   }
   if (number_percent() < get_skill(ch, gsn_second_attack) / 2)
   {
      n_attacks++;
   }
   if (number_percent() < get_skill(ch, gsn_third_attack) / 4)
   {
      n_attacks++;
   }
   if (number_percent() < get_skill(ch, gsn_fourth_attack) / 5)
   {
      n_attacks++;
   }
   if (!bow->enchanted)
   {
      for (af = bow->pIndexData->affected; af != NULL; af = af->next)
      {
         if (af->location == APPLY_ATTACKS)
         {
            n_attacks += af->modifier;
         }
         if (af->location == APPLY_ACCURACY)
         {
            accuracy += af->modifier;
         }
      }
   }
   for (af = bow->affected; af != NULL; af = af->next)
   {
      if (af->location == APPLY_ATTACKS)
      {
         n_attacks += af->modifier;
      }
      else if (af->location == APPLY_ACCURACY)
      {
         accuracy += af->modifier;
      }
   }
   if (!obj->enchanted)
   {
      for (af = obj->pIndexData->affected; af != NULL; af = af->next){
         if (af->location == APPLY_DAMROLL)
         {
            dam_mod += af->modifier;
         }
         else if (af->location == APPLY_ACCURACY)
         {
            accuracy += af->modifier;
         }
      }
   }
   for (af = obj->affected; af != NULL; af = af->next)
   {
      if (af->location == APPLY_DAMROLL)
      {
         dam_mod += af->modifier;
      }
      else if (af->location == APPLY_ACCURACY)
      {
         accuracy += af->modifier;
      }
   }
   if (accuracy > 99)
   {
      accuracy = 99;
   }
   if (accuracy > chance)
   {
      accuracy = chance;
   }
   n_attacks = URANGE(1, n_attacks, 6);
   if
   (
      !dont_extract &&
      n_attacks > n_arrows
   )
   {
      n_attacks = n_arrows;
   }

   /*        dt = TYPE_HIT + obj->value[3]; */
   dt = gsn_archery;
   dam_type = attack_table[obj->value[3]].damage;
   wield = obj;
   id = victim->id;
   set_fighting(ch, victim);
   for (cnt = 0; cnt < n_attacks; cnt++)
   {
      if
      (
         victim == NULL ||
         victim->id != id ||
         ch->in_room == NULL ||
         victim->in_room != ch->in_room ||
         victim->ghost
      )
      {
         break;
      }
      if
      (
         number_percent() < accuracy &&
         number_percent() < chance
      )
      {
         check_improve(ch, gsn_archery, TRUE, 5);
         if
         (
            !check_dodge(ch, victim, dt) &&
            !check_acrobatics(ch, victim, dt) &&
            !check_tumble(ch, victim, dt) &&
            !check_shield_block(ch, victim, dt) &&
            !check_side_step(ch, victim, dt)
         )
         {
            dam = dice(obj->value[1], obj->value[2]);
            dam += GET_DAMROLL(ch);
            dam += dam_mod;
            dam = dam * get_weapon_skill(ch, gsn_archery) / 100;
            if (ch->level < 40)
            {
               dam = dam * ch->level / 40;
            }
            if (IS_WEAPON_STAT(obj, WEAPON_SHARP))
            {
               int percent;

               if ((percent = number_percent()) <= (accuracy / 5))
               {
                  dam = 2 * dam + (dam * 2 * percent / 100);
               }
            }
            if
            (
               obj->pIndexData->vnum == OBJ_VNUM_FIERY_ARROWS &&
               number_percent() < 7
            )
            {
               act
               (
                  "$n is burned by the fiery arrows.",
                  victim,
                  NULL,
                  NULL,
                  TO_ROOM
               );
               act
               (
                  "You are burned by the fiery arrows.",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               dam = dam * 5 / 2;
            }
            result = damage(ch, victim, dam, dt, dam_type, TRUE);
            if (!result)
            {
               continue;
            }
            if (ch->fighting == victim && (wield != NULL && IS_WEAPON_STAT(wield,WEAPON_POISON)))
            {
               int level;
               AFFECT_DATA *poison, af;
               AFFECT_DATA *af2;

               poison = NULL;
               if (wield != NULL)
               {
                  if ((poison = affect_find(wield->affected,gsn_poison)) == NULL)
                  level = wield->level;
                  else
                  level = poison->level;
               }
               else
               {
                  level = ch->level;
               }

               if (!saves_spell(ch, level / 2,victim,DAM_POISON, SAVE_BREATH))
               {
                  send_to_char("You feel poison coursing through your veins.\n\r",
                  victim);
                  act("$n is poisoned by the venom on $p.",victim, wield, NULL,TO_ROOM);


                  af.where     = TO_AFFECTS;
                  af.type      = gsn_poison;
                  af.level     = level * 3/4;
                  af.duration  = level / 2;
                  af.location  = APPLY_STR;
                  af.modifier  = -1;
                  af.bitvector = AFF_POISON;
                  affect_join( victim, &af, 10 );
                  af2 =affect_find(victim->affected,gsn_poison);
                  if (af2 != NULL)
                  {
                     free_string(af2->caster);
                     if
                     (
                        IS_NPC(ch) &&
                        IS_AFFECTED(ch, AFF_CHARM) &&
                        ch->master &&
                        !IS_NPC(ch->master)
                     )
                     {
                        af2->caster = str_dup(ch->master->name);
                     }
                     else
                     {
                        af2->caster = str_dup(ch->name);
                     }
                  }
               }

               /* weaken the poison if it's temporary */
               if (poison != NULL)
               {
                  poison->level = UMAX(0,poison->level - 2);
                  poison->duration = UMAX(0,poison->duration - 1);

                  if (poison->level == 0 || poison->duration == 0)
                  act("The poison on $p has worn off.",ch,wield,NULL,TO_CHAR);
               }
            }
            if (result && wield != NULL)
            {
               int dam; /* moved down here to avoid a warning */
               if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_VAMPIRIC)
               && number_percent() < 13)
               {
                  dam = number_range(wield->level/2, wield->level);
                  act("$p draws life from $n.",victim,wield,NULL,TO_ROOM);
                  act("You feel $p drawing your life away.",
                  victim,wield,NULL,TO_CHAR);
                  damage(ch,victim,dam,0,DAM_NEGATIVE,FALSE);
                  ch->hit = UMIN(ch->hit + dam, ch->max_hit);
               }

               if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FLAMING)
               && number_percent() < 15)
               {
                  dam = number_range(1,wield->level / 4 + 1);
                  act("$n is burned by $p.",victim,wield,NULL,TO_ROOM);
                  act("$p sears your flesh.",victim,wield,NULL,TO_CHAR);
                  fire_effect( (void *) victim,wield->level/2,dam,TARGET_CHAR);
                  damage(ch,victim,dam,0,DAM_FIRE,FALSE);
               }

               if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FROST)
               && number_percent() < 15)
               {
                  dam = number_range(1,wield->level / 6 + 2);
                  act("$p freezes $n.",victim,wield,NULL,TO_ROOM);
                  act("The cold touch of $p surrounds you with ice.",
                  victim,wield,NULL,TO_CHAR);
                  cold_effect(victim,wield->level/2,dam,TARGET_CHAR);
                  damage(ch,victim,dam,0,DAM_COLD,FALSE);
               }

               if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_SHOCKING)
               && number_percent() < 15)
               {
                  dam = number_range(1,wield->level/5 + 2);
                  act("$n is struck by lightning from $p.",victim,wield,NULL,TO_ROOM);
                  act("You are shocked by $p.",victim,wield,NULL,TO_CHAR);
                  shock_effect(victim,wield->level/2,dam,TARGET_CHAR);
                  damage(ch,victim,dam,0,DAM_LIGHTNING,FALSE);
               }

               if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_DROWNING)
               && number_percent() < 15)
               {
                  dam = number_range(1,wield->level/5 + 2);
                  act("$n is deluged by water spouting from $p.",victim,wield,NULL,TO_ROOM);
                  act("You are smothered by a deluge of water spouting from $p.",victim,wield,NULL,TO_CHAR);
                  drowning_effect(victim,wield->level/2,dam,TARGET_CHAR);
                  damage(ch,victim,dam,0,DAM_DROWNING,FALSE);
               }
               if
               (
                  ch->fighting == victim &&
                  IS_WEAPON_STAT(wield, WEAPON_RESONATING) &&
                  number_percent() < 15
               )
               {
                  dam = number_range(1, wield->level/5 + 2);
                  act
                  (
                     "$n is struck by the sonic resonance from $p.",
                     victim,
                     wield,
                     NULL,
                     TO_ROOM
                  );
                  act
                  (
                     "You are struck by the sonic resonance from $p.",
                     victim,
                     wield,
                     NULL,
                     TO_CHAR
                  );
                  resonating_effect
                  (
                     victim,
                     wield->level/2,
                     dam,
                     TARGET_CHAR
                  );
                  damage
                  (
                     ch,
                     victim,
                     dam,
                     0,
                     DAM_SOUND,
                     FALSE
                  );
               }
            }
         }
      }
      else
      {
         check_improve(ch, gsn_archery, FALSE, 5);
         damage(ch, victim, 0, dt, dam_type, TRUE);
      }
   }
   if (!dont_extract)
   {
      obj->weight -= n_attacks;
      ch->carry_weight -= n_attacks;
   }
   if (obj->weight <= 0)
   {
      extract_obj(obj, FALSE);
      send_to_char("You have fired your last arrow.\n\r", ch);
   }
   if (victim != NULL && victim-> fighting == NULL)
   {
      multi_hit(victim, ch, TYPE_UNDEFINED);
   }
   return TRUE;
}

/*
* Do one group of attacks.
*/
void multi_hit( CHAR_DATA *ch, CHAR_DATA *victim, int dt )
{
   int     chance;
   int        dual_chance;
   int    trinal_chance;
   OBJ_DATA *obj;
   OBJ_DATA *wield;
   int     is_dancing;
   CHAR_DATA *leader;
   int  tactics;

   /*
   In round combat Nullified for certain players
   if !IS_NPC(ch) && IS_SET(ch->act2, PLR_NO_FIGHT)
   they don't get a fight.. so
   if an npc, or its not set.., they DO get a fight
   */
   if
   (
      !IS_NPC(ch) &&
      IS_SET(ch->act2, PLR_NO_FIGHT)
   )
   {
      act
      (
         "$n refuses to actively fight $N.",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      act
      (
         "$n refuses to actively fight you.",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "You refuse to actively fight $N.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   leader = (ch->leader != NULL) ? ch->leader : ch;

   tactics = 0;
   if (get_skill(leader, gsn_battle_tactics) > 50 &&
   has_skill(leader, gsn_battle_tactics))
   {
      if (get_skill(leader,gsn_battle_tactics) < number_percent())
      tactics = 5;
   }

   if (is_safe(ch,victim, 0))
   {
      return;
   }

   if (IS_NPC(ch) && (ch->pIndexData->vnum == MOB_VNUM_VOID_ELEMENTAL) &&
   ((obj = get_eq_char(victim,WEAR_BRAND)) != NULL ) &&
   (obj->pIndexData->vnum == 15901))
   {
      stop_fighting(ch, TRUE);
      ch->last_fought = 0;
      if (ch->master != NULL)
      {
         switch (number_range(1,4))
         {
            case 1: do_say(ch, "I refuse to harm a creature of the Void!"); break;
            case 2: do_say(ch, "No, Master, YOU do the attacking. That one bears the Lord's blessing.");
            break;
            case 3: do_say(ch, "By divine decree, I cannot touch this one."); break;
            case 4: do_say(ch, "Never! The Trigram holds my soul!");
         }
         if (((((obj = get_eq_char(ch->master,WEAR_BRAND)) != NULL) && (obj->pIndexData->vnum != 15901))
         || (obj == NULL)) && (number_range(1,100) < 34))
         {
            switch (number_range(1,4))
            {
               case 1: do_say(ch, "Master, you have made a very big mistake."); break;
               case 2: do_say(ch, "By the will of the Eye of Darkness, you will DIE for this insult!");
               break;
               case 3: do_say(ch, "For asking me to destroy myself, you must die."); break;
               case 4: do_say(ch, "Pay for your foolishness in blood!"); break;
            }
            victim = ch->master;
            stop_follower(ch);
            multi_hit(ch, victim, TYPE_UNDEFINED);
         } else
         do_sleep(ch,"");
      } else
      {
         switch (number_range(1,4))
         {
            case 1: do_say(ch, "Oh, a creature of the Void. I would never attack you.");
            case 2: do_say(ch, "I apologize for considering an attack upon you, follower of Xurinos.");
            case 3: do_say(ch, "Lord, grant me forgiveness for thinking to attack your branded!");
            case 4: do_say(ch, "The Trigram holds my soul; you will not be harmed by me.");
         }
      }
      return;
   }

   if (!IS_NPC(ch)){
      if (victim->house != 0)
      if (IS_SET(ch->pcdata->allied_with,powtwo(2,victim->house)))
      REMOVE_BIT(ch->pcdata->allied_with,powtwo(2,victim->house));
   }
   if (is_affected(ch,gsn_trapstun))
   {
      if (number_percent() < 20)
      {
         send_to_char("You break free of your snare.\n\r",ch);
         act("$n breaks free from the snare.",ch,0,0,TO_ROOM);
         affect_strip(ch,gsn_trapstun);
      }
   }
   if (is_affected(victim,gsn_trapstun))
   {
      if (number_percent() < 10)
      {
         send_to_char("You break free of your snare.\n\r",victim);
         act("$n breaks free from the snare.",victim,0,0,TO_ROOM);
         affect_strip(victim,gsn_trapstun);
      }
   }
   /*
   if (ch->class == GUILD_MONK -1){
   if ((obj = get_eq_char(ch,WEAR_HOLD)) != NULL){
   obj_from_char(obj);
   obj_to_char(obj,ch);
   send_to_char("You prepare for the coming battle and remove your held item.\n\r",ch);
   }
   }
   */
   if (is_affected(ch,gsn_stealth)){
      send_to_char("Your fight begins to draw attention to you!\n\r",ch);
      affect_strip(ch,gsn_stealth);
   }
   if (is_affected(ch,gsn_healing_trance)){
      send_to_char("You cease to meditate.\n\r",ch);
      affect_strip(ch,gsn_healing_trance);
   }
   if (is_affected(ch,gsn_spiritwalk)){
      send_to_char("Your body has come under attack!\n\r",ch);
      do_return(ch,"");
   }
   if (is_affected(ch,gsn_feign_death))
   {
      send_to_char("You are no longer feigning death.\n\r",ch);
      affect_strip(ch, gsn_feign_death);
   }

   is_dancing = check_dance_venom(ch,victim);
   if (is_affected(ch,gsn_timestop) || is_affected(ch,gsn_stone) || is_affected(ch,gsn_freeze))
   {
      if (ch->fighting != NULL)
      ch->fighting = NULL;
      return;
   }

   /* no attacks for stunnies -- just a check */
   if (ch->position < POS_RESTING)
   return;

   /* archery code */
   if
   (
      (
         (
            obj = get_eq_char(ch, WEAR_WIELD)
         ) != NULL
      ) &&
      obj->value[0] == WEAPON_BOW &&
      !check_tanking(ch) &&
      dt != gsn_ambush &&
      fire_volley(ch, victim, FALSE)
   )
   {
      return;
   }

   if
   (
      IS_NPC(ch) &&
      ch != victim
   )
   {
      if
      (
         IS_NPC(victim) &&
         ch->fighting == NULL &&
         ch->master != NULL &&
         ch->master->in_room == ch->in_room &&
         victim->master != NULL &&
         victim->in_room == victim->master->in_room &&
         ch->master != victim->master
      )
      {
         char buf[MAX_STRING_LENGTH];

         sprintf
         (
            buf,
            "Help! %s's followers are attacking mine!",
            PERS(ch->master, victim->master)
         );
         do_myell(victim->master, buf);
         sprintf
         (
            log_buf,
            "[%s] ordered an attack on [%s] at %d",
            ch->master->name,
            victim->master->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
      }
      mob_hit(ch, victim, dt);
      return;
   }

   one_hit( ch, victim, dt );
   if (is_dancing)
   {
      one_hit(ch, victim, dt);
   }
   if (ch->fighting != victim)
   {
      return;
   }
   check_bracelets(ch);
   wing_beating(ch);

   if
   (
      ch->fighting == victim &&
      (
         (
            IS_NPC(ch) &&
            ch->pIndexData->vnum == OBJ_VNUM_MOB_MEDUSA
         ) ||
         (
            (obj = get_eq_char(ch, WEAR_HEAD)) != NULL &&
            obj->pIndexData->vnum == OBJ_VNUM_MEDUSA_WIG
         )
      )
   )
   {
      check_medusa(ch);
   }

   if( (obj = get_eq_char(ch,WEAR_BRAND)) != NULL )
   {
      switch( obj->pIndexData->vnum )
      {
         case 14600:
         check_adorno_brand(ch,obj);
         break;
         case 28903:
         if (ch->fighting == victim)
         check_runge_brand(ch,victim);
         break;
         case OBJ_VNUM_BATTLEAXE_BRAND:
         check_battleaxe_brand(ch, victim);
         break;
         /* Check for "Spark" power during battle for Hector's brand - Wicket */
         case OBJ_VNUM_HECTOR_BRAND:
         check_hector_brand(ch, victim);
         break;
         /* Check for "Misdirection" power during battle for Utara's brand - Wicket
         case OBJ_VNUM_UTARA_BRAND:
         check_gremlin_misdirection(ch,victim);
         break; */
         /*Check for fire blast for xeonauz's brand*/
         case 980:
         check_xeonauz_brand(ch, victim);
         break;
         case (OBJ_VNUM_OBLIVION_BRAND):
         {
            check_vrrin_brand(ch, victim);
            break;
         }
         case (OBJ_VNUM_DRINLINDA_BRAND):
         {
            check_drinlinda_attack_brand(ch, victim);
            break;
         }
         case (OBJ_VNUM_DRITHENTIR_BRAND):
         {
            check_drithentir_attack_brand(ch, victim);
            break;
         }
      }
   }

   obj = get_eq_char(ch,WEAR_NECK_1);
   if (obj != NULL && obj->pIndexData->vnum == 27757)
   check_water_symbol(ch,victim,obj);

   obj = get_eq_char(ch,WEAR_NECK_2);
   if (obj != NULL && obj->pIndexData->vnum == 27757)
   check_water_symbol(ch,victim,obj);

   obj = get_eq_char(ch,WEAR_ABOUT);
   if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_ROBE_LIGHT)
   check_robe_light(ch,obj);

   obj = get_eq_char(ch,WEAR_FINGER_L);
   if( obj != NULL
   && obj->pIndexData->vnum == OBJ_VNUM_CONCAT_RING &&
   ch->fighting
   && number_percent() < 5 )
   {
      magic_spell
      (
         ch,
         "blah",
         CAST_BITS_PLR_SKILL,
         obj->level,
         gsn_concatenate
      );
   }

   obj = get_eq_char(ch,WEAR_FINGER_R);
   if( obj != NULL
   && obj->pIndexData->vnum == OBJ_VNUM_CONCAT_RING &&
   ch->fighting
   && number_percent() < 5 )
   {
      magic_spell
      (
         ch,
         "blah",
         CAST_BITS_PLR_SKILL,
         obj->level,
         gsn_concatenate
      );
   }

   obj = get_eq_char(ch,WEAR_WIELD);
   if (obj != NULL && obj->pIndexData->vnum == 27307)
   check_staff_gardener(ch,obj);
   if (obj != NULL && obj->pIndexData->vnum == 27751)
   check_mace_blessed(ch,victim,obj);
   if (obj != NULL && obj->pIndexData->vnum == 27503)
   check_silver_hammer(ch,obj);
   if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_GENOCIDE_AXE)
   check_genocide_axe(ch,victim,obj);
   if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_SWORD_DEMONS)
   check_sword_demons(ch,victim, obj);
   if (obj != NULL && obj->pIndexData->vnum == 27504)
   check_thm_sword(ch,victim,obj);
   if (obj != NULL && obj->pIndexData->vnum == 27505)
   check_sword_marcil(ch,victim,obj);

   obj = get_eq_char(ch,WEAR_DUAL_WIELD);
   if (obj != NULL && obj->pIndexData->vnum == 27307)
   check_staff_gardener(ch,obj);
   if (obj != NULL && obj->pIndexData->vnum == 27751)
   check_mace_blessed(ch,victim,obj);
   if (obj != NULL && obj->pIndexData->vnum == 27503)
   check_silver_hammer(ch,obj);
   if (obj != NULL && obj->pIndexData->vnum == 27504)
   check_thm_sword(ch,victim,obj);
   if (obj != NULL && obj->pIndexData->vnum == 27505)
   check_sword_marcil(ch,victim,obj);
   if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_GENOCIDE_AXE)
   check_genocide_axe(ch,victim,obj);
   if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_SWORD_DEMONS)
   check_sword_demons(ch,victim,obj);

   if ( (wield = get_eq_char(ch,WEAR_WIELD)) != NULL)
   {
      if (ch->fighting == victim && wield->pIndexData->vnum == 27037)
      obj_fight_27037(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27039)
      obj_fight_27039(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27040)
      obj_fight_27040(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27041)
      obj_fight_27041(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == OBJ_VNUM_TALON)
      check_blue_talon(ch,ch->fighting);

   }
   if ((obj = get_eq_char(ch,WEAR_WRIST_L)) != NULL)
   {
      if (obj != NULL && obj->pIndexData->vnum == 2732)
      check_honor_bracer(ch);
   }
   if ((obj = get_eq_char(ch,WEAR_WRIST_R)) != NULL)
   {
      if (obj != NULL && obj->pIndexData->vnum == 2732)
      check_honor_bracer(ch);
   }
   if ( ch->fighting != victim || dt == gsn_backstab || (dt ==  gsn_ambush) )
   return;

   if (IS_AFFECTED(ch,AFF_HASTE))
   one_hit(ch,victim,dt);

   chance = get_skill(ch,gsn_second_attack)/2;
   if (chance != 0) chance += tactics;
   dual_chance = get_skill(ch,gsn_dual_wield)/2;
   trinal_chance = get_skill(ch,gsn_tertiary_wield)/4;

   if (IS_AFFECTED(ch,AFF_SLOW))
   {
      chance /= 2;
      dual_chance /= 2;
      trinal_chance /= 2;
   }

   if (chance == 1)
   {
      chance = 2;
   }
   if (dual_chance  == 1)
   {
      dual_chance = 2;
   }
   if (trinal_chance == 1)
   {
      trinal_chance = 2;
   }
   if ( number_percent( ) < chance)
   {
      one_hit( ch, victim, dt );
      if (is_dancing)
      one_hit(ch,victim, dt);
      check_improve(ch,gsn_second_attack,TRUE,5);
      if ( ch->fighting != victim )
      return;
   }
   check_bracelets(ch);
   wing_beating(ch);

   if ( (wield = get_eq_char(ch,WEAR_WIELD)) != NULL)
   {
      if (ch->fighting == victim && wield->pIndexData->vnum == 27037)
      obj_fight_27037(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27039)
      obj_fight_27039(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27040)
      obj_fight_27040(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27041)
      obj_fight_27041(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == OBJ_VNUM_TALON)
      check_blue_talon(ch,ch->fighting);

   }
   if ((obj = get_eq_char(ch,WEAR_WRIST_L)) != NULL)
   {
      if (obj != NULL && obj->pIndexData->vnum == 2732)
      check_honor_bracer(ch);
   }
   if ((obj = get_eq_char(ch,WEAR_WRIST_R)) != NULL)
   {
      if (obj != NULL && obj->pIndexData->vnum == 2732)
      check_honor_bracer(ch);
   }

   if (get_eq_char(ch,WEAR_DUAL_WIELD) != NULL
   && (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_second_attack]) > 10)
   {
      if (number_percent( ) < dual_chance)
      {
         one_hit(ch,victim,gsn_dual_wield);
         if (is_dancing)
         one_hit(ch,victim, dt);

         check_improve(ch,gsn_dual_wield,TRUE,3);
         if (ch->fighting != victim)
         return;
      }
      else
      check_improve(ch,gsn_dual_wield,FALSE,3);
   }

   if (get_eq_char(ch,WEAR_TERTIARY_WIELD) != NULL
   && (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_second_attack]) > 10)
   {
      if (number_percent( ) < trinal_chance)
      {
         one_hit(ch,victim,gsn_tertiary_wield);
         if (is_dancing)
         one_hit(ch,victim, dt);

         check_improve(ch,gsn_tertiary_wield,TRUE,3);
         if (ch->fighting != victim)
         return;
      }
      else
      check_improve(ch,gsn_tertiary_wield,FALSE,3);
   }

   if (!IS_NPC(ch) && !str_cmp(class_table[ch->class].name,"monk")
   &&  (get_eq_char(ch,WEAR_WIELD) != NULL) )
   return;     /* Monks can't get 3/4th attack with a weapon */

   chance = get_skill(ch,gsn_third_attack)/4;
   if (chance != 0) chance += tactics;


   if (chance == 1)
   {
      chance = 2;
   }

   if (IS_AFFECTED(ch,AFF_SLOW))
   chance = 0;;

   if ( number_percent( ) < chance)
   {
      one_hit( ch, victim, dt );
      if (is_dancing)
      one_hit(ch,victim, dt);
      check_improve(ch,gsn_third_attack,TRUE,6);
      if ( ch->fighting != victim )
      return;
   }

   dual_chance = get_skill(ch,gsn_dual_wield)/4;
   if (get_eq_char(ch,WEAR_DUAL_WIELD) != NULL
   && (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_third_attack]) > 10)
   {
      if (number_percent( ) < dual_chance)
      {
         one_hit(ch,victim,gsn_dual_wield);
         if (is_dancing)
         one_hit(ch,victim, dt);
         check_improve(ch,gsn_dual_wield,TRUE,3);
         if (ch->fighting != victim)
         return;
      }
      else
      check_improve(ch,gsn_dual_wield,FALSE,3);
   }

   trinal_chance = get_skill(ch,gsn_tertiary_wield)/5;
   if (get_eq_char(ch,WEAR_TERTIARY_WIELD) != NULL
   && (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_third_attack]) > 10)
   {
      if (number_percent( ) < trinal_chance)
      {
         one_hit(ch,victim,gsn_tertiary_wield);
         if (is_dancing)
         one_hit(ch,victim, dt);
         check_improve(ch,gsn_tertiary_wield,TRUE,3);
         if (ch->fighting != victim)
         return;
      }
      else
      check_improve(ch,gsn_tertiary_wield,FALSE,3);
   }

   chance = get_skill(ch,gsn_fourth_attack)/5;
   if (chance != 0) chance += tactics;

   if (chance == 1)
   {
      chance = 2;
   }
   if (IS_AFFECTED(ch,AFF_SLOW))
   chance /= 2;

   if ( number_percent() < chance )
   {
      one_hit( ch, victim, dt );
      if (is_dancing)
      one_hit(ch,victim, dt);
      check_improve(ch,gsn_fourth_attack,TRUE,6);
      if (ch->fighting != victim )
      return;
   }

   dual_chance = get_skill(ch,gsn_dual_wield)/8;

   if (get_eq_char(ch,WEAR_DUAL_WIELD) != NULL
   && (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_fourth_attack]) > 10)
   {
      if (number_percent( ) < dual_chance)
      {
         one_hit(ch,victim,gsn_dual_wield);
         if (is_dancing)
         one_hit(ch,victim, dt);
         check_improve(ch,gsn_dual_wield,TRUE,6);
         if (ch->fighting != victim)
         return;
      }
      else
      check_improve(ch,gsn_dual_wield,FALSE,5);
   }

   trinal_chance = get_skill(ch,gsn_tertiary_wield)/8;
   if (get_eq_char(ch,WEAR_TERTIARY_WIELD) != NULL
   && (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_fourth_attack]) > 85)
   {
      if (number_percent( ) < trinal_chance)
      {
         one_hit(ch,victim,gsn_tertiary_wield);
         if (is_dancing)
         one_hit(ch,victim, dt);
         check_improve(ch,gsn_tertiary_wield,TRUE,3);
         if (ch->fighting != victim)
         return;
      }
      else
      check_improve(ch,gsn_tertiary_wield,FALSE,3);
   }

   chance = get_skill(ch,gsn_fifth_attack)/5;
   if (chance != 0) chance += tactics;

   if (chance == 1)
   {
      chance = 2;
   }

   if (IS_AFFECTED(ch,AFF_SLOW))
   chance /= 2;

   if (IS_NPC(ch))
   chance = 0;

   if ( number_percent() < chance )
   {
      one_hit( ch, victim, dt );
      if (is_dancing)
      one_hit(ch,victim, dt);
      check_improve(ch,gsn_fifth_attack,TRUE,6);
      if (ch->fighting != victim )
      return;
   }
   chance = get_skill(ch,gsn_corrupt("sixth attack", &gsn_sixth_attack))/2;
   if (chance != 0) chance += tactics;

   if (chance == 1)
   {
      chance = 2;
   }
   if (IS_AFFECTED(ch,AFF_SLOW))
   chance /= 2;

   if (IS_NPC(ch))
   chance = 0;

   if ( number_percent() < chance )
   {
      one_hit( ch, victim, dt );
      if (is_dancing)
      one_hit(ch,victim, dt);
      check_improve(ch,gsn_corrupt("sixth attack", &gsn_sixth_attack),TRUE,6);
      if (ch->fighting != victim )
      return;
   }

   if (ch->fighting != victim)
   return;

   if (get_skill(ch,gsn_riposte) > 0 &&has_skill(ch,gsn_riposte)
   && (IS_NPC(ch) || (ch->pcdata->house_rank < 4)))
   {
      int dam = 0;
      dam = number_range(ch->level*2/3, ch->level*4/3);
      if ( get_skill(ch,gsn_enhanced_damage) > 0)
      {
         int diceroll;
         diceroll = number_percent();
         if ((diceroll <= get_skill(ch, gsn_enhanced_damage)))
         {
            check_improve(ch,gsn_enhanced_damage,TRUE,6);
            dam += 2 * (dam * (diceroll+ch->level)/300);
         }
      }
      if ( get_skill(ch, gsn_enhanced_damage_two) > 0)
      {
         int diceroll2;
         diceroll2 = number_percent();
         if ((diceroll2 <= get_skill(ch, gsn_enhanced_damage_two)))
         {
            check_improve(ch,gsn_enhanced_damage_two,TRUE,3);
            diceroll2 = diceroll2/2;
            diceroll2 = UMAX(diceroll2, 20);
            dam += 2* (dam * diceroll2/200);
         }
      }

      if (number_percent() < get_skill(ch,gsn_riposte)/3){
         int evaded = FALSE;
         check_improve(ch,gsn_riposte,TRUE,1);
         if( number_range(0,3) == 3
         && check_dodge(ch, victim, gsn_riposte) )
         evaded = TRUE;
         else if (number_range(0,1) == 1
         && check_parry(ch,victim,gsn_riposte) )
         evaded = TRUE;
         if (!evaded)
         damage( ch, victim, dam, gsn_riposte, DAM_SLASH, TRUE );
      }
   }
   if (ch->fighting != victim)
   return;

   if(get_skill(ch, gsn_kung_fu) > 0 && has_skill(ch, gsn_kung_fu))
   {
      int dam = 0;
      dam = check_kung_fu(ch, victim);
      if (dam != 0){
         if (check_roll(ch,victim,gsn_kung_fu))
         {
            act
            (
               "$N rolls and dodges $n's strike.",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You roll and dodge $n's strike.",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$N rolls and dodges your strike.",
               ch,
               0,
               victim,
               TO_CHAR
            );
         }
         else
         if( number_range(0,2) != 2
         && !check_dodge(ch, victim, gsn_kung_fu) )
         damage( ch, victim, dam, gsn_kung_fu, DAM_BASH, TRUE );
      }
   }
   /*
   *   I left some of the gsn_kung_fu's on purpose
   *   because dodge & roll already know to allow kung fu to
   *   dodge, and the only difference in the two is meant to be
   *   the skill name
   */
   if(get_skill(ch, gsn_corrupt("ninjitsu", &gsn_ninjitsu)) > 0 && has_skill(ch,gsn_corrupt("ninjitsu", &gsn_ninjitsu)))
   {
      int dam = 0;
      dam = check_kung_fu(ch,victim);
      if (dam != 0){
         if (check_roll(ch,victim,gsn_kung_fu))
         {
            act
            (
               "$N rolls and dodges $n's strike.",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You roll and dodge $n's strike.",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$N rolls and dodges your strike.",
               ch,
               0,
               victim,
               TO_CHAR
            );
         }
         else
         if( number_range(0,2) != 2
         && !check_dodge(ch, victim, gsn_kung_fu) )
         damage
         (
            ch,
            victim,
            dam,
            gsn_corrupt("ninjitsu", &gsn_ninjitsu),
            DAM_BASH,
            TRUE
         );
      }
   }

   return;
}

/* procedure for all mobile attacks */
void mob_hit (CHAR_DATA *ch, CHAR_DATA *victim, int dt)
{
   int chance,number;
   int dual_chance;
   CHAR_DATA *vch, *vch_next;

   one_hit(ch,victim,dt);

   if (ch->fighting != victim)
   {
      return;
   }
   if
   (
      ch->daze > 0 ||
      ch->wait > 0
   )
   {
      return;
   }

   /* Area attack -- BALLS nasty! */

   if (IS_SET(ch->off_flags,OFF_AREA_ATTACK) || (ch->house != 0))
   {
      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         vch_next = vch->next;
         if ((vch != victim && vch->fighting == ch))
         one_hit(ch,vch,dt);
      }
   }
   if (dt == gsn_ambush || dt == gsn_backstab) return;
   if (IS_AFFECTED(ch,AFF_HASTE)
   ||  (IS_SET(ch->off_flags,OFF_FAST) && !IS_AFFECTED(ch,AFF_SLOW)))
   one_hit(ch,victim,dt);

   if (ch->fighting != victim || dt == gsn_backstab)
   return;

   chance = get_skill(ch,gsn_second_attack)/2;
   dual_chance = ch->level*2/3;

   if (IS_AFFECTED(ch,AFF_SLOW) && !IS_SET(ch->off_flags,OFF_FAST))
   {
      dual_chance /= 2;
      chance /= 2;
   }

   if (number_percent() < chance)
   {
      one_hit(ch,victim,dt);
      if (ch->fighting != victim)
      return;
   }

   if (IS_AFFECTED(ch,AFF_HASTE))
   dual_chance *= 5/4;

   if (number_percent() < dual_chance && get_eq_char(ch,WEAR_DUAL_WIELD) != NULL)
   {
      one_hit(ch,victim,gsn_dual_wield);
      if (ch->fighting != victim)
      return;
   }

   chance = get_skill(ch,gsn_third_attack)/4;
   dual_chance *= 2/3;

   if (IS_AFFECTED(ch,AFF_SLOW) && !IS_SET(ch->off_flags,OFF_FAST))
   {
      dual_chance = 0;
      chance = 0;
   }

   if (IS_AFFECTED(ch,AFF_HASTE))
   dual_chance *= 3/2;

   if (number_percent() < chance)
   {
      one_hit(ch,victim,dt);
      if (ch->fighting != victim)
      return;
   }

   if (number_percent() < dual_chance && get_eq_char(ch,WEAR_DUAL_WIELD) != NULL)
   {
      one_hit(ch,victim,gsn_dual_wield);
      if (ch->fighting != victim)
      return;
   }

   /* oh boy!  Fun stuff! */

   number = number_range(0,2);

   if (number == 1 && IS_SET(ch->act,ACT_MAGE))
   {
      /*  { mob_cast_mage(ch,victim); return; } */ ;
   }

   if (number == 2 && IS_SET(ch->act,ACT_CLERIC))
   {
      /* { mob_cast_cleric(ch,victim); return; } */ ;
   }

   /* now for the skills */

   number = number_range(0,12);
   if (IS_NPC(ch) && IS_AFFECTED(ch, AFF_CHARM) && (ch->pIndexData->vnum < 2900 ||
   ch->pIndexData->vnum > 2999))
   number = -1;
   switch(number)
   {
      case (-1): break;
      case (12):
      if (IS_SET(ch->off_flags, OFF_KILLER))
      do_killer_instinct(ch, "");
      break;
      case (10):
      if (IS_SET(ch->off_flags, OFF_PUGIL))
      do_pugil(ch, "");
      break;
      case (11):
      if (IS_SET(ch->off_flags, OFF_LUNGE))
      do_lunge(ch, "");
      break;
      case (0) :
      if (IS_SET(ch->off_flags,OFF_BASH))
      do_bash(ch,"");
      else if (IS_SET(ch->off_flags,OFF_TAIL))
      do_tail(ch,"");
      break;

      case (1) :
      if (IS_SET(ch->off_flags,OFF_BERSERK) && !IS_AFFECTED(ch,AFF_BERSERK))
      do_berserk(ch,"");
      break;


      case (2) :
      if (IS_SET(ch->off_flags,OFF_DISARM)
      || (get_weapon_sn(ch) != gsn_hand_to_hand
      && (IS_SET(ch->act,ACT_WARRIOR)
      ||  IS_SET(ch->act,ACT_THIEF))))
      do_disarm(ch,"");
      break;

      case (3) :
      if (IS_SET(ch->off_flags,OFF_KICK))
      do_kick(ch,"");
      break;

      case (4) :
      if (IS_SET(ch->off_flags,OFF_KICK_DIRT) && number_percent() < ch->level)
      do_dirt(ch,"");
      break;

      case (5) :
      if (IS_SET(ch->off_flags,OFF_TAIL))
      {
         do_tail(ch,"");
      }
      break;

      case (6) :
      if (IS_SET(ch->off_flags,OFF_TRIP))
      do_trip(ch,"");
      break;

      case (7) :
      if (IS_SET(ch->off_flags,OFF_CRUSH))
      {
         do_crush(ch,"") ;
      }
      break;
      case (8) :
      if (IS_SET(ch->off_flags,OFF_BACKSTAB))
      {
         do_backstab(ch,"");
      }
      else if (IS_SET(ch->off_flags,OFF_UNDEAD_DRAIN))
      do_undead_drain(ch,"");
      break;
      case (9) :
      if ( IS_SET(ch->off_flags,OFF_UNDEAD_DRAIN))
      {
         do_undead_drain(ch,"");
      }
      break;
   }

   /* Guardian Angel code */
   if ( IS_GUARDIAN_ANGEL(ch) )
   {
      if ( ch->master && (ch->master->in_room != ch->in_room) )
      {
         act( "$n spreads $s wings and flies away.", ch, NULL, NULL, TO_ROOM );
         stop_fighting( ch, TRUE );
         char_from_room( ch );
         char_to_room( ch, ch->master->in_room );
         act( "$n flies into the area and lands on $s feet, wings spread majestically.", ch, NULL, NULL, TO_ROOM );
      }
      else if (ch->in_room != NULL)
      {
         switch ( number_range(1, 8) )
         {
            case 1:
            if (EVIL_TO(ch, victim))
            do_cast( ch, "'dispel evil'" );
            break;
            case 2:
            do_cast( ch, "flamestrike" );
            break;
            case 3:
            if ( ch->master && (ch->master->in_room == ch->in_room) )
            {
               if ( ch->master->hit < ch->master->max_hit )
               {
                  char masterBuf[MAX_STRING_LENGTH];
                  sprintf( masterBuf, "'cure serious' %s", ch->master->name );
                  do_cast( ch, masterBuf );
               }
            }
            break;
            case 4:
            if ( ch->master && (ch->master->in_room == ch->in_room) )
            {
               if ( ch->master->hit < (ch->master->max_hit / 2) )
               {
                  CHAR_DATA * rescueCheck;
                  int rescueMaster = 0;

                  for ( rescueCheck = ch->in_room->people; rescueCheck != NULL; rescueCheck = rescueCheck->next_in_room )
                  {
                     if ( rescueCheck->fighting == ch->master )
                     rescueMaster = 1;
                  }

                  if ( rescueMaster )
                  do_rescue( ch, ch->master->name );
               }
            }
            break;
         }
      }
   }
}


/*
* Hit one guy once.
*/
void one_hit( CHAR_DATA *ch, CHAR_DATA *victim, int dt )
{
   OBJ_DATA *wield;
   OBJ_DATA *brand = NULL;
   int victim_ac;
   int thac0;
   OBJ_DATA *obj;
   float bcry;
   int thac0_00;
   int thac0_32;
   int dam;
   int diceroll, diceroll2 = 0;
   int sn,skill;
   int dam_type;
   int tmp_dt;
   bool result;

   sn = -1;

   /* just in case */
   if (victim == ch || ch == NULL || victim == NULL)
   return;

   /*
   * Can't beat a dead char!
   * Guard against weird room-leavings.
   */
   if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
   return;

   /*
   * Figure out the type of damage message.
   */
   wield = get_eq_char( ch, WEAR_WIELD );


   if ( dt == TYPE_UNDEFINED )
   {
      dt = TYPE_HIT;
      if ( wield != NULL && wield->item_type == ITEM_WEAPON )
      dt += wield->value[3];
      else
      dt += ch->dam_type;
   }

   if (dt < TYPE_HIT)
   {
      if (wield != NULL)
      dam_type = attack_table[wield->value[3]].damage;
      else
      dam_type = attack_table[ch->dam_type].damage;
   }
   else
   dam_type = attack_table[dt - TYPE_HIT].damage;

   if (dam_type == -1)
   dam_type = DAM_BASH;

   /* get the weapon skill */
   sn = get_weapon_sn(ch);
   skill = 20 + get_weapon_skill(ch,sn);

   /* DUAL WIELD..kinda messy here */
   if (dt == gsn_dual_wield || dt == gsn_whirlwind)
   {
      if (dt == gsn_dual_wield)
      wield = get_eq_char( ch, WEAR_DUAL_WIELD );
      else {
         int chance = number_percent();

         if( get_eq_char(ch, WEAR_DUAL_WIELD) != NULL && chance < 50 )
         wield = get_eq_char(ch,WEAR_DUAL_WIELD);
         else
         wield = get_eq_char(ch,WEAR_WIELD);
      };

      tmp_dt = TYPE_HIT;
      if ( wield != NULL && wield->item_type == ITEM_WEAPON )
      tmp_dt += wield->value[3];
      else
      tmp_dt += ch->dam_type;

      if (tmp_dt < TYPE_HIT)
      {
         if (wield != NULL)
         dam_type = attack_table[wield->value[3]].damage;
         else
         dam_type = attack_table[ch->dam_type].damage;
      }
      else
      dam_type = attack_table[tmp_dt - TYPE_HIT].damage;

      if (dam_type == -1)
      {
         dam_type = DAM_BASH;
      }

      if (wield == NULL)        sn = -1;
      else switch (wield->value[0])
      {
         default:    sn = -1;    break;
         case (WEAPON_SWORD):    sn = gsn_sword;        break;
         case (WEAPON_DAGGER):    sn = gsn_dagger;    break;
         case (WEAPON_SPEAR):    sn = gsn_spear;        break;
         case (WEAPON_MACE):    sn = gsn_mace;        break;
         case (WEAPON_AXE):    sn = gsn_axe;        break;
         case (WEAPON_FLAIL):    sn = gsn_flail;        break;
         case (WEAPON_WHIP):    sn = gsn_whip;        break;
         case (WEAPON_POLEARM):    sn = gsn_polearm;    break;
         case (WEAPON_STAFF):    sn = gsn_staff;        break;
         case (WEAPON_BOW):    sn = gsn_archery;    break;
      }

      skill = 10 + get_weapon_skill(ch,sn);

   }
   else
   {
      if (dam_type == -1)
      {
         dam_type = DAM_BASH;
      }

      if
      (
         wield == NULL &&
         IS_SET(ch->act2, PLR_LICH)
      )
      {
         dam_type = DAM_COLD;
      }
   }

   /*
   * Calculate to-hit-armor-class-0 versus armor.
   */
   if ( IS_NPC(ch) )
   {
      thac0_00 = 20;
      thac0_32 = -4;   /* as good as a thief */
      if (IS_SET(ch->act,ACT_WARRIOR))
      thac0_32 = -10;
      else if (IS_SET(ch->act,ACT_THIEF))
      thac0_32 = -4;
      else if (IS_SET(ch->act,ACT_CLERIC))
      thac0_32 = 2;
      else if (IS_SET(ch->act,ACT_MAGE))
      thac0_32 = 6;
   }
   else
   {
      thac0_00 = class_table[ch->class].thac0_00;
      thac0_32 = class_table[ch->class].thac0_32;
   }
   thac0  = interpolate( ch->level + ch->drain_level, thac0_00, thac0_32 );

   if (thac0 < 0)
   thac0 = thac0/2;

   if (thac0 < -5)
   thac0 = -5 + (thac0 + 5) / 2;

   thac0 -= GET_HITROLL(ch) * skill/100;
   thac0 += 5 * (100 - skill) / 100;

   if (dt == gsn_backstab)
   thac0 -= 10 * (100 - ((get_skill(ch,gsn_backstab) == -1) ? 0 : get_skill(ch,gsn_backstab)));

   if (dt == gsn_ambush)
   thac0 -= 15 * (100 - ((get_skill(ch,gsn_ambush) == -1) ? 0 : get_skill(ch,gsn_ambush)));

   switch(dam_type)
   {
      case(DAM_PIERCE):victim_ac = GET_AC(victim,AC_PIERCE)/10;       break;
      case(DAM_BASH):  victim_ac = GET_AC(victim,AC_BASH)/10;         break;
      case(DAM_SLASH): victim_ac = GET_AC(victim,AC_SLASH)/10;        break;
      default:         victim_ac = GET_AC(victim,AC_EXOTIC)/10;       break;
   };

   if (victim_ac < -15)
   victim_ac = (victim_ac + 15) / 5 - 15;

   if ( !can_see( ch, victim ) )
   victim_ac -= 4;

   if ( victim->position < POS_FIGHTING)
   victim_ac += 4;

   if (victim->position < POS_RESTING)
   victim_ac += 6;

   /*
   * The moment of excitement!
   */

   while ( ( diceroll = number_bits( 5 ) ) >= 20 )
   ;

   if ( diceroll == 0
   || ( diceroll != 19 && diceroll < thac0 - victim_ac ) )
   {
      /* Miss. */
      damage( ch, victim, 0, dt, dam_type, TRUE );
      tail_chain( );
      return;
   }

   if (is_affected(ch,gsn_strabismus) && !IS_AFFECTED(ch,AFF_BLIND) &&
   !is_affected(ch,gsn_blind_fighting) && number_range(1,10) < 5)
   {
      send_to_char("The image fades just as your swing should have connected!\n\r",ch);
      act("$n swings at thin air!",ch,0,0,TO_ROOM);
      damage( ch, victim, 0, dt, dam_type, TRUE );
      tail_chain( );
      return;
   }
   /*
   * Hit.
   * Calc damage.
   */
   if ( IS_NPC(ch) && (!ch->pIndexData->new_format || wield == NULL))
   {
      if (!ch->pIndexData->new_format)
      {
         dam = number_range( ( ch->level + ch->drain_level) / 2, (ch->drain_level + ch->level) * 3 / 2 );
         if ( wield != NULL )
         dam += dam / 2;
      }
      else
      dam = dice(ch->damage[DICE_NUMBER],ch->damage[DICE_TYPE]);
   }
   else
   {
      if (sn != -1)
      check_improve(ch,sn,TRUE,5);
      if ( wield != NULL )
      {
         if (wield->pIndexData->new_format)
         dam = dice(wield->value[1],wield->value[2]) * skill/100;
         else
         dam = number_range( wield->value[1] * skill/100,
         wield->value[2] * skill/100);

         if (get_eq_char(ch,WEAR_SHIELD) == NULL)  /* no shield = more */
         dam = dam * 11/10;

         if (wield->level - (ch->drain_level + ch->level) >= 35)
         dam = (dam*6)/10;
         else if (wield->level - (ch->drain_level + ch->level) >= 25)
         dam = (dam*7)/10;
         else if (wield->level - (ch->drain_level + ch->level) >= 15)
         dam = (dam*8)/10;
         else if (wield->level - (ch->drain_level + ch->level) >= 5)
         dam = (dam*9)/10;

         /* crushing blow */
         if (wield != NULL &&
         (wield->value[0] == WEAPON_STAFF || wield->value[0] == WEAPON_MACE ||
         wield->value[0] == WEAPON_AXE))
         {
            if
            (
               has_skill(ch, gsn_crushingblow) &&
               get_skill(ch, gsn_crushingblow) > 0
            )
            {
               if (number_percent() <= UMAX(get_skill(ch,gsn_crushingblow)/8, 1))
               {
                  dam = 2 * dam + (dam * 2 * number_percent() / 100);
                  send_to_char("You land a crushing blow!\n\r",ch);
                  act("$n lands a crushing blow!",ch,NULL,NULL,TO_ROOM);
                  check_improve(ch,gsn_crushingblow,TRUE,1);
               }
            }
         }

         if (dt == gsn_jump && ch->is_riding != NULL)
         {
            CHAR_DATA *tmp;
            tmp = (CHAR_DATA *) ch->is_riding->mount;
            if (tmp->pIndexData->vnum == MOB_VNUM_COVENANT_DRAGON)
            dam = dam * 3;
            else
            dam = dam * 2;
            act("You are crushed under the weight of $n.", tmp, 0,victim, TO_VICT);
         }
         /* sharpness! */
         if (IS_WEAPON_STAT(wield,WEAPON_SHARP))
         {
            int percent;

            if ((percent = number_percent()) <= (skill / 8))
            {
               dam = 2 * dam + (dam * 2 * percent / 100);
               if (wield->pIndexData->vnum == OBJ_VNUM_SOUL_SAINT)
               dt = 50;
            }
         }
      }
      else
      {
         int n_sides, n_dice;
         n_dice = 4;
         if (ch->class == CLASS_MONK) n_dice += 2;
         n_sides = 3;
         if (ch->level > 50)
         n_sides += 1;
         if (ch->level > 40)
         n_sides += 2;
         if (ch->level > 30)
         n_sides += 2;
         if (ch->level > 20)
         n_sides += 1;
         dam = dice(n_dice, n_sides) * skill / 100;
         /* open claw fighting and fists of x skills (except fury) -Wervdon */
         if (is_affected(ch,gsn_fists_fire))
         {
            if (number_percent() < (get_skill(ch,gsn_fists_fire)/3)){
               send_to_char("A fiery haze surrounds your fists!\n\r",ch);
               act("$n's fists are surrounded by a fiery haze!",ch,0,victim,TO_ROOM);
               if( dt != gsn_whirlwind )
               dt = gsn_fists_fire;
               dam_type = DAM_FIRE;
               dam = dam + (dam*2/10);
            }
         }
         if (is_affected(ch,gsn_fists_ice))
         {
            if (number_percent() < (get_skill(ch,gsn_fists_ice)/3)){
               send_to_char("A frosty haze surrounds your fists!\n\r",ch);
               act("$n's fists are surrounded by a frosty haze!",ch,0,victim,TO_ROOM);
               if( dt != gsn_whirlwind )
               dt = gsn_fists_ice;
               dam_type = DAM_COLD;
               dam = dam + (dam*2/10);
            }
         }
         if (is_affected(ch,gsn_fists_divine))
         {
            if (number_percent() < (get_skill(ch,gsn_fists_divine)/3)){
               send_to_char("A holy aura surrounds your fists!\n\r",ch);
               act("$n's fists are surrounded by a holy aura!",ch,0,victim,TO_ROOM);
               if( dt != gsn_whirlwind )
               dt = gsn_fists_divine;
               dam_type = DAM_HOLY;
               dam = dam + (dam*2/10);
            }
         }
         if (is_affected(ch, gsn_open_claw))
         {
            int percent = number_percent();
            if (percent <= (get_skill(ch, gsn_open_claw) / 8))
            {
               if (dt != gsn_whirlwind)
               {
                  dt = gsn_open_claw;
               }
               dam_type = DAM_SLASH;
               dam = 2 * dam + (dam * 2 * percent / 100);
               send_to_char("You open your claws for a deadly slash!\n\r", ch);
               act
               (
                  "$n's claws open and $e delivers a deadly slash!",
                  ch,
                  NULL,
                  victim,
                  TO_ROOM
               );
            }
         }
         if (is_affected(ch,gsn_fists_poison))
         {
            if (number_percent() < (get_skill(ch,gsn_fists_poison)/3)){
               send_to_char("You strike with the powerful fang fist technique!\n\r",ch);
               act("$n strikes with the fang technique!",ch,0,victim,TO_ROOM);
               if( dt != gsn_whirlwind )
               dt = gsn_fists_poison;
               dam_type = DAM_PIERCE;
               if (!saves_spell(ch,ch->level/ 2,victim,DAM_POISON,SAVE_BREATH))
               {
                  AFFECT_DATA af;
                  AFFECT_DATA *af2;
                  send_to_char("You feel poison coursing through your veins.\n\r",
                  victim);
                  act("$N is poisoned by your fang strike!",ch,0,victim,TO_CHAR);
                  af.where     = TO_AFFECTS;
                  af.type      = gsn_poison;
                  af.level     = ch->level * 3/4;
                  af.duration  = ch->level / 2;
                  af.location  = APPLY_STR;
                  af.modifier  = -1;
                  af.bitvector = AFF_POISON;
                  affect_join( victim, &af, 10 );
                  af2 =affect_find(victim->affected,gsn_poison);
                  if (af2 != NULL)
                  {
                     free_string(af2->caster);
                     af2->caster    = str_dup(ch->name);
                  }
               }
            }
         }
         if (is_affected(ch,gsn_darkforge_fists))
         {
            if (number_percent() < (get_skill(ch,gsn_darkforge)/3)){
               send_to_char("The shadows surround your fists!\n\r",ch);
               act("Shadows surround $n fists!",ch,0,victim,TO_ROOM);
               dt = gsn_darkforge_fists;
               dam_type = DAM_NEGATIVE;
               if (ch->fighting == victim && number_percent() < 13)
               {
                  int v_dam = number_range(ch->level/2, ch->level);
                  act("$N draws life from $n.",victim,0,ch,TO_ROOM);
                  act("You feel $N drawing your life away.",
                  victim,0,ch,TO_CHAR);
                  damage(ch,victim,v_dam,0,DAM_NEGATIVE,FALSE);
                  ch->hit = UMIN(ch->hit + v_dam, ch->max_hit);
               }
            }
         }
      }
   }

   /*
   * Bonuses.
   */

   /* New Enhanced Damage & Enhanced Damage II code - Wervdon */

   if ( get_skill(ch,gsn_enhanced_damage) > 0)
   {
      diceroll = number_percent();
      if ((diceroll <= get_skill(ch, gsn_enhanced_damage)) &&
      (dt != gsn_backstab))
      {
         check_improve(ch,gsn_enhanced_damage,TRUE,6);
         dam += 2 * (dam * (diceroll+ch->level)/300);
      }
   }

   if ( get_skill(ch, gsn_enhanced_damage_two) > 0)
   {
      diceroll2 = number_percent();
      if ((diceroll2 <= get_skill(ch, gsn_enhanced_damage_two)) &&
      (dt != gsn_backstab))
      {
         check_improve(ch,gsn_enhanced_damage_two,TRUE,3);
         diceroll2 = diceroll2/2;
         diceroll2 = UMAX(diceroll2, 20);
         dam += 2* (dam * diceroll2/200);
      }
   }
   if (check_two_hand_wield(ch))
   {
      if (number_percent() <= get_skill(ch,gsn_two_hand_wield))
      {
         check_improve(ch,gsn_two_hand_wield,TRUE,3);
         if (ch->level < 30)
         dam += dam/2;
         else if (ch->level < 40)
         dam += dam/2 + dam/4;
         else
         dam = dam*2;
      }
   }
   /* roughly 15% enhanced damage for cloak of bravery */
   brand = get_eq_char(ch,WEAR_BRAND);
   if (brand != NULL && brand->pIndexData->vnum == 433) brand = NULL;
   if (is_affected(ch,gsn_cloak_brave))
   {
      if (brand == NULL)
      dam += dam/6;
      else
      dam += dam/3;
   }

   /* End of new enhanced damage code - Wervdon */

   /* snake damage reduction in favor of extra attacks */
   if ( !IS_NPC(ch) && ch->pcdata->special == SUBCLASS_SCHOOL_SNAKE)
   dam = dam - dam/5;


   dam += (ch->drain_level + ch->level)/8;

   if ( !IS_AWAKE(victim) )
   dam *= 2;
   else if (victim->position < POS_FIGHTING)
   dam = dam * 3 / 2;

   /* modified calc for backstab. enhanced dam doesn't apply for bs */
   /* runge */

   if ( dt == gsn_backstab && wield != NULL)
   {
      if ( wield->value[0] != 2 )
      dam *= 2 + ((ch->level + ch->drain_level) / 10) ;
      else
      dam *= 2 + ((ch->drain_level + ch->level) / 8);
   }


   if ( dt == gsn_ambush )
   dam *= 5/2 + ((ch->drain_level + ch->level) / 9 );


   dam += GET_DAMROLL(ch) * UMIN(100,skill) /100;

   if (!IS_NPC(ch))
   if (!str_cmp(class_table[ch->class].name,"monk"))
   {
      if (wield == NULL
      && get_eq_char(ch,WEAR_DUAL_WIELD) == NULL)
      dam += (2*(ch->drain_level + ch->level)/5);
   }

   if (IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_HYDRA)
   {
      if (wield != NULL && wield->pIndexData->vnum == OBJ_VNUM_HYDRA_SLAYER)
      dam = dice(17,50);
   }

   bcry = battlecry_multiplier(ch,victim,dt);
   if (wield != NULL && wield->pIndexData->vnum == 23265)
   if (check_cutter(ch,victim) > 1)
   dam += dice(10,3);

   if (bcry < 1.1 && wield == NULL)
   {
      if (check_palm(ch))
      {
         act("$n strikes a powerful open handed blow!",ch,0,0,TO_ROOM);
         act("You strike a powerful open handed blow!",ch,0,0,TO_CHAR);
         if ((ch->drain_level + ch->level) <= 39)
         {
            dam += dam/5;
         }
         else
         dam += dam/3;
      }
   }
   if (bcry < 1.1 && ch->house != HOUSE_CRUSADER)
   {
      if ((obj = get_eq_char(ch,WEAR_HANDS)) != NULL
      && obj->pIndexData->vnum == OBJ_VNUM_GAUNTLETS_STRIKING
      && number_percent() < 10)
      {
         OBJ_DATA *KingArmor;
         act("$n strikes a powerful blow!",ch,0,0,TO_ROOM);
         act("You strike a powerful blow to your opponent!",ch,0,0,TO_CHAR);
         KingArmor = get_eq_char(victim,WEAR_BODY);

         if ((KingArmor != NULL) && (KingArmor->pIndexData->vnum == 28315)
         && (number_range(1,100) <= 20 ))
         {
            send_to_char("Your armor fully absorbs the deathblow!\n\r",victim);
            act("The deathblow does not phase $n!",victim,NULL,NULL,TO_ROOM);
         }
         else
         {
            bcry = 2.0;
         } /* KingArmor defense */
      }
   }

   dam *= bcry;

   if (wield != NULL && wield->pIndexData->vnum == OBJ_VNUM_AVENGER)
   {
      if (IS_WEAPON_STAT(wield,WEAPON_SHADOWBANE)
      && number_percent() < 7)
      {
         act("$p flares and sears $N!",ch,wield,victim,TO_CHAR);
         act("$p flares and sears you!",ch,wield,victim,TO_VICT);
         act("$p flares and sears $N!",ch,wield,victim,TO_NOTVICT);
         dam *= 2;
      }
      if (IS_WEAPON_STAT(wield,WEAPON_LIGHTBRINGER)
      && number_percent() < 10)
      {
         act("$p flares and sears $N!",ch,wield,victim,TO_CHAR);
         act("$p flares and sears you!",ch,wield,victim,TO_VICT);
         act("$p flares and sears $N!",ch,wield,victim,TO_NOTVICT);
         dam *= 3;
         dam /=2;
      }

   }


   if (bcry == 1)
   {
      if (wield != NULL && wield->pIndexData->vnum == 24309)
      {
         if (number_percent() < 6)
         {
            act("$n's $p lands a crushing blow!",ch,wield,0,TO_ROOM);
            act("Your $p lands a crushing blow!",ch,wield,0,TO_CHAR);
            dam *= 2;
         }
      }

      if (ch->fighting == victim && wield != NULL &&
      (wield->pIndexData->vnum == 23764
      || wield->pIndexData->vnum == 23704
      || wield->pIndexData->vnum == 23749) )
      dam *= check_draconian_eq(ch,victim,wield);

      if ((IS_NPC(victim) && victim->house != 0)
      || (!IS_NPC(victim)))
      {

         /* sword of planes  and mace disruption .. go right before damage report*/
         if (wield != NULL && wield->pIndexData->vnum == OBJ_VNUM_SWORD_PLANES)
         {
            if (IS_NPC(victim)
            && ( IS_SET(victim->act,ACT_UNDEAD)
            || victim->pIndexData->vnum == MOB_VNUM_FIRE_ELEMENTAL
            || victim->pIndexData->vnum == MOB_VNUM_AIR_ELEMENTAL
            || victim->pIndexData->vnum == MOB_VNUM_WATER_ELEMENTAL
            || victim->pIndexData->vnum == MOB_VNUM_EARTH_ELEMENTAL
            || victim->pIndexData->vnum == MOB_VNUM_DRAGON
            || victim->pIndexData->vnum == MOB_VNUM_UNICORN
            || is_name(victim->name,"demon")
            || is_name(victim->name,"familiar")
            || is_name(victim->name,"golem")) )
            {
               if (!(saves_spell(ch, ch->level,victim,DAM_ENERGY, SAVE_OTHER))
               && (!saves_spell(ch, ch->level + 3,victim,DAM_ENERGY, SAVE_OTHER))
               && (!saves_spell(ch, wield->level,victim,DAM_OTHER, SAVE_OTHER))
               && can_instakill(ch, victim)
               && number_percent() < 50)
               {
                  act("$n's body suddenly crumples as $p draws $s lifeforce back to the outer planes!",
                  victim,wield,0,TO_ROOM);
                  raw_kill(ch,victim);
                  return;
               }
               else if (IS_SET(victim->affected_by, AFF_SANCTUARY) )
               {
                  dam += (dam/2);  /* partiallyNegates sanc */
               }
            }
         }
         else if (wield != NULL && wield->pIndexData->vnum == OBJ_VNUM_MACE_DISRUPTION)
         {
            if (IS_NPC(victim)
            && ( IS_SET(victim->act,ACT_UNDEAD)) )
            {
               if (!saves_spell(ch, ch->level,victim,DAM_ENERGY, SAVE_OTHER)
               && !saves_spell(ch, ch->level,victim,DAM_ENERGY, SAVE_OTHER)
               && !saves_spell(ch, ch->level,victim,DAM_OTHER, SAVE_OTHER)
               && can_instakill(ch, victim))
               {
                  act("$N's body explodes under $n's mace of disruption!",ch,0,victim,TO_NOTVICT);
                  act("$N's body explodes under your mace of disruption!",ch,0,victim,TO_CHAR);
                  raw_kill(ch,victim);
                  return;
               }
               else if (IS_SET(victim->affected_by,AFF_SANCTUARY))
               {
                  dam += (3* dam/4);
               }
            }
         }
      } /* end of check for legal mobs and players */

      if (IS_NPC(ch)
      && ch->pIndexData->vnum == 19000
      && number_percent() < 4)
      {
         act("$n bellows a cry and unleashes a mighty blow upon you!",ch,0,victim,TO_VICT);
         act("$n bellows a cry and unleashes a mighty blow upon $N",ch,0,victim,TO_NOTVICT);
         dam += dice(ch->level,3);
      }
   }

   if ( dam <= 0 )
   dam = 1;

   if (check_taichi(ch, victim, dt))
   {
      result = damage( victim, ch, dam / 2, gsn_taichi, dam_type, TRUE );
   }
   else if (check_judo(ch, victim, dt))
   {
      result = damage( victim, ch, dam / 2, gsn_judo, dam_type, TRUE );
   }
   else
   {
      result = damage(ch, victim, dam, dt, dam_type, TRUE);
   }
   check_outlaw_badge(ch);
   check_red_shield(ch);
   check_high_herb(ch);

   if (wield != NULL && wield->pIndexData->vnum == OBJ_VNUM_RANGER_STAFF)
   check_ranger_staff(ch,wield);

   if (wield != NULL && wield->pIndexData->vnum == 8003)
   check_ranger_staff(ch,wield);    /* Staff of magi call */

   /* but do we have a funky weapon? */
   if (result && wield != NULL)
   {

      if (ch->fighting == victim && wield->pIndexData->vnum == 27035)
      obj_fight_27035(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27036)
      obj_fight_27036(ch,victim,wield);
      else  if (ch->fighting == victim && wield->pIndexData->vnum == 27038)
      obj_fight_27038(ch,victim,wield);
      else if (ch->fighting == victim && wield->pIndexData->vnum == 27042)
      obj_fight_27042(ch,victim,wield);
   }
   if (result){
      if (ch->fighting == victim && (wield != NULL && IS_WEAPON_STAT(wield,WEAPON_POISON)))
      {
         int level;
         AFFECT_DATA *poison, af;
         AFFECT_DATA *af2;

         poison = NULL;
         if (wield != NULL){
            if ((poison = affect_find(wield->affected,gsn_poison)) == NULL)
            level = wield->level;
            else
            level = poison->level;
         }
         else
         {
            level = ch->level;
         }

         if (!saves_spell(ch, level / 2,victim,DAM_POISON, SAVE_BREATH))
         {
            send_to_char("You feel poison coursing through your veins.\n\r",
            victim);
            act("$n is poisoned by the venom on $p.",victim, wield, NULL,TO_ROOM);


            af.where     = TO_AFFECTS;
            af.type      = gsn_poison;
            af.level     = level * 3/4;
            af.duration  = level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -1;
            af.bitvector = AFF_POISON;
            affect_join( victim, &af, 10 );
            af2 =affect_find(victim->affected,gsn_poison);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               if
               (
                  IS_NPC(ch) &&
                  IS_AFFECTED(ch, AFF_CHARM) &&
                  ch->master &&
                  !IS_NPC(ch->master)
               )
               {
                  af2->caster = str_dup(ch->master->name);
               }
               else
               {
                  af2->caster = str_dup(ch->name);
               }
            }
         }

         /* weaken the poison if it's temporary */
         if (poison != NULL)
         {
            poison->level = UMAX(0,poison->level - 2);
            poison->duration = UMAX(0,poison->duration - 1);

            if (poison->level == 0 || poison->duration == 0)
            act("The poison on $p has worn off.",ch,wield,NULL,TO_CHAR);
         }
      }
   }
   if (result && wield != NULL){
      int dam; /* moved down here to avoid a warning */
      if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_VAMPIRIC)
      && number_percent() < 13)
      {
         dam = number_range(wield->level/2, wield->level);
         act("$p draws life from $n.",victim,wield,NULL,TO_ROOM);
         act("You feel $p drawing your life away.",
         victim,wield,NULL,TO_CHAR);
         damage(ch,victim,dam,0,DAM_NEGATIVE,FALSE);
         ch->hit = UMIN(ch->hit + dam, ch->max_hit);
      }

      if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FLAMING)
      && number_percent() < 15)
      {
         dam = number_range(1,wield->level / 4 + 1);
         act("$n is burned by $p.",victim,wield,NULL,TO_ROOM);
         act("$p sears your flesh.",victim,wield,NULL,TO_CHAR);
         fire_effect( (void *) victim,wield->level/2,dam,TARGET_CHAR);
         damage(ch,victim,dam,0,DAM_FIRE,FALSE);
      }

      if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FROST)
      && number_percent() < 15)
      {
         dam = number_range(1,wield->level / 6 + 2);
         act("$p freezes $n.",victim,wield,NULL,TO_ROOM);
         act("The cold touch of $p surrounds you with ice.",
         victim,wield,NULL,TO_CHAR);
         cold_effect(victim,wield->level/2,dam,TARGET_CHAR);
         damage(ch,victim,dam,0,DAM_COLD,FALSE);
      }

      if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_SHOCKING)
      && number_percent() < 15)
      {
         dam = number_range(1,wield->level/5 + 2);
         act("$n is struck by lightning from $p.",victim,wield,NULL,TO_ROOM);
         act("You are shocked by $p.",victim,wield,NULL,TO_CHAR);
         shock_effect(victim,wield->level/2,dam,TARGET_CHAR);
         damage(ch,victim,dam,0,DAM_LIGHTNING,FALSE);
      }

      if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_DROWNING)
      && number_percent() < 15)
      {
         dam = number_range(1,wield->level/5 + 2);
         act("$n is deluged by water spouting from $p.",victim,wield,NULL,TO_ROOM);
         act("You are smothered by a deluge of water spouting from $p.",victim,wield,NULL,TO_CHAR);
         drowning_effect(victim,wield->level/2,dam,TARGET_CHAR);
         damage(ch,victim,dam,0,DAM_DROWNING,FALSE);
      }
      if
      (
         ch->fighting == victim &&
         IS_WEAPON_STAT(wield, WEAPON_RESONATING) &&
         number_percent() < 15
      )
      {
         dam = number_range(1, wield->level/5 + 2);
         act
         (
            "$n is struck by the sonic resonance from $p.",
            victim,
            wield,
            NULL,
            TO_ROOM
         );
         act
         (
            "You are struck by the sonic resonance from $p.",
            victim,
            wield,
            NULL,
            TO_CHAR
         );
         resonating_effect
         (
            victim,
            wield->level/2,
            dam,
            TARGET_CHAR
         );
         damage
         (
            ch,
            victim,
            dam,
            0,
            DAM_SOUND,
            FALSE
         );
      }
   }
   check_doublestrike(ch,victim,dam_type);
   if
   (
      result &&
      (
         (
            IS_NPC(victim) &&
            victim->pIndexData->vnum == MOB_VNUM_FIRE_ELEMENTAL &&
            victim->master != NULL &&
            has_skill(victim->master, gsn_flame_form)
         ) ||
         (
            !IS_NPC(victim) &&
            has_skill(victim, gsn_flame_form) &&
            get_skill(victim, gsn_flame_form) >= 75
         )
      ) &&
      number_range(1, 10) == 1
   )
   {
      act("Flames from $N scorch you as you strike $M!", ch, 0, victim, TO_CHAR);
      act("Your flames scorch $n as $e strikes!.", ch, 0, victim, TO_VICT);
      act("Flames from $N scorch $n as $e strikes.", ch, 0, victim, TO_NOTVICT);
      damage(victim, ch, dice(ch->level,3),gsn_flame_form, DAM_FIRE, TRUE);
   }
   if
   (
      result &&
      victim->valid &&
      ch->valid &&
      is_affected(victim, gsn_virulent_cysts)
   )
   {
      check_cysts(ch, victim);
   }
   tail_chain( );
   return;
}


void check_red_shield(CHAR_DATA *ch)
{
   OBJ_DATA *shield;
   shield = get_eq_char(ch,WEAR_SHIELD);
   if (shield == NULL)
   return;
   if (shield->pIndexData->vnum != 23728)
   return;
   if (number_percent() < 6)
   {
      act("The cross on $n's shield glows a soft red.",ch,shield,0,TO_ROOM);
      act("The cross on your shield glows a soft red.",ch,shield,0,TO_CHAR);
      obj_cast_spell(gsn_cure_critical, 45, ch, ch, shield);
   }
   return;
}

void check_high_herb(CHAR_DATA *ch)
{
   if(is_affected(ch,gsn_high_herb) && number_percent() < 1)
   {
      act("$n becomes paranoid and runs in fear!",ch,NULL,NULL,TO_ROOM);
      act("You become paranoid and run in fear!", ch,NULL,NULL,TO_CHAR);
      do_flee(ch,"");
   }
   return;
}

void check_outlaw_badge(CHAR_DATA *ch)
{
   OBJ_DATA *badge;

   badge = get_eq_char(ch,WEAR_ABOUT);

   if (badge == NULL) return;

   if (badge->pIndexData->vnum == OBJ_VNUM_OUTLAW_CLOAK
   && number_percent() < 8)
   {
      act("$n's $p glows bright blue!",ch,badge,0,TO_ROOM);
      act("Your $p glows bright blue!",ch,badge,0,TO_CHAR);
      obj_cast_spell(gsn_cure_critical, badge->level, ch, ch, badge);
   }

   return;
}


int check_draconian_eq(CHAR_DATA *ch, CHAR_DATA *victim,OBJ_DATA *wield)
{
   if (number_percent() > 5)
   return 1;
   if (wield->pIndexData->vnum == 23764)
   {
      act("$p clenches with viscious force!",ch,wield,0,TO_ROOM);
      act("Your claw of draconian warfare clenches with viscious force!",ch,wield,0,TO_CHAR);
      return 2;
   }
   if (wield->pIndexData->vnum == 23704)
   {
      act("Your Claw of the Dragon King opens and slashes at $N!",ch,wield,victim,TO_CHAR);
      act("$n's Claw of the Dragon King opens and slashes at you!",ch,wield,victim,TO_VICT);
      act("$n's Claw of the Dragon King opens and slashes at $N!",ch,wield,victim,TO_NOTVICT);
      return 2;
   }
   if (wield->pIndexData->vnum == 23749)
   {
      act("$n's horn of frost suddenly becomes covered in freezing white ice!",ch,wield,0,TO_ROOM);
      act("Your horn of frost suddenly becomes covered in freezing ice!",ch,wield,0,TO_CHAR);
      return 2;
   }

   return 1;
}

void check_robe_light(CHAR_DATA *ch,OBJ_DATA *obj)
{
   if (ch->position != POS_FIGHTING)
   return;

   if( number_percent() < 6 )
   {
      act("$n's robe of the light blazes brightly.",ch,0,0,TO_ROOM);
      send_to_char("Your robe of the light blazes brightly.\n\r",ch);
      obj_cast_spell(gsn_cure_critical, ch->level,ch,ch,obj);;
   }

   if( number_percent() < 6 )
   {
      act("$n's robe of the light flashes brilliantly.",ch,0,0,TO_ROOM);
      send_to_char("Your robe of the light flashes brilliantly.\n\r",ch);
      obj_cast_spell(gsn_dispel_evil, obj->level, ch, ch->fighting, obj );
   }

   return;
}

void check_adorno_brand(CHAR_DATA *ch,OBJ_DATA *obj)
{
   if (ch->position != POS_FIGHTING)
   return;
   if (number_percent() > 7)
   return;
   act("$n's brand of a white ball glows brighter for a moment.",ch,0,0,TO_ROOM);
   send_to_char("Your brand of a white ball glows brighter for a moment.\n\r",ch);
   obj_cast_spell(gsn_cure_critical, ch->level,ch,ch,obj);;
   return;
}

void check_medusa(CHAR_DATA *ch)
{
   if
   (
      check_immune(ch->fighting, DAM_OTHER) == IS_IMMUNE ||
      IS_AFFECTED(ch->fighting, AFF_BLIND) ||
      see_state(ch->fighting, ch) != SEE_TARGET ||
      number_percent() > 9
      /*
         6% will pass this
         Changed to 9% (1.5 times as often)
      */
   )
   {
      return;
   }

   if
   (
      IS_NPC(ch) &&
      ch->pIndexData->vnum == OBJ_VNUM_MOB_MEDUSA
   )
   {
      act
      (
         "$N's face turns to stone as $S vision glances over your face.",
         ch,
         NULL,
         ch->fighting,
         TO_CHAR
      );
      act
      (
         "$N's face forms bloody cracks, as bits of it fall to the ground.",
         ch,
         NULL,
         ch->fighting,
         TO_NOTVICT
      );
      send_to_char
      (
         "Part of your face turns to stone as you gaze upon the horrid face of the"
         " medusa!\n\r",
         ch->fighting
      );
      damage(ch, ch->fighting, 1000, gsn_stone, DAM_OTHER, FALSE);
      return;
   }
   /*
      2/3rd chance to return, 1/3rd to continue 6% * 1/3 = 2%
      6% (above) changed to 9%: 9% * 1/3 = 3%, so 3% will pass
   */
   if (number_range(0, 2))
   {
      return;
   }
   act
   (
      "The snakes upon your head writhe and send a terrible black stream at $N.",
      ch,
      NULL,
      ch->fighting,
      TO_CHAR
   );
   act
   (
      "The snakes atop $n's head writhe very quickly and spit a black venom at $N.",
      ch,
      NULL,
      ch->fighting,
      TO_NOTVICT
   );
   act
   (
      "You are struck by a black essence that freezes your skin on contact!",
      ch,
      NULL,
      ch->fighting,
      TO_VICT
   );
   damage(ch, ch->fighting, 600, gsn_stone, DAM_OTHER, FALSE);
   return;
}

void check_silver_hammer(CHAR_DATA *ch, OBJ_DATA *obj)
{
   if (ch->position != POS_FIGHTING)
   return;
   if (number_percent() > 7)
   return;
   act("$n's silver hammer shines brightly.",ch,0,0,TO_ROOM);
   send_to_char("Your silver hammer shines brightly.\n\r",ch);
   obj_cast_spell(gsn_heal, ch->level,ch,ch,obj);
   return;
}

void check_staff_gardener(CHAR_DATA *ch, OBJ_DATA *obj)
{
   if (ch->position != POS_FIGHTING)
   return;
   if (number_percent() > 7)
   return;
   act("$n's Staff of the Gardener glows bright green.",ch,0,0,TO_ROOM);
   send_to_char("Your Staff of the Gardener glows bright green.\n\r",ch);
   obj_cast_spell(gsn_heal, ch->level,ch,ch,obj);
   return;
}

void check_mace_blessed(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   if (ch->position != POS_FIGHTING)
   return;
   if (number_percent() > 7)
   return;
   act("$n's blessed mace sends a circle of light around $N's head.",ch,0,victim,TO_NOTVICT);
   act("Your blessed mace sends a circle of light around $N's head.",ch,0,victim,TO_CHAR);
   act("$n's blessed mace sends a circle of light around your head.",ch,0,victim,TO_VICT);
   damage(ch,victim,number_range(75,120),gsn_divine_touch,DAM_MENTAL,TRUE);
   return;
}

void check_thm_sword(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   if (ch->position != POS_FIGHTING)
   return;
   if (number_percent() > 7)
   return;
   act("$n's sword glints wickedly.",ch,0,victim,TO_NOTVICT);
   send_to_char("Your sword glints wickedly.\n\r",ch);
   send_to_char("Reality shatters as your mind is blasted!\n\r",ch);
   damage(ch,ch,number_range(75,120),gsn_divine_touch,DAM_MENTAL,FALSE);
   return;
}

void check_genocide_axe(CHAR_DATA *ch, CHAR_DATA *victim,OBJ_DATA *obj)
{
   if
   (
      ch->position != POS_FIGHTING ||
      ch->fighting != victim ||
      !ch->fighting
   )
   return;
   if (number_percent() > 5)
   return;
   act("$n's $p glows wickedly.",ch,obj,victim,TO_VICT);
   act("$n's $p glows wickedly.",ch,obj,victim,TO_NOTVICT);
   act("Your $p glows wickedly.",ch,obj,victim,TO_CHAR);
   magic_spell
   (
      ch,
      "blah",
      CAST_BITS_PLR_SKILL,
      obj->level,
      gsn_demonfire
   );
   return;
}

void check_sword_demons(CHAR_DATA *ch, CHAR_DATA *victim,OBJ_DATA *obj)
{
   if
   (
      ch->position != POS_FIGHTING ||
      !ch->fighting ||
      ch->fighting != victim
   )
   return;
   if (number_percent() > 5)
   return;
   act("$n's $p grins evilly, you hear the laughter of demons.",ch,obj,victim,TO_VICT);
   act("$n's $p grins evilly, you hear the laughter of demons.",ch,obj,victim,TO_NOTVICT);
   act("Your $p grins evilly, you hear the laughter of demons.",ch,obj,victim,TO_CHAR);
   if (number_percent() < 70){
      magic_spell
      (
         ch,
         "blah",
         CAST_BITS_PLR_SKILL,
         40,
         gsn_energy_drain
      );
   }
   else
   {
      magic_spell
      (
         ch,
         "blah",
         CAST_BITS_PLR_SKILL,
         40,
         gsn_fireball
      );
   }
   return;
}

void check_sword_marcil(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   if (IS_NPC(victim)) return;
   if (ch->position != POS_FIGHTING)
   return;
   if (number_percent() > 7)
   return;
   act("$n's Sword of Marcil surrounds $N with a yellow beam.",ch,0,victim,TO_NOTVICT);
   act("Your Sword of Marcil surrounds $N with a yellow beam.",ch,0,victim,TO_CHAR);
   act("$n's Sword of Marcil surrounds you with a yellow beam.",ch,0,victim,TO_VICT);
   magic_spell_vict
   (
      ch,
      victim,
      CAST_BITS_PLR_SKILL,
      1000,
      gsn_teleport
   );
   return;
}

void check_water_symbol(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int dam;
   int level = obj->level;

   if (ch->position != POS_FIGHTING)
   return;
   if (number_percent() > 7)
   return;
   act("$n's Water Symbol spouts water at $N.",ch,0,victim,TO_NOTVICT);
   act("Your Water Symbol spouts water at $N.",ch,0,victim,TO_CHAR);
   act("$n's Water Symbol spouts water at you!",ch,0,victim,TO_VICT);
   dam = number_range(85,130);
   if (saves_spell(ch,level,victim,DAM_DROWNING, SAVE_OTHER))
   {
      drowning_effect(victim,level/2,dam/4,TARGET_CHAR);
      damage(ch,victim,dam/2,gsn_find_water,DAM_DROWNING,TRUE);
   }
   else
   {
      drowning_effect(victim,level,dam,TARGET_CHAR);
      damage(ch,victim,dam,gsn_find_water,DAM_DROWNING,TRUE);
   }
   return;
}

void check_ranger_staff(CHAR_DATA *ch,OBJ_DATA *wield) {
   if (wield->pIndexData->vnum != 8003)
   {
      if (!IS_SET(wield->extra_flags,ITEM_MAGIC)) return;
      if (str_cmp(wield->material,"magic root wood")) return;
   }
   if (number_percent() < 7)
   {
      if (wield->pIndexData->vnum == OBJ_VNUM_RANGER_STAFF)
      {
         act("$p glows blue!",ch,wield,0,TO_ROOM);
         act("Your ranger staff glows blue!",ch,wield,0,TO_CHAR);
      }
      else
      {
         act("$p glows a burning green!",ch,wield,0,TO_ROOM);
         act("Your staff of the magi glows burning green!",ch,wield,0,TO_CHAR);
      }
      magic_spell
      (
         ch,
         "blah",
         CAST_BITS_PLR_SKILL,
         wield->level,
         gsn_cure_critical
      );
   }
   return;
}

int avenger_multiplier(CHAR_DATA *ch,OBJ_DATA *wield)
{
   int avenge;

   avenge = 1;
   if (IS_EVIL(ch->fighting) && wield != NULL)
   {
      if (number_percent() < 7 && IS_WEAPON_STAT(wield,WEAPON_SHADOWBANE))
      avenge = 2;
      if (number_percent() < 7 && IS_WEAPON_STAT(wield,WEAPON_LIGHTBRINGER))
      avenge = 3/2;
   }

   return avenge;
}

float battlecry_multiplier(CHAR_DATA *ch, CHAR_DATA *victim, int dt)
{
   OBJ_DATA *obj;
   CHAR_DATA *vch;
   int chance;
   int mod;
   float battlecry = 1.0;

   int count = 0;
   /*
   if (IS_NPC(ch) && ch->pIndexData->vnum != MOB_VNUM_CRUSADER
   return 1;
   */
   if (!is_affected(ch,gsn_battlecry) && !IS_NPC(ch))
   return 1.0;

   if (IS_NPC(ch) && ch->pIndexData->vnum != MOB_VNUM_CRUSADER
   && !is_affected(ch,gsn_battlecry))
   return 1.0;

   /*    if ((ch->drain_level + ch->level) < skill_table[gsn_battlecry].skill_level[ch->class]
   && !IS_NPC(ch))
   return 1;*/
   if (!IS_NPC(ch) && (ch->drain_level + ch->level) < ch->pcdata->learnlvl[gsn_battlecry])
   return 1;

   if (house_down(ch,HOUSE_CRUSADER))
   return 1;

   if  ((obj = get_eq_char(ch,WEAR_HANDS)) != NULL
   && obj->pIndexData->vnum == OBJ_VNUM_GAUNTLETS_STRIKING)
   mod = 3;
   else mod = 0;

   if( victim != NULL
   && IS_SET(victim->wiznet,PLR_FORSAKEN) )
   mod += number_range(2,5);


   for( vch=ch->in_room->people; vch!=NULL; vch=vch->next_in_room )
   {
      if( vch == ch
      || vch->fighting != ch
      || vch->level < (ch->level / 2) )
      continue;

      if( !IS_NPC(vch) )
      count += 3;
      else
      count ++;
   }
   mod += (count > 1 ? ((count * 2)/3) : 0);

   chance = 10 + mod;
   chance = UMIN(chance,20);

   if  (number_percent( ) > chance)
   return 1;

   chance = get_skill(ch,gsn_battlecry);
   if (IS_NPC(ch) )
   chance = 100;

   if (chance > 2)
   {
      if (number_percent( ) > chance )
      {
         send_to_char("You fail to deliver a blow of deadly force.\n\r",ch);
         if
         (
            !IS_NPC(ch) &&
            ch->pcdata->spam < current_time &&
            !is_affected(ch, gsn_smite) &&
            !is_affected(ch, gsn_punishment) &&
            (
               ch->pcdata->learned[gsn_battlecry] < 100 &&
               number_percent() < 90
            )
         )
         {
            send_to_char("You learn from your mistakes and become better at battlecry.\n\r",ch);
            ch->pcdata->learned[gsn_battlecry]++;
            ch->pcdata->updated[gsn_battlecry] = TRUE;
            save_char_obj( ch );
         }
      }
      else
      {
         OBJ_DATA *KingArmor;

         send_to_char("You deliver a blow of deadly force!\n\r",ch);
         act("$n delivers a blow of deadly force!",ch,NULL,NULL,TO_ROOM);
         check_improve(ch,gsn_battlecry,TRUE,1);

         KingArmor = get_eq_char(victim,WEAR_BODY);

         if ((KingArmor != NULL) && (KingArmor->pIndexData->vnum == 28315) &&
         (number_range(1,100) <= 20 )) {
            send_to_char("Your armor fully absorbs the deathblow!\n\r",victim);
            act("The deathblow does not phase $n!",victim,NULL,NULL,TO_ROOM);
         }
         else
         {
            if ((ch->drain_level + ch->level) <= 29)     battlecry = 1.4;
            else if ((ch->drain_level + ch->level) <= 39)     battlecry = 2.4;
            else if ((ch->drain_level + ch->level) <= 49)    battlecry = 3.4;
            else if ((ch->drain_level + ch->level) <= 59)     battlecry = 4.4;
            else battlecry = 5.0;
         } /* victim wearing 28315 */
      } /* success at battlecry */
   }

   if( count > 9 )
   battlecry += 1.8;
   else if( count > 6 )
   battlecry += 1.2;
   else if( count > 3 )
   battlecry += 0.6;

   if( IS_NPC(victim)
   && IS_AFFECTED(victim,AFF_CHARM) )
   battlecry += 0.6;

   if (dt == gsn_circle)
   battlecry = UMIN(battlecry,3);
   else if (dt == gsn_lunge)
   battlecry = UMIN(battlecry,3);
   else if (dt == gsn_backstab)
   battlecry = UMIN(battlecry,2);
   else if (dt == gsn_dual_backstab)
   battlecry = UMIN(battlecry,2);
   else if (dt == gsn_ambush)
   battlecry = UMIN(battlecry,2);
   else if (dt == gsn_iron_palm)
   battlecry = UMIN(battlecry,2);

   return battlecry;
}

/*
* See if an attack justifies a KILLER flag.
*/
void check_killer( CHAR_DATA *ch, CHAR_DATA *victim )
{
   /*
   * Follow charm thread to responsible character.
   * Attacking someone's charmed char is hostile!
   */
   while
   (
      IS_NPC(victim) &&
      IS_AFFECTED(victim, AFF_CHARM) &&
      victim->master &&
      victim->master != victim &&
      victim->master->master != victim
   )
   victim = victim->master;

   /*
   * NPC's are fair game.
   * So are killers and thieves.
   */
   if ( IS_NPC(victim)
   ||   IS_SET(victim->act, PLR_KILLER)
   ||   IS_SET(victim->act, PLR_THIEF))
   return;

   /*
   * NPC's are cool of course (as long as not charmed).
   * Hitting yourself is cool too (bleeding).
   * So is being immortal (Alander's idea).
   * And current killers stay as they are.
   */
   if ( IS_NPC(ch)
   ||   ch == victim
   ||   ch->level >= LEVEL_IMMORTAL
   ||   !is_house(ch)
   ||   IS_SET(ch->act, PLR_KILLER)
   ||   ch->fighting  == victim)
   return;

   save_char_obj( ch );
   return;
}

/* Check a counter-parry */

void do_counter_parry(CHAR_DATA *ch,CHAR_DATA *victim,int dt, int dam)
{
   int chance;
   int tmp_dt;
   char *attack;
   OBJ_DATA *wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];

   if ((chance = get_skill(victim,gsn_counter_parry)) <= 0
   || IS_NPC(victim)
   || /*victim->level < skill_table[gsn_counter_parry].skill_level[victim->class]*/
   !has_skill(ch,gsn_counter_parry))
   return;

   chance /= 5;
   if (chance > 20)
   chance = 20;

   if (number_percent() < chance)
   {
      tmp_dt = TYPE_HIT;
      if (dt  == gsn_dual_wield)
      wield = get_eq_char(ch,WEAR_DUAL_WIELD);
      else if (dt == gsn_tertiary_wield)
      wield = get_eq_char(ch,WEAR_TERTIARY_WIELD);
      else
      wield = get_eq_char(ch,WEAR_WIELD);


      if (wield != NULL)
      tmp_dt += wield->value[3];
      else
      tmp_dt += ch->dam_type;


      if (tmp_dt > TYPE_HIT && tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE)
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
      else
      attack = attack_table[0].name;

      sprintf(buf1,"You counter parry $n's %s!",attack);
      sprintf(buf2,"$N counter parries your %s!",attack);
      act(buf1,ch,0,victim,TO_VICT);
      act(buf2,ch,0,victim,TO_CHAR);
      if (house_down(victim,HOUSE_CRUSADER))
      return;

      damage(victim,ch,dam,gsn_counter_parry,TYPE_HIT,TRUE);
      check_improve(victim,gsn_counter_parry,TRUE,3);
      return;
   }

   check_improve(victim,gsn_counter_parry,FALSE,2);
   return;
}


bool check_counter(CHAR_DATA* ch, CHAR_DATA* victim, int dam, int dt)
{
   int chance;
   long cid;
   long vid;

   if (dt == gsn_counter)
   {
      return FALSE;
   }
   if (dt == gsn_counter_parry)
   {
      return FALSE;
   }

   if
   (
      (
         dt == gsn_backstab ||
         dt == gsn_ambush ||
         dt == gsn_cleave ||
         dt == gsn_deathstrike ||
         dt == gsn_iron_palm
      ) &&
      (number_range(1,8) !=1)
   )
   {
      return FALSE;
   }

   if (ch->fighting != NULL)
   {
      return FALSE;
   }

   if
   (
      (chance = get_skill(victim, gsn_counter)) <= 0 ||
      /*victim->level < skill_table[gsn_counter].skill_level[ch->class]*/
      !has_skill(victim, gsn_counter)
   )
   {
      return FALSE;
   }

   if(see_state(victim, ch) == NO_SEE_TARGET )
   {
      chance -= 30;
   }
   if
   (
      get_eq_char(victim,WEAR_WIELD) == NULL &&
      ch->class !=(GUILD_MONK-1)
   )
   {
      chance -= 50;
      chance += (victim->level - ch->level);
   }

   if
   (
      victim->position != POS_FIGHTING &&
      IS_AWAKE(victim)
   )
   {
      if (number_percent() < chance)
      {
         act
         (
            "You counter $n's attack!",
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            "$N counters your attack!",
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            "$N counters $n's attack!",
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         check_improve
         (
            victim,
            gsn_counter,
            TRUE,
            1
         );
         cid = ch->id;
         vid = victim->id;
         damage
         (
            victim,
            ch,
            dam,
            gsn_counter,
            TYPE_UNDEFINED,
            TRUE
         );
         if
         (
            ch->valid &&
            victim->valid &&
            ch->on_line &&
            victim->on_line &&
            victim->id == vid &&
            ch->id == cid &&
            !ch->ghost &&
            !victim->ghost &&
            victim->in_room == ch->in_room &&
            ch->fighting == NULL &&
            ch->position > POS_STUNNED
         )
         {
            set_fighting(ch, victim);
         }
         return TRUE;
      }
   }

   check_improve
   (
      victim,
      gsn_counter,
      FALSE,
      2
   );
   return FALSE;
}



/*
* Check for parry.
*/
bool check_parry(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;
   extern bool defense_not_countered;
   OBJ_DATA* dwield;
   int dual_parry = FALSE;

   if (!IS_AWAKE(victim))
   return FALSE;

   if (!has_skill(victim, gsn_parry))
   {
      return FALSE;
   }

   chance = get_skill(victim, gsn_parry) / 2;

   if (get_eq_char(victim, WEAR_WIELD) == NULL)
   {
      if (IS_NPC(victim))
      chance /= 2;
      else
      return FALSE;
   }

   if( see_state(victim,ch) == NO_SEE_TARGET )
   chance /= 2;

   if (is_affected(ch, gsn_killer_instinct))
   {
      /* at 100% skill, it will reduce by 1/3rd */
      chance -= chance * get_skill(ch, gsn_killer_instinct) / 300;
   }

   if
   (
      number_percent( ) >= chance +
      (
         victim->drain_level +
         victim->level
      ) -
      (
         ch->drain_level +
         ch->level)
   )
   {
      check_improve(victim,gsn_parry,FALSE,6);
      if
      (
         get_skill(victim, gsn_dual_parry) > 0 &&
         has_skill(victim, gsn_dual_parry)
      )
      {
         chance = get_skill(victim, gsn_dual_parry);
         dwield = get_eq_char(victim, WEAR_DUAL_WIELD);
         if (dwield == NULL)
         {
            chance = 0;
         }
         if (number_percent() < (chance/5))
         {
            check_improve
            (
               victim,
               gsn_dual_parry,
               TRUE,
               3
            );
            dual_parry = TRUE;
         }
         else
         {
            check_improve
            (
               victim,
               gsn_dual_parry,
               FALSE,
               3
            );
            return FALSE;
         }
      }
      else
      {
         return FALSE;
      }
   }

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }


   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT +
      MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In parry, bad dam message: dt %d.",tmp_dt);
      sprintf
      (
         buf1,
         "Player: %s Target: %s.",
         ch->name,
         victim->name
      );
      bug(buf1, 0);
      attack = attack_table[0].name;
   }

   if (!dual_parry)
   {
      switch(number_range(1,12))
      {
         case (1):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s and deflect it away from yourself.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s and deflects it away from $Mself.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s and deflects it away from $Mself.",
               attack
            );
            break;
         }
         case (2):
         {
            sprintf
            (
               buf1,
               "You strike aside $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N strikes aside your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N strikes aside $n's %s.",
               attack
            );
            break;
         }
         case (3):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s to the left.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s to $S left.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s to $S left.",
               attack
            );
            break;
         }
         case (4):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s to the right.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s to $S right.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s to $S right.",
               attack
            );
            break;
         }
         case (5):
         {
            sprintf
            (
               buf1,
               "You duck and parry $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N ducks and parries your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N ducks and parries $n's %s.",
               attack
            );
            break;
         }
         case (6):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s and deflect it to the left.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s and deflects it to $S left.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s and deflects it to $S left.",
               attack
            );
            break;
         }
         case (7):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s and deflect it to the left.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s and deflects it to $S left.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s and deflects it to $S left.",
               attack
            );
            break;
         }
         case (8):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s and deflect it downward.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s and deflects it downward.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s and deflects it downward.",
               attack
            );
            break;
         }
         case (9):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s and deflect it upward.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s and deflects it upward.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s and deflects it upward.",
               attack
            );
            break;
         }
         case (10):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You swim to the left and parry $n's %s to the right.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N swims to $S left and parries your %s to $S right.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N swims to $S left and parries $n's %s to $S right.",
                  attack
               );
               break;
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You fly to the left and parry $n's %s to the right.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N flies to $S left and parries your %s to $S right.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N flies to $S left and parries $n's %s to $S right.",
                  attack
               );
               break;
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You hop to the left and parry $n's %s to the right.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N hops to $S left and parries your %s to $S right.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N hops to $S left and parries $n's %s to $S right.",
                  attack
               );
               break;
            }
         }
         case (11):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You swim to the right and parry $n's %s to the left.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N swims to $S right and parries your %s to $S left.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N swims to $S right and parries $n's %s to $S left.",
                  attack
               );
               break;
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You fly to the right and parry $n's %s to the left.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N fly to $S right and parries your %s to $S left.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N fly to $S right and parries $n's %s to $S left.",
                  attack
               );
               break;
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You hop to the right and parry $n's %s to the left.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N hops to $S right and parries your %s to $S left.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N hops to $S right and parries $n's %s to $S left.",
                  attack
               );
               break;
            }
         }
         case (12):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You swim backward and parry $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N swim backward and parries your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N swim backward and parries $n's %s.",
                  attack
               );
               break;
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You fly backward and parry $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N flies backward and parries your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N flies backward and parries $n's %s.",
                  attack
               );
               break;
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You hop backward and parry $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N hops backward and parries your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N hops backward and parries $n's %s.",
                  attack
               );
               break;
            }
         }
      }
   }
   else
   {
      switch(number_range(1, 20))
      {
         case (1):
         {
            sprintf
            (
               buf1,
               "You bring both of your weapons across to the left and dual parry $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N brings both of $S weapons across to $S left and dual parries your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N brings both of $S weapons across to $S left and dual parries $n's %s.",
               attack
            );
            break;
         }
         case (2):
         {
            sprintf
            (
               buf1,
               "You bring both of your weapons across to the right and dual parry $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N brings both of $S weapons across to $S right and dual parries your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N brings both of $S weapons across to $S right and dual parries $n's %s.",
               attack
            );
            break;
         }
         case (3):
         {
            sprintf
            (
               buf1,
               "You cross both of your weapons in front of you and bring them down, dual parrying $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N crosses both of $S weapons in front of $Mself and brings them down, dual parrying your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N crosses both of $S weapons in front of $Mself and brings them down, dual parrying $n's %s.",
               attack
            );
            break;
         }
         case (4):
         {
            sprintf
            (
               buf1,
               "You strike out with both weapons and dual parry $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N strikes out with both weapons and dual parries your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N strikes out with both weapons and dual parries $n's %s.",
               attack
            );
            break;
         }
         case (5):
         {
            sprintf
            (
               buf1,
               "You quickly spin around, causing both of your weapons to alternatingly dual parry $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N quickly spins around, causing both of $S weapons to alternatingly dual parry your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N quickly spins around, causing both of $S weapons to alternatingly dual parry $n's %s.",
               attack
            );
            break;
         }
         case (6):
         {
            sprintf
            (
               buf1,
               "You whirl both of your weapons at high speeds around yourself, dual parrying $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N whirls both of $S weapons at high speeds around $Mself, dual parrying your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N whirls both of $S weapons at high speeds around $Mself, dual parrying $n's %s.",
               attack
            );
            break;
         }
         case (7):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s with both of your weapons, deflecting it to the left.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s with both of $S weapons, deflecting it to $S left.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s with both of $S weapons, deflecting it to $S left.",
               attack
            );
            break;
         }
         case (8):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s with both of your weapons, deflecting it to the right.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s with both of $S weapons, deflecting it to $S right.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s with both of $S weapons, deflecting it to $S right.",
               attack
            );
            break;
         }
         case (9):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s with both of your weapons, deflecting it downward.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s with both of $S weapons, deflecting it downward.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s with both of $S weapons, deflecting it downward.",
               attack
            );
            break;
         }
         case (10):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s with both of your weapons, deflecting it upward.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s with both of $S weapons, deflecting it upward.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s with both of $S weapons, deflecting it upward.",
               attack
            );
            break;
         }
         case (11):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s to the left with one of your weapons and downward with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s to $S left with one of $S weapons and downward with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s to $S left with one of $S weapons and downward with the other.",
               attack
            );
            break;
         }
         case (12):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s to the left with one of your weapons and upward with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s to $S left with one of $S weapons and upward with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s to $S left with one of $S weapons and upward with the other.",
               attack
            );
            break;
         }
         case (13):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s to the right with one of your weapons and downward with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s to $S right with one of $S weapons and downward with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s to $S right with one of $S weapons and downward with the other.",
               attack
            );
            break;
         }
         case (14):
         {
            sprintf
            (
               buf1,
               "You deflect $n's %s to the right with one of your weapons and upward with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N deflects your %s to $S right with one of $S weapons and upward with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N deflects $n's %s to $S right with one of $S weapons and upward with the other.",
               attack
            );
            break;
         }
         case (15):
         {
            sprintf
            (
               buf1,
               "You deflect $n's %s downward with one of your weapons and to the left with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N deflects your %s downward with one of $S weapons and to $S left with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N deflects $n's %s downward with one of $S weapons and to $S left with the other.",
               attack
            );
            break;
         }
         case (16):
         {
            sprintf
            (
               buf1,
               "You deflect $n's %s downward with one of your weapons and to the right with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N deflects your %s downward with one of $S weapons and to $S right with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N deflects $n's %s downward with one of $S weapons and to $S right with the other.",
               attack
            );
            break;
         }
         case (17):
         {
            sprintf
            (
               buf1,
               "You deflect $n's %s upward with one of your weapons and to the left with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N deflects your %s upward with one of $S weapons and to $S left with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N deflects $n's %s upward with one of $S weapons and to $S left with the other.",
               attack
            );
            break;
         }
         case (18):
         {
            sprintf
            (
               buf1,
               "You parry $n's %s upward with one of your weapons and to the right with the other.",
               attack
            );
            sprintf
            (
               buf2,
               "$N parries your %s upward with one of $S weapons and to $S right with the other.",
               attack
            );
            sprintf
            (
               buf3,
               "$N parries $n's %s upward with one of $S weapons and to $S right with the other.",
               attack
            );
            break;
         }
         case (19):
         {
            sprintf
            (
               buf1,
               "You spin and whirl your weapons around, dual parrying $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N spins and whirls $S weapons around, dual parrying your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N spins and whirls $S weapons around, dual parrying $n's %s.",
               attack
            );
            break;
         }
         case (20):
         {
            sprintf
            (
               buf1,
               "You duck and cross your weapons above your head, dual parrying $n's %s.",
               attack
            );
            sprintf
            (
               buf2,
               "$N ducks and crosses $S weapons above $S head, dual parrying your %s.",
               attack
            );
            sprintf
            (
               buf3,
               "$N ducks and crosses $S weapons above $S head, dual parrying $n's %s.",
               attack
            );
            break;
         }
      }
   }
   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_CHAR
   );
   /*
   Commented out 3rd party parry
   to prevent spam with large fights.
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );
   */
   /*
   act( "You parry $n's attack.",  ch, NULL, victim, TO_VICT    );
   act( "$N parries your attack.", ch, NULL, victim, TO_CHAR    );
   */

   if (check_counter_defense(ch, victim))
   {
      switch(number_range(1,3))
      {
         case (1):
         {
            act
            (
               "$n counters your parry!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You counter $N's parry!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n counters $N's parry!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (2):
         {
            act
            (
               "$n deflects your parry and attacks with a vicious counterstrike!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You deflect $N's parry and attack with a vicious counterstrike!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n deflects $N's parry and attacks with a vicious counterstrike!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (3):
         {
            act
            (
               "$n knocks aside your parry with $s own and strikes you in return!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You knock aside $N's parry with your own and strike $M in return!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n knocks aside $N's parry with $s own and strikes $N in return!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
      }
      defense_not_countered = FALSE;
      return FALSE;
   }

   check_improve
   (
      victim,
      gsn_parry,
      TRUE,
      6
   );
   return TRUE;
}

bool check_halo_sun(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   if(!IS_AWAKE(victim))
   {
      return FALSE;
   }

   if(!is_affected(victim,gsn_halo_of_the_sun))
   {
      return FALSE;
   }

   /*    if( house_down(victim, HOUSE_LIGHT) )
   return FALSE; */

   if(number_percent( ) >= 7)
   {
      check_improve(victim, gsn_halo_of_the_sun, FALSE, 6);
      return FALSE;
   }

   act
   (
      "A flash of bright light surrounds you and $n's attack is turned aside!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "A flash of bright light surrounds $N and your attack is turned aside!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "A flash of bright light surrounds $N and $n's attack is turned aside!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );

   check_improve(victim, gsn_halo_of_the_sun, TRUE, 6);
   return TRUE;
}

/* Block for monks */
bool check_block(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;
   extern bool defense_not_countered;

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }
   if (IS_NPC(victim))
   {
      return FALSE;
   }

   chance = get_skill(victim,gsn_block);

   if ( /* victim->level <skill_table[gsn_block].skill_level[victim->class] */
   !has_skill(victim,gsn_block))
   {
      return FALSE;
   }

   chance /= 4;

   if (get_eq_char(victim, WEAR_WIELD) != NULL)
   {
      return FALSE;
   }

   if(see_state(victim, ch) == NO_SEE_TARGET)
   {
      chance /= 2;
   }

   if (is_affected(ch, gsn_killer_instinct))
   {
      /* at 100% skill, it will reduce by 1/3rd */
      chance -= chance * get_skill(ch, gsn_killer_instinct) / 300;
   }
   if
   (
      number_percent( ) >= chance +
      (
         victim->drain_level +
         victim->level
      ) -
      (
         ch->drain_level +
         ch->level
      )
   )
   {
      check_improve(victim,gsn_block,FALSE,5);
      return FALSE;
   }

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch,WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch,WEAR_WIELD);
   }


   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT +
      MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In check_block, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }

   switch(number_range(1,16))
   {
      case (1):
      {
         sprintf
         (
            buf1,
            "You channel your chi and block $n's %s with your bare hands.",
            attack
         );
         sprintf
         (
            buf2,
            "$N channels $S chi and blocks your %s with $S bare hands.",
            attack
         );
         sprintf
         (
            buf3,
            "$N channels $S chi and blocks $n's %s with $S bare hands.",
            attack
         );
         break;
      }
      case (2):
      {
         sprintf
         (
            buf1,
            "You cross your forearms in front of you and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N crosses $S forearms in front of $Mself and blocks your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N crosses $S forearms in front of $Mself and blocks $n's %s.",
            attack
         );
         break;
      }
      case (3):
      {
         sprintf
         (
            buf1,
            "You swing your left arm in front of you and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N swings $S left arm in front of $Mself and blocks your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N swings $S left arm in front of $Mself and blocks $n's %s.",
            attack
         );
         break;
      }
      case (4):
      {
         sprintf
         (
            buf1,
            "You swing your right arm in front of you and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N swings $S right arm in front of $Mself and blocks your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N swings $S right arm in front of $Mself and blocks $n's %s.",
            attack
         );
         break;
      }
      case (5):
      {
         sprintf
         (
            buf1,
            "You focus your chi and bring your hand into the path of $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N focuses $S chi and brings $S hand into the path of your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N focuses $S chi and brings $S hand into the path of $n's %s.",
            attack
         );
         break;
      }
      case (6):
      {
         sprintf
         (
            buf1,
            "You lean to the left and slap your left hand across, blocking $s %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N leans to $S left and slaps $S left hand across, blocking your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N leans to $S left and slaps $S left hand across, blocking $n's %s.",
            attack
         );
         break;
      }
      case (7):
      {
         sprintf
         (
            buf1,
            "You lean to the right and slap your right hand across, blocking $s %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N leans to $S right and slaps $S right hand across, blocking your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N leans to $S right and slaps $S right hand across, blocking $n's %s.",
            attack
         );
         break;
      }
      case (8):
      {
         sprintf
         (
            buf1,
            "You get into a horse stance and raise your left arm to block $s %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N gets into a horse stance and raises $S left arm to block your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N gets into a horse stance and raises $S left arm to block $n's %s.",
            attack
         );
         break;
      }
      case (9):
      {
         sprintf
         (
            buf1,
            "You get into a horse stance and raise your right arm to block $s %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N gets into a horse stance and raises $S right arm to block your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N gets into a horse stance and raises $S right arm to block $n's %s.",
            attack
         );
         break;
      }
      case (10):
      {
         sprintf
         (
            buf1,
            "You get into a horse stance and flip your left arm upward to block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N gets into a horse stance and flips $S left arm upward to block your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N gets into a horse stance and flips $S left arm upward to block $n's %s.",
            attack
         );
         break;
      }
      case (11):
      {
         sprintf
         (
            buf1,
            "You get into a horse stance and flip your right arm upward to block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N gets into a horse stance and flips $S right arm upward to block your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N gets into a horse stance and flips $S right arm upward to block $n's %s.",
            attack
         );
         break;
      }
      case (12):
      {
         sprintf
         (
            buf1,
            "You raise and tuck in your left leg and swing your left arm downward to block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N raises and tucks in $S left leg and swings $S left arm downward to block your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N raises and tucks in $S left leg and swings $S left arm downward to block $n's %s.",
            attack
         );
         break;
      }
      case (13):
      {
         sprintf
         (
            buf1,
            "You raise and tuck in your right leg and swing your right arm downward to block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N raises and tucks in $S right leg and swings $S right arm downward to block your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N raises and tucks in $S right leg and swings $S right arm downward to block $n's %s.",
            attack
         );
         break;
      }
      case (14):
      {
         sprintf
         (
            buf1,
            "You leap into the air and block $n's %s partway through your front flip.",
            attack
         );
         sprintf
         (
            buf2,
            "$N leaps into the air and blocks your %s partway through $S front flip.",
            attack
         );
         sprintf
         (
            buf3,
            "$N leaps into the air and blocks $n's %s partway through $S front flip.",
            attack
         );
         break;
      }
      case (15):
      {
         sprintf
         (
            buf1,
            "You leap into the air and block $n's %s partway through your backflip.",
            attack
         );
         sprintf
         (
            buf2,
            "$N leaps into the air and blocks your %s partway through $S backflip.",
            attack
         );
         sprintf
         (
            buf3,
            "$N leaps into the air and blocks $n's %s partway through $S backflip.",
            attack
         );
         break;
      }
      case (16):
      {
         sprintf
         (
            buf1,
            "You flip onto your back, block $n's %s with your hands and leap back to your feet.",
            attack
         );
         sprintf
         (
            buf2,
            "$N flips onto $S back, blocks $n's %s with $S hands and leaps back to $S feet.",
            attack
         );
         sprintf
         (
            buf3,
            "$N flips onto $S back, blocks $n's %s with $S hands and leaps back to $S feet.",
            attack
         );
         break;
      }
   }

   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_CHAR
   );
   /*
   3rd party block message removed - Fizz
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );
   */
   /*
   act
   (
      "You parry $n's attack.",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$N parries your attack.",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   */
   if (check_counter_defense(ch, victim))
   {
      switch(number_range(1,4))
      {
         case (1):
         {
            act
            (
               "$n strikes you just as you try to block $s attack!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N just as $E tries to block your attack!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N just as $E tries to block $n's attack!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (2):
         {
            act
            (
               "$n strikes you just as you try to block $s attack!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N just as $E tries to block your attack!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N just as $E tries to block $n's attack!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (3):
         {
            act
            (
               "$n strikes at your blocking hand, countering your block!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N's blocking hand, countering $N's block!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N's blocking hand, countering $N's block!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (4):
         {
            act
            (
               "$n quickly strikes you just as you block $s initial attack!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You quickly strike $N just as $E blocks your initial attack!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes $N just as $N blocks $S initial attack!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
      }
      defense_not_countered = FALSE;
      return FALSE;
   }

   check_improve(victim, gsn_block, TRUE, 6);
   return TRUE;
}

/*
* Check for shield block.
*/
bool check_shield_block(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   OBJ_DATA* shield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;
   extern bool defense_not_countered;
   bool shield_law = FALSE;

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }


   if (is_affected(victim, gsn_airshield) && number_percent() <= 25)
   {
      sprintf
      (
         buf1,
         "A sharp current of air about you deflects $n's attack."
      );
      sprintf
      (
         buf2,
         "A sharp current of air about $N deflects your attack."
      );
      act
      (
         buf1,
         ch,
         0,
         victim,
         TO_VICT
      );
      act
      (
         buf2,
         ch,
         0,
         victim,
         TO_CHAR
      );
      return TRUE;
   }

   if ((shield = get_eq_char(victim, WEAR_SHIELD)) == NULL)
   {
      return FALSE;
   }

   /* enforcer shield of law */
   if (shield->pIndexData->vnum == OBJ_VNUM_PROTECTORATE)
   {
      shield_law = TRUE;
   }

   if (!shield_law)
   {
      if (/* victim->level < skill_table[gsn_shield_block].skill_level[victim->class] */
      !has_skill(victim, gsn_shield_block))
      {
         return FALSE;
      }
   }

   chance = ((get_skill(victim, gsn_shield_block) / 4) + 15);

   if (shield_law)
   {
      chance += 15;
   }

   chance += (victim->drain_level + victim->level - (ch->drain_level + ch->level));
   if (is_affected(ch, gsn_killer_instinct))
   {
      /* at 100% skill, it will reduce by 1/3rd */
      chance -= chance * get_skill(ch, gsn_killer_instinct) / 300;
   }
   if (number_percent( ) >= chance)
   {
      check_improve(victim, gsn_shield_block, FALSE, 4);
      return FALSE;
   }

   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }

   if (dt == gsn_archery)
   {
      OBJ_DATA* arrow;
      if ((arrow = get_eq_char(ch, WEAR_ABOUT)) != NULL)
      {
         if ((arrow = arrow->contains) != NULL)
         {
            if (arrow->item_type == ITEM_WEAPON)
            {
               wield = arrow;
            }
         }
      }
   }

   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT +
      MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In shield block, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }
   switch(number_range(1,5))
   {
      case (1):
      {
         sprintf
         (
            buf1,
            "You raise your shield and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N raises $S shield to block your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N raises $S shield to block $n's %s.",
            attack
         );
         break;
      }
      case (2):
      {
         sprintf
         (
            buf1,
            "You brace yourself behind your shield and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N braces $Mself behind $S shield and blocks your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N braces $Mself behind $S shield and blocks $n's %s.",
            attack
         );
         break;
      }
      case (3):
      {
         sprintf
         (
            buf1,
            "You duck down and hide behind your shield and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N ducks down behind $S shield and blocks your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N ducks down behind $S shield and blocks $n's %s.",
            attack
         );
         break;
      }
      case (4):
      {
         sprintf
         (
            buf1,
            "You quickly align your shield in front of yourself and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N quickly aligns $S shield in front of $Mself and blocks your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N quickly aligns $S shield in front of $Mself and blocks $n's %s.",
            attack
         );
         break;
      }
      case (5):
      {
         sprintf
         (
            buf1,
            "You snap your shield before yourself, brace it, and block $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N snaps $S shield before $Mself, braces it, and blocks your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N snaps $S shield before $Mself, braces it, and blocks $n's %s.",
            attack
         );
         break;
      }
   }
   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_CHAR
   );
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );
   /*
   act( "You shield block $n's attack.",  ch, NULL, victim,
   TO_VICT    );
   act( "$N's shield blocks your attack.", ch, NULL, victim,
   TO_CHAR    );
   */

   if (check_counter_defense(ch, victim))
   {
      switch(number_range(1,3))
      {
         case (1):
         {
            act
            (
               "$n strikes your shield hard enough to cause it to hit you!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N's shield hard enough to cause it to hit $M!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N's shield hard enough to cause it to hit $N!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (2):
         {
            act
            (
               "$n strikes you by attacking around the side of your shield!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N by attacking around the side of $N's shield!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N by attacking around the side of $N's shield!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (3):
         {
            act
            (
               "$n strikes you by attacking around the side of your shield!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N by attacking around the side of $N's shield!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N by attacking around the side of $N's shield!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (4):
         {
            act
            (
               "$n strikes you by attacking around the top of your shield!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N by attacking around the top of $N's shield!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N by attacking around the top of $N's shield!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (5):
         {
            act
            (
               "$n strikes you by attacking around the bottom of your shield!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N by attacking around the bottom of $N's shield!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N by attacking around the bottom of $N's shield!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         defense_not_countered = FALSE;
         return FALSE;
      }
   }

   check_improve(victim, gsn_shield_block, TRUE, 4);
   return TRUE;
}

bool check_tumble( CHAR_DATA *ch, CHAR_DATA *victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA *wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char *attack;
   int check_uppercut = 0;

   if ( !IS_AWAKE(victim) )
   return FALSE;

   if (IS_NPC(victim))
   return FALSE;

   if (!has_skill(victim, gsn_tumble)||victim->pcdata->learned[gsn_tumble] <1)
   return FALSE;

   chance = ( get_skill(victim,gsn_tumble) / 8);

   if( see_state(victim,ch) == NO_SEE_TARGET )
   chance /= 2;

   chance += (victim->level/5);

   if (is_affected(ch, gsn_killer_instinct))
   {
      /* at 100% skill, it will reduce by 1/3rd */
      chance -= chance * get_skill(ch, gsn_killer_instinct) / 300;
   }

   if (chance > 50)
   chance = 50;

   if ( number_percent( ) >= chance )
   {
      check_improve(victim,gsn_tumble,FALSE,4);
      return FALSE;
   }

   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   else if (dt == gsn_tertiary_wield)
   wield = get_eq_char(ch,WEAR_TERTIARY_WIELD);
   else
   wield = get_eq_char(ch,WEAR_WIELD);

   if (dt == gsn_archery){
      OBJ_DATA *arrow;
      if ((arrow = get_eq_char(ch,WEAR_ABOUT)) != NULL)
      if ((arrow = arrow->contains) != NULL)
      if (arrow->item_type == ITEM_WEAPON)
      wield = arrow;
   }

   if (wield != NULL)
   tmp_dt += wield->value[3];
   else
   tmp_dt += ch->dam_type;


   if (tmp_dt > TYPE_HIT && tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE)
   attack = attack_table[tmp_dt - TYPE_HIT].noun;
   else
   {
      bug("In tumble, bad dam message: dt %d.",tmp_dt);
      attack = attack_table[0].name;
   }
   /* code directly from dodge for damage messages */
   switch(number_range(1,3)){
      case 1:
      sprintf(buf3,"$N tumbles out of the way of $n's %s.", attack);
      sprintf(buf2,"You tumble out of the way of $n's %s.",attack);
      sprintf(buf1,"$N tumbles out of the way of your %s.",attack);
      break;
      case 2:
      sprintf(buf3,"$N leaps over $n's %s.",attack);
      sprintf(buf2,"You leap over $n's %s.",attack);
      sprintf(buf1,"$N leaps over your %s.",attack);
      break;
      case 3:
      check_uppercut = 1;
      sprintf(buf3,"$N ducks beneath $n's %s.", attack);
      sprintf(buf2,"You duck beneath $n's %s.",attack);
      sprintf(buf1,"$N ducks beneath your %s.",attack);
      break;
   }
   act(buf3,ch,0,victim, TO_NOTVICT);
   act(buf2,ch,0,victim,TO_VICT);
   act(buf1,ch,0,victim,TO_CHAR);
   if (number_percent() < 30 && check_uppercut)
   {
      act("You punch $N squarely in the jaw with a rapid uppercut!",victim,NULL,ch,TO_CHAR);
      act("$n strikes you squarely in the jaw with an uppercut!",victim,NULL,ch,TO_VICT);
      act("$n strikes $N in the jaw with a rapid uppercut!",victim,NULL,ch,TO_NOTVICT);
      damage( victim, ch, number_range(30,65), gsn_tumble,DAM_BASH,TRUE);
   }
   check_improve(victim,gsn_tumble,TRUE,5);
   return TRUE;
}

bool check_acrobatics( CHAR_DATA *ch, CHAR_DATA *victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA *wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char *attack;

   if ( !IS_AWAKE(victim) )
   return FALSE;

   if (IS_NPC(victim))
   return FALSE;

   if (!has_skill(victim, gsn_acrobatics)||victim->pcdata->learned[gsn_acrobatics] <1)
   return FALSE;

   chance = ( get_skill(victim,gsn_acrobatics) / 8);

   if( see_state(victim,ch) == NO_SEE_TARGET )
   chance /= 2;

   chance += (victim->level/5);

   if (is_affected(ch, gsn_killer_instinct))
   {
      /* at 100% skill, it will reduce by 1/3rd */
      chance -= chance * get_skill(ch, gsn_killer_instinct) / 300;
   }

   if (chance > 50)
   chance = 50;

   if ( number_percent( ) >= chance )
   {
      check_improve(victim,gsn_acrobatics,FALSE,4);
      return FALSE;
   }

   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   else if (dt == gsn_tertiary_wield)
   wield = get_eq_char(ch,WEAR_TERTIARY_WIELD);
   else
   wield = get_eq_char(ch,WEAR_WIELD);

   if (dt == gsn_archery){
      OBJ_DATA *arrow;
      if ((arrow = get_eq_char(ch,WEAR_ABOUT)) != NULL)
      if ((arrow = arrow->contains) != NULL)
      if (arrow->item_type == ITEM_WEAPON)
      wield = arrow;
   }

   if (wield != NULL)
   tmp_dt += wield->value[3];
   else
   tmp_dt += ch->dam_type;


   if (tmp_dt > TYPE_HIT && tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE)
   attack = attack_table[tmp_dt - TYPE_HIT].noun;
   else
   {
      bug("In acrobatics, bad dam message: dt %d.",tmp_dt);
      attack = attack_table[0].name;
   }
   /* code directly from dodge for damage messages */
   switch(number_range(1,5)){
      case 1:
      sprintf(buf2,"You tumble out of the way of $n's %s.",attack);
      sprintf(buf1,"$N tumbles out of the way of your %s.",attack);
      break;
      case 2:
      sprintf(buf2,"You leap over $n's %s.",attack);
      sprintf(buf1,"$N leaps over your %s.",attack);
      break;
      case 3:
      sprintf(buf2,"You duck beneath $n's %s.",attack);
      sprintf(buf1,"$N ducks beneath your %s.",attack);
      break;
      case 4:
      sprintf(buf2,"You backflip out of the way of $n's %s.",attack);
      sprintf(buf1,"$N backflips out of the way of your %s.",attack);
      break;
      case 5:
      sprintf(buf2,"You somersault out of the way of $n's %s.",attack);
      sprintf(buf1,"$N somersaults out of the way of your %s.",attack);
      break;
   }
   act(buf2,ch,0,victim,TO_VICT);
   act(buf1,ch,0,victim,TO_CHAR);

   check_improve(victim,gsn_acrobatics,TRUE,5);
   return TRUE;

}

CHAR_DATA *check_evasive (CHAR_DATA *ch, CHAR_DATA *victim)
{
   int chance, i, count;
   CHAR_DATA *vch;
   CHAR_DATA *temp = NULL;

   if ( !IS_AWAKE(victim) )
   return FALSE;

   if( (chance = get_skill(victim,gsn_evasive_dodge)) < 1
   || !has_skill(victim,gsn_evasive_dodge) )
   return FALSE;

   chance /= 5;

   if (!can_see(victim,ch))
   chance /= 2;

   if ( number_percent() > chance )
   {
      check_improve(victim,gsn_evasive_dodge,FALSE,4);
      return FALSE;
   }

   count = 0;
   for( vch=ch->in_room->people; vch ;vch = vch->next_in_room )
   {
      if
      (
         vch == ch ||
         vch == victim ||
         vch->fighting != victim ||
         is_safe(ch, vch, IS_SAFE_SILENT)
      )
      {
         continue;
      }
      count++;
      temp = vch;
   }

   if( count < 1 )
   return NULL;

   if (count == 1 && temp)
   {
      vch = temp;
   }
   else
   {
      i = number_range(1, count);
      count = 0;
      for (vch=ch->in_room->people; vch ;vch = vch->next_in_room)
      {
         if
         (
            vch == ch ||
            vch == victim ||
            vch->fighting != victim ||
            is_safe(ch, vch, IS_SAFE_SILENT) ||
            ++count != i
         )
         {
            continue;
         }
         break;
      }
   }

   if( !vch )
   {
      bug("Bad target in evasive dodge!",0);
      return NULL;
   }

   act("You deftly evade $n's attack!",ch,0,victim,TO_VICT);
   act("$N deftly evades your attack!",ch,0,victim,TO_CHAR);
   check_improve(victim,gsn_evasive_dodge,TRUE,5);

   if (check_counter_defense(ch,victim)){
      act("$n counters your evasive dodge!",ch,0,victim,TO_VICT);
      act("You counter $N's evasive dodge!",ch,0,victim,TO_CHAR);
      return NULL;
   }

   act("Suddenly you find yourself at the business end of $n's attack!",ch,0,vch,TO_VICT);
   return vch;
}

bool check_taichi(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }

   if (IS_NPC(victim))
   {
      return FALSE;
   }

   if
   (
      !has_skill(victim, gsn_taichi) ||
      victim->pcdata->learned[gsn_taichi]<1
   )
   {
      return FALSE;
   }

   chance = (get_skill(victim, gsn_taichi) / 10);
   chance = UMAX(chance, 2);
   if (see_state(victim, ch) == NO_SEE_TARGET)
   {
      chance /= 2;
   }

   chance -= (ch->level-victim->level);

   if (chance > 15)
   {
      chance = 15;
   }

   if (number_percent() >= chance)
   {
      /*    check_improve(victim,gsn_taichi,FALSE,4); */
      return FALSE;
   }

   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }


   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT +
      MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In taichi, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }
   /* code directly from dodge for damage messages */

   switch(number_range(1,8))
   {
      case(1):
      {
         sprintf
         (
            buf1,
            "$N catches your %s and pulls you in before striking you!",
            attack
         );
         sprintf
         (
            buf2,
            "You catch $n's %s and pull $m in before striking $m!",
            attack
         );
         sprintf
         (
            buf3,
            "$N catches $n's %s and pulls $m in before striking $m!",
            attack
         );
         break;
      }
      case(2):
      {
         if (ch->race == grn_arborian)
         {
            sprintf
            (
               buf1,
               "$N catches your tendril and strikes you, deflecting the force of your %s back onto you!",
               attack
            );
            sprintf
            (
               buf2,
               "You catch $n's tendril and strike $m, deflecting the force of $s %s back onto $m!",
               attack
            );
            sprintf
            (
               buf3,
               "$N catches $n's tendril and strikes $m, deflecting the force of $s %s back onto $m!",
               attack
            );
            break;
         }
         else
         {
            sprintf
            (
               buf1,
               "$N catches your arm and strikes you, deflecting the force of your %s back onto you!",
               attack
            );
            sprintf
            (
               buf2,
               "You catch $n's arm and strike $m, deflecting the force of $s %s back onto $m!",
               attack
            );
            sprintf
            (
               buf3,
               "$N catches $n's arm and strikes $m, deflecting the force of $s %s back onto $m!",
               attack
            );
            break;
         }
      }
      case(3):
      {
         sprintf
         (
            buf1,
            "$N yanks you along the path of your attack, deflecting your %s and striking you with its force!",
            attack
         );
         sprintf
         (
            buf2,
            "You yank $n along the path of $s attack, deflecting $s %s and striking $m with its force!",
            attack
         );
         sprintf
         (
            buf3,
            "$N yanks $n along the path of $s attack, deflecting $s %s and striking $m with its force!",
            attack
         );
         break;
      }
      case(4):
      {
         sprintf
         (
            buf1,
            "$N deflects your %s, taking its force and striking you with a powerful elbow!",
            attack
         );
         sprintf
         (
            buf2,
            "You deflect $n's %s, taking its force and striking $m with a powerful elbow!",
            attack
         );
         sprintf
         (
            buf3,
            "$N deflects $n's %s, taking its force and striking $m with it a powerful elbow!",
            attack
         );
         break;
      }
      case(5):
      {
         if (ch->race == grn_arborian)
         {
            sprintf
            (
               buf1,
               "$N deflects your %s and uses the energy to strike you in the cornstalk!",
               attack
            );
            sprintf
            (
               buf2,
               "You deflect $n's %s and use the energy to strike $m in the cornstalk!",
               attack
            );
            sprintf
            (
               buf3,
               "$N deflects $n's %s and uses the energy to strike $m in the cornstalk!",
               attack
            );
            break;
         }
         else
         {
            sprintf
            (
               buf1,
               "$N deflects your %s and uses the energy to strike you in the head!",
               attack
            );
            sprintf
            (
               buf2,
               "You deflect $n's %s and use the energy to strike $m in the head!",
               attack
            );
            sprintf
            (
               buf3,
               "$N deflects $n's %s and uses the energy to strike $m in the head!",
               attack
            );
            break;
         }
      }
      case(6):
      {
         sprintf
         (
            buf1,
            "$N catches your %s and hurls its force right back at you!",
            attack
         );
         sprintf
         (
            buf2,
            "You catch $n's %s and hurls its force right back at $m!",
            attack
         );
         sprintf
         (
            buf3,
            "$N catches $n's %s and hurls its force right back at $m!",
            attack
         );
         break;
      }
      case(7):
      {
         if (ch->race == grn_arborian)
         {
            sprintf
            (
               buf1,
               "$N catches your %s and deflects it, striking your tendril with its force!",
               attack
            );
            sprintf
            (
               buf2,
               "You catch $n's %s and deflect it, striking $s tendril with its force!",
               attack
            );
            sprintf
            (
               buf3,
               "$N catches $n's %s and deflects it, striking $s tendril with its force!",
               attack
            );
            break;
         }
         else
         {
            sprintf
            (
               buf1,
               "$N catches your %s and deflects it, striking your hand with its force!",
               attack
            );
            sprintf
            (
               buf2,
               "You catch $n's %s and deflect it, striking $s hand with its force!",
               attack
            );
            sprintf
            (
               buf3,
               "$N catches $n's %s and deflects it, striking $s hand with its force!",
               attack
            );
            break;
         }
      }
      case(8):
      {
         sprintf
         (
            buf1,
            "$N deflects your %s and uses its force to throw you over $S shoulder!",
            attack
         );
         sprintf
         (
            buf2,
            "You deflect $n's %s and uses its force to throw $m over your shoulder!",
            attack
         );
         sprintf
         (
            buf3,
            "$N deflects $n's %s and uses its force to throw $m over $S shoulder!",
            attack
         );
         break;
      }
   }
   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_CHAR
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );

   check_improve
   (
      victim,
      gsn_taichi,
      TRUE,
      5
   );
   return TRUE;

}

bool check_judo(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }

   if (IS_NPC(victim))
   {
      return FALSE;
   }

   if
   (
      !has_skill(victim, gsn_judo) ||
      victim->pcdata->learned[gsn_judo]<1
   )
   {
      return FALSE;
   }

   chance = (get_skill(victim, gsn_judo) / 10);
   chance = UMAX(chance, 2);
   if (see_state(victim, ch) == NO_SEE_TARGET)
   {
      chance /= 2;
   }

   chance -= (ch->level-victim->level);

   if (chance > 15)
   {
      chance = 15;
   }

   if (number_percent() >= chance)
   {
      /*    check_improve(victim,gsn_judo,FALSE,4); */
      return FALSE;
   }

   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }


   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT +
      MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In judo, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }
   /* code directly from dodge for damage messages */
   switch(number_range(1,4))
   {
      case(1):
      {
         sprintf
         (
            buf1,
            "$N deflects your %s back on you!",
            attack
         );
         sprintf
         (
            buf2,
            "You deflect $n's %s back on $m!",
            attack
         );
         sprintf
         (
            buf3,
            "$N deflects $n's %s back on $m!",
            attack
         );
         break;
      }
      case(2):
      {
         sprintf
         (
            buf1,
            "$N deflects your %s and tosses you over $S shoulder!",
            attack
         );
         sprintf
         (
            buf2,
            "You deflect $n's %s and toss $m over your shoulder!",
            attack
         );
         sprintf
         (
            buf3,
            "$N deflects $n's %s and tosses $m over $S shoulder!",
            attack
         );
         break;
      }
      case(3):
      {
         sprintf
         (
            buf1,
            "$N deflects your %s and slams you to the ground!",
            attack
         );
         sprintf
         (
            buf2,
            "You deflect $n's %s slam $m to the ground!",
            attack
         );
         sprintf
         (
            buf3,
            "$N deflects $n's %s and slams $m to the ground!",
            attack
         );
         break;
      }
      case(4):
      {
         sprintf
         (
            buf1,
            "$N deflects your %s and pushes you over backward!",
            attack
         );
         sprintf
         (
            buf2,
            "You deflect $n's %s and push $m over backward!",
            attack
         );
         sprintf
         (
            buf3,
            "$N deflects $n's %s and push $m over backward!",
            attack
         );
         break;
      }
   }

   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_CHAR
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );

   check_improve
   (
      victim,
      gsn_judo,
      TRUE,
      5
   );
   return TRUE;

}

bool check_dance_venom(CHAR_DATA *ch, CHAR_DATA *victim)
{
   int chance;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];

   if ( !IS_AWAKE(ch) )
   return FALSE;

   if (IS_NPC(ch))
   return FALSE;

   if (!has_skill(ch,gsn_dance_venom)||ch->pcdata->learned[gsn_dance_venom]<1)
   return FALSE;

   chance = ( get_skill(ch,gsn_dance_venom) / 10);
   chance = UMAX(chance, 2);
   if ( number_percent( ) >= chance )
   {
      if (number_range(0,4) == 0)
      check_improve(ch,gsn_dance_venom,FALSE,4);
      return FALSE;
   }

   /* code directly from dodge for damage messages */
   sprintf(buf1,"You begin a DEADLY dance of venom.");
   sprintf(buf2,"$n begins a DEADLY dance of venom.");
   act(buf2,ch,0,victim,TO_VICT);
   act(buf1,ch,0,victim,TO_CHAR);
   act(buf2,ch,0,victim,TO_NOTVICT);

   check_improve(ch,gsn_dance_venom,TRUE,3);
   return TRUE;

}


bool check_side_step(CHAR_DATA* ch, CHAR_DATA* victim, int dt )
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;
   extern bool defense_not_countered;

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }

   if (IS_NPC(victim))
   {
      return FALSE;
   }

   if
   (
      !has_skill(victim, gsn_side_step)||
      victim->pcdata->learned[gsn_side_step]<1
   )
   {
      return FALSE;
   }

   chance = (get_skill(victim, gsn_side_step) / 10);
   chance = UMAX(chance, 2);

   if(see_state(victim,ch) == NO_SEE_TARGET)
   {
      chance /= 2;
   }

   chance += (victim->level/5);

   if (chance > 40)
   {
      chance = 40;
   }

   if (is_affected(ch, gsn_killer_instinct))
   {
      /* at 100% skill, it will reduce by 1/3rd */
      chance -= chance * get_skill(ch, gsn_killer_instinct) / 300;
   }

   if (number_percent( ) >= chance)
   {
      check_improve
      (
         victim,
         gsn_side_step,
         FALSE,
         4
      );
      return FALSE;
   }

   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }

   if (dt == gsn_archery)
   {
      OBJ_DATA *arrow;
      if ((arrow = get_eq_char(ch, WEAR_ABOUT)) != NULL)
      if ((arrow = arrow->contains) != NULL)
      if (arrow->item_type == ITEM_WEAPON)
      wield = arrow;
   }

   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT +
      MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In side step, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }

   /* code directly from dodge for damage messages */
   switch(number_range(1,12))
   {
      case (1):
      {
         sprintf
         (
            buf1,
            "You execute a cartwheel to the left and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N executes a cartwheel to $S left and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N executes a cartwheel to $S left and avoids $n's %s.",
            attack
         );
         break;
      }
      case (2):
      {
         sprintf
         (
            buf1,
            "You execute a cartwheel to the right and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N executes a cartwheel to $S right and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N executes a cartwheel to $S right and avoids $n's %s.",
            attack
         );
         break;
      }
      case (3):
      {
         sprintf
         (
            buf1,
            "You quickly step to the left and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N quickly steps to $S left and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N quickly steps to $S left and avoids $n's %s.",
            attack
         );
         break;
      }
      case (4):
      {
         sprintf
         (
            buf1,
            "You quickly step to the right and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N quickly steps to $S right and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N quickly steps to $S right and avoids $n's %s.",
            attack
         );
         break;
      }
      case (5):
      {
         sprintf
         (
            buf1,
            "You dive and roll to the left to avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N dives and rolls to $S left to avoid your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N dives and rolls to $S left to avoid $n's %s.",
            attack
         );
         break;
      }
      case (6):
      {
         sprintf
         (
            buf1,
            "You dive and roll to the right to avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N dives and rolls to $S right to avoid your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N dives and rolls to $S right to avoid $n's %s.",
            attack
         );
         break;
      }
      case (7):
      {
         sprintf
         (
            buf1,
            "You twist and spin horizontally while leaping to the left and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N twists and spins horizontally while leaping to $S left and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N twists and spins horizontally while leaping to $S left and avoids $n's %s.",
            attack
         );
         break;
      }
      case (8):
      {
         sprintf
         (
            buf1,
            "You twist and spin horizontally while leaping to the right and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N twists and spins horizontally while leaping to $S right and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N twists and spins horizontally while leaping to $S right and avoids $n's %s.",
            attack
         );
         break;
      }
      case (9):
      {
         sprintf
         (
            buf1,
            "You execute a one-handed cartwheel to the left and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N executes a one-handed cartwheel to $S left and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N executes a one-handed cartwheel to $S left and avoids $n's %s.",
            attack
         );
         break;
      }
      case (10):
      {
         sprintf
         (
            buf1,
            "You execute a one-handed cartwheel to the right and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N executes a one-handed cartwheel to $S right and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N executes a one-handed cartwheel to $S right and avoids $n's %s.",
            attack
         );
         break;
      }
      case (11):
      {
         sprintf
         (
            buf1,
            "You execute an aerial cartwheel to the left and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N executes an aerial cartwheel to $S left and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N executes an aerial cartwheel to $S left and avoids $n's %s.",
            attack
         );
         break;
      }
      case (12):
      {
         sprintf
         (
            buf1,
            "You execute an aerial cartwheel to the right and avoid $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N executes an aerial cartwheel to $S right and avoids your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N executes an aerial cartwheel to $S right and avoids $n's %s.",
            attack
         );
         break;
      }
      default:
      {
         sprintf
         (
            buf1,
            "$N quickly steps out of the way of your %s.",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_CHAR
         );
         sprintf
         (
            buf2,
            "You quickly step out of the way of $n's %s.",
            attack
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_VICT
         );
         sprintf
         (
            buf3,
            "$N quickly steps out of the way of $n's %s.",
            attack
         );
         break;
      }
   }
   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_CHAR
   );
   /*
   removed 3rd party sidestep message - Fizz
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );
   */

   if (check_counter_defense(ch, victim))
   {
      switch(number_range(1,3))
      {
         case (1):
         {
            act
            (
               "You move and counter $N's side step!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n moves and counters your side step!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$n moves and counters $N's side step!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (2):
         {
            act
            (
               "You strike $N's midway through $S side step!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes you midway through your side step!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$n strikes $N midway through $S side step!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (3):
         {
            act
            (
               "You counter $N's side step!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n counters your side step!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$n counters $N's side step!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
      }

      defense_not_countered = FALSE;
      return FALSE;
   }

   check_improve
   (
      victim,
      gsn_side_step,
      TRUE,
      5
   );
   return TRUE;
}

bool check_counter_defense(CHAR_DATA* ch, CHAR_DATA* victim)
{
   int chance;
   int roll;

   if (IS_NPC(ch))
   {
      return FALSE;
   }

   if
   (
      !has_skill(ch, gsn_counter_defense) ||
      ch->pcdata->learned[gsn_counter_defense] < 1
   )
   {
      return FALSE;
   }

   chance = get_skill(ch, gsn_counter_defense);
   chance = chance/5;
   chance = UMAX(chance, 2);


   chance = chance - (ch->level - victim->level) * 2;

   roll = number_percent();

   if (roll < chance)
   {
      check_improve
      (
         ch,
         gsn_counter_defense,
         TRUE,
         4
      );
      return TRUE;
   }
   /*   check_improve(ch,gsn_counter_defense,FALSE,1); */
   return FALSE;
}

/*
* Check for dodge.
*/
bool check_dodge(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char attack[MAX_STRING_LENGTH];
   int dex;
   int dexa;
   extern bool defense_not_countered;
   bool monk_dodge;

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }

   chance = (3 * get_skill(victim, gsn_dodge) / 10);
   dex = get_curr_stat(victim, STAT_DEX);
   dexa= get_curr_stat(ch, STAT_DEX);
   if (dex <= 5)
   {
      chance += 0;
   }
   else if (dex <= 10)
   {
      chance += dex/2;
   }
   else if (dex <=15)
   {
      chance += (2*dex/3);
   }
   else if (dex <= 20)
   {
      chance += (8*dex/10);
   }
   else
   {
      chance += dex;
      chance+=dex-dexa;
      chance+=(ch->size-victim->size)*5;
   }
   if (see_state(victim, ch) == NO_SEE_TARGET)
   {
      chance /= 2;
   }

   if (is_affected(ch, gsn_killer_instinct))
   {
      /* at 100% skill, it will reduce by 1/3rd */
      chance -= chance * get_skill(ch, gsn_killer_instinct) / 300;
   }

   if
   (
      number_percent( ) >= chance +
      (
         victim->drain_level +
         victim->level
      ) -
      (
         ch->drain_level +
         ch->level
      )
   )
   {
      check_improve(victim, gsn_dodge, FALSE,4);
      return FALSE;
   }

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch,WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch,WEAR_WIELD);
   }

   if (dt == gsn_archery)
   {
      OBJ_DATA *arrow;
      if ((arrow = get_eq_char(ch,WEAR_ABOUT)) != NULL)
      if ((arrow = arrow->contains) != NULL)
      if (arrow->item_type == ITEM_WEAPON)
      wield = arrow;
   }

   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }
   attack[0] = '\0';
   if (dt != gsn_skull_bash)
   {
      if (tmp_dt > TYPE_HIT && tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE)
      {
         sprintf
         (
            attack,
            "%s",
            attack_table[tmp_dt - TYPE_HIT].noun
         );
      }
      else
      {
         bug("In dodge, bad dam message: dt %d.", tmp_dt);
         sprintf
         (
            attack,
            "%s",
            attack_table[0].name
         );
      }
   }
   else
   {
      sprintf(attack, "skull bashing");
   }
   if (dt == gsn_fist_god)
   sprintf(attack, "pound");

   monk_dodge =
   (
      victim->class == CLASS_MONK ||
      (
         victim->class == CLASS_THIEF &&
         victim->pcdata->special == SUBCLASS_NINJA
      ) ||
      victim->id == ID_DRINLINDA
   );

   switch(number_range(1, 8))
   {
      case (1):
      {
         sprintf
         (
            buf1,
            "You duck and dodge $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N ducks and dodges your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N ducks and dodges $n's %s.",
            attack
         );
         break;
      }
      case (2):
      {
         sprintf
         (
            buf1,
            "You lean to the left and dodge $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N leans to $S left and dodges your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N leans to $S left and dodges $n's %s.",
            attack
         );
         break;
      }
      case (3):
      {
         sprintf
         (
            buf1,
            "You lean to the right and dodge $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N leans to $S right and dodges your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N leans to $S right and dodges $n's %s.",
            attack
         );
         break;
      }
      case (4):
      {
         sprintf
         (
            buf1,
            "You lean back and dodge $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N leans back and dodges your %s.",
            attack
         );
         /* sprintf
         (
            buf3,
            "$N leans back and dodges $n's %s.",
            attack
         ); */
         break;
      }
      case (5):
      {
         if (monk_dodge)
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You twist and spin horizontally while swimming backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N twists and spins horizontally while swimming backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N twists and spins horizontally while swimming backward and dodges $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You twist and spin horizontally while flying backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N twists and spins horizontally while flying backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N twists and spins horizontally while flying backward and dodges $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You twist and spin horizontally while leaping backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N twists and spins horizontally while leaping backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N twists and spins horizontally while leaping backward and dodges $n's %s.",
                  attack
               );
            }
         }
         else
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You swim backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N swims backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N swims backward and dodges $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You fly backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N flies backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N flies backward and dodges $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You hop backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N hops backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N hops backward and dodges $n's %s.",
                  attack
               );
            }
         }
         break;
      }
      case (6):
      {
         if (monk_dodge)
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You quickly swims backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N quickly swims backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N quickly swims backward and dodges $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You quickly fly backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N quickly flies backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N quickly flies backward and dodges $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You execute a backflip and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N executes a backflip and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N executes a backflip and dodges $n's %s.",
                  attack
               );
            }
         }
         else
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You quickly swim backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N quickly swims backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N quickly swims backward and dodges $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You quickly fly backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N quickly flies backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N quickly flies backward and dodges $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You scramble backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N scrambles backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N scrambles backward and dodges $n's %s.",
                  attack
               );
            }
         }
         break;
      }
      case (7):
      {
         if (monk_dodge)
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You quickly swim to the side and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N quickly swims to the side and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N quickly swims to the side and dodges $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You quickly fly to the side and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N quickly flies to the side and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N quickly flies to the side and dodges $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You execute a jumping backtuck and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N executes a jumping backtuck and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N executes a jumping backtuck and dodges $n's %s.",
                  attack
               );
            }
         }
         else
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You swim backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N swims backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N swims backward and dodges $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You fly backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N flies backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N flies backward and dodges $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You scramble backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N scrambles backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N scrambles backward and dodges $n's %s.",
                  attack
               );
            }
         }
         break;
      }
      case (8):
      {
         if (monk_dodge)
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You swim straight up and tuck your legs in, dodging $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N swims straight up and tucks $S legs in, dodging your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N swims straight up and tucks $S legs in, dodging $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)

            {
               sprintf
               (
                  buf1,
                  "You flies straight up and tuck your legs in, dodging $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N flies straight up and tucks $S legs in, dodging your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N flies straight up and tucks $S legs in, dodging $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You leap straight up and tuck your legs in, dodging $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N leaps straight up and tucks $S legs in, dodging your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N leaps straight up and tucks $S legs in, dodging $n's %s.",
                  attack
               );
            }
         }
         else
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                    ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                    IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               sprintf
               (
                  buf1,
                  "You swim backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N swims backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N swims backward and dodges $n's %s.",
                  attack
               );
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               sprintf
               (
                  buf1,
                  "You fly backward and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N flies backward and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N flies backward and dodges $n's %s.",
                  attack
               );
            }
            else
            {
               sprintf
               (
                  buf1,
                  "You drop, roll backward, and dodge $n's %s.",
                  attack
               );
               sprintf
               (
                  buf2,
                  "$N drops, rolls backward, and dodges your %s.",
                  attack
               );
               sprintf
               (
                  buf3,
                  "$N drops, rolls backward, and dodges $n's %s.",
                  attack
               );
            }
         }
         break;
      }
      default:
      {
         sprintf
         (
            buf1,
            "You dodge $n's %s.",
            attack
         );
         sprintf
         (
            buf2,
            "$N dodges your %s.",
            attack
         );
         sprintf
         (
            buf3,
            "$N dodges $n's %s.",
            attack
         );
         break;
      }
   }
   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_CHAR
   );
   /*
   third person dodge is silent - Fizz
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );
   */
   if
   (
      check_counter_defense(ch, victim)
   )
   {
      switch(number_range(1,3))
      {
         case (1):
         {
            act
            (
               "You counter $N's dodge!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n counters your dodge!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$n counters $N's dodge!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (2):
         {
            act
            (
               "You move to intercept $N and counter $S dodge!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n moves to intercept you and counters your dodge!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$n moves to intercept $N and counters $S dodge!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case (3):
         {
            act
            (
               "You strike $N just as $S begins to dodge your attack!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes you just as you begin to dodge $s attack!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$n strikes $N just as $E begins to dodge $s attack!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         default:
         {
            act
            (
               "You counter $N's dodge!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n counters your dodge!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "$n counters $N's dodge!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
      }
      defense_not_countered = FALSE;
      return FALSE;
   }

   check_improve
   (
      victim,
      gsn_dodge,
      TRUE,
      5
   );
   return TRUE;
}

/*
* Check for void phasing.
*/
bool check_void( CHAR_DATA *ch, CHAR_DATA *victim, int dt )
{
   int chance;
   int tmp_dt;
   OBJ_DATA *wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char *attack;

   if (!is_affected(victim,gsn_void))
   return FALSE;

   if ( !IS_AWAKE(victim) )
   return FALSE;

   chance = 6;

   if ( number_percent( ) >= chance )
   return FALSE;

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   else if (dt == gsn_tertiary_wield)
   wield = get_eq_char(ch,WEAR_TERTIARY_WIELD);
   else
   wield = get_eq_char(ch,WEAR_WIELD);


   if (wield != NULL)
   tmp_dt += wield->value[3];
   else
   tmp_dt += ch->dam_type;


   if (tmp_dt > TYPE_HIT && tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE)
   attack = attack_table[tmp_dt - TYPE_HIT].noun;
   else
   {
      bug("In void phasing, bad dam message: dt %d.",tmp_dt);
      attack = attack_table[0].name;
   }

   sprintf(buf1,"You phase out of existence briefly, and $n's %s misses.",attack);
   sprintf(buf2,"$N phases out of existence briefly, and your %s misses.",attack);
   act(buf1,ch,0,victim,TO_VICT);
   act(buf2,ch,0,victim,TO_CHAR);

   return TRUE;
}

/*
* Check for 'Blur of the Gremlin' - Utara's brand
* Copy of check_void with a few minor changes.
* - Wicket
*/
bool check_utara_brand_blur( CHAR_DATA *ch, CHAR_DATA *victim, int dt )
{
   int chance;
   int tmp_dt;
   OBJ_DATA *wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char *attack;

   if (!is_affected(victim,gsn_utara_brand_blur))
   return FALSE;

   if ( !IS_AWAKE(victim) )
   return FALSE;

   chance = 6;

   if ( number_percent( ) >= chance )
   return FALSE;

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   else if (dt == gsn_tertiary_wield)
   wield = get_eq_char(ch,WEAR_TERTIARY_WIELD);
   else
   wield = get_eq_char(ch,WEAR_WIELD);


   if (wield != NULL)
   tmp_dt += wield->value[3];
   else
   tmp_dt += ch->dam_type;


   if (tmp_dt > TYPE_HIT && tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE)
   attack = attack_table[tmp_dt - TYPE_HIT].noun;
   else
   {
      bug("In Blur of the Gremlin, bad dam message: dt %d.",tmp_dt);
      attack = attack_table[0].name;
   }

   sprintf(buf1,"Your body distorts and $n's %s fades within your blurred presence.",attack);
   sprintf(buf2,"$N's body distorts and your %s fades within $s blurred presence.",attack);
   sprintf(buf3,"$N's body distorts and is lost within a blur of motion.");
   act(buf1,ch,0,victim,TO_VICT);
   act(buf2,ch,0,victim,TO_CHAR);
   act(buf3,ch,0,victim,TO_NOTVICT);

   return TRUE;
}


/*
* Set position of a victim.
*/
void update_pos( CHAR_DATA *victim )
{
   if ( victim->hit > 0 )
   {
      if ( victim->position <= POS_STUNNED )
      {
         victim->on = NULL;
         victim->position = POS_STANDING;
      }
      return;
   }

   if (!IS_NPC(victim) && victim->pcdata->brand_rank > 0)
   {
      OBJ_DATA* brand = get_eq_char(victim, WEAR_BRAND);
      int hp;

      if
      (
         brand != NULL &&
         brand->pIndexData->vnum == OBJ_VNUM_OBLIVION_BRAND
      )
      {
         hp = victim->max_hit * -5 / 100;
         if (victim->hit < hp)
         {
            victim->position = POS_DEAD;
            victim->on = NULL;
         }
         else if (victim->position <= POS_STUNNED)
         {
            victim->on = NULL;
            victim->position = POS_STANDING;
         }
         return;
      }
   }

   if ( IS_NPC(victim) && victim->hit < 1 )
   {
      victim->position = POS_DEAD;
      victim->on = NULL;
      return;
   }

   if ( victim->hit <= -11 )
   {
      victim->position = POS_DEAD;
      victim->on = NULL;
      return;
   }

   if ( victim->hit <= -6 ) victim->position = POS_MORTAL;
   else if ( victim->hit <= -3 ) victim->position = POS_INCAP;
   else                          victim->position = POS_STUNNED;

   return;
}



/*
* Start fights.
*/
void set_fighting(CHAR_DATA* ch, CHAR_DATA* victim)
{
   /* cant fight yourself */
   if
   (
      victim == ch ||
      ch == NULL ||
      victim == NULL ||
      ch->fighting != NULL ||
      ch->in_room == NULL ||
      ch->in_room != victim->in_room
   )
   {
      return;
   }

   affect_strip(ch, gsn_camp);
   affect_strip(ch, gsn_peace);
   affect_strip(victim, gsn_peace);

   ch->fighting = victim;
   ch->position = POS_FIGHTING;
   ch->on = NULL;
   strip_simulacrum(ch, victim, FALSE);
   if
   (
      !IS_NPC(ch) &&
      !IS_IMMORTAL(ch) &&
      !IS_IMMORTAL(victim)
   )
   {
      if
      (
         !IS_NPC(victim) ||
         (
            IS_AFFECTED(victim, AFF_CHARM) &&
            victim->master != ch
         ) ||
         (
            IS_NPC(victim) &&
            victim->house
         )
      )
      {
         QUIT_STATE(ch, 20);
         if (!IS_NPC(victim))
         {
            QUIT_STATE(victim, 20);
         }
      }
   }

   return;
}



/*
* Stop fights.
*/
void stop_fighting( CHAR_DATA *ch, bool fBoth )
{
   CHAR_DATA *fch;

   for ( fch = char_list; fch != NULL; fch = fch->next )
   {
      if ( fch == ch || ( fBoth && fch->fighting == ch ) )
      {
         fch->fighting       = NULL;
         if
         (
            !IS_AFFECTED2(fch, AFF_NAP) ||
            fch->position == POS_FIGHTING
         )
         {
            fch->position =
            (
               IS_NPC(fch) ?
               fch->default_pos :
               POS_STANDING
            );
         }
         update_pos( fch );
      }
   }

   return;
}



/*
* Make a corpse out of a character.
*/
void make_corpse(CHAR_DATA* killer, CHAR_DATA* ch)
{
   char buf[MAX_STRING_LENGTH];
   OBJ_DATA* corpse;
   OBJ_DATA* shard;
   OBJ_DATA* obj;
   OBJ_DATA* obj_next;
   OBJ_DATA* head;
   char* name;
   CHAR_DATA* new_genocide_owner;

   if (!check_room(ch, TRUE, "make corpse, ch->in_room == NULL, ch destroyed"))
   {
      /*
      Makes certain ch->in_room != NULL, if it is,
      and a PC, moves to limbo.  Else destroys char.
      Thus, ch is now invalid.
      */
      return;
   }

   if
   (
      IS_NPC(killer) &&
      IS_AFFECTED(killer, AFF_CHARM) &&
      killer->master &&
      killer->in_room &&
      killer->master->in_room &&
      killer->in_room == killer->master->in_room &&
      killer != ch &&
      killer->master != ch
   )
   {
      new_genocide_owner = killer->master;
   }
   else
   {
      new_genocide_owner = killer;
   }

   /* Neohydra */
   if
   (
      IS_NPC(ch) &&
      ch->pIndexData->vnum == 13724
   )
   {
      act
      (
         "One of $n's massive heads falls decapitated onto the ground.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      if
      (
         (
            head = create_object(get_obj_index(OBJ_VNUM_HYDRA_HEAD), 0)
         ) != NULL
      )
      {
         obj_to_room(head, ch->in_room);
      }
   }

   if
   (
      IS_NPC(ch) &&
      ch->house != 0
   )
   {
      act
      (
         "$n's body crumples up and dissolves into dust.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      for (obj = ch->carrying; obj != NULL; obj = obj_next)
      {
         bool floating = FALSE;

         obj_next = obj->next_content;
         if (obj->wear_loc != WEAR_BRAND)
         {
            obj_from_char(obj);
         }
         if (obj->item_type == ITEM_POTION)
         {
            obj->timer = number_range(500, 1000);
         }
         if (obj->item_type == ITEM_SCROLL)
         {
            obj->timer = number_range(1000, 2500);
         }
         if
         (
            is_affected_obj(obj, gsn_alchemy) &&
            (
               IS_NPC(ch) ||
               ch->pcdata->special != SUBCLASS_ENCHANTER
            )
         )
         {
            if
            (
               killer != ch &&
               (
                  !IS_NPC(killer) ||
                  IS_AFFECTED(killer, AFF_CHARM)
               )
            )
            {
               /* fade it */
               un_pulse(obj);
            }
            else
            {
               /* rot it */
               obj->timer = 12;
            }
         }
         if
         (
            IS_SET(obj->extra_flags, ITEM_ROT_DEATH) &&
            !floating
         )
         {
            if (obj->pIndexData->quitouts == FALSE)
            {
               obj->timer = number_range(5, 10);
            }
            /*
            delayed rot timers for antfolk carapaces
            in antfolk.are - runge
            */
            if
            (
               obj->pIndexData->vnum == 28810 ||  /* black drone */
               obj->pIndexData->vnum == 28811 ||  /* red drone */
               obj->pIndexData->vnum == 28812 ||  /* pale drone */
               obj->pIndexData->vnum == 28813 ||  /* thick red */
               obj->pIndexData->vnum == 28814 ||  /* thick black */
               obj->pIndexData->vnum == 28815 ||  /* thick plain */
               obj->pIndexData->vnum == 28818 ||  /* queen's wings */
               obj->pIndexData->vnum == 28822 ||  /* spiked */
               obj->pIndexData->vnum == 28823     /* queen's carapace */
            )
            {
               obj->timer = 96;
            }
            if
            (
               obj->pIndexData->condition < 0 &&
               obj->pIndexData->quitouts == FALSE
            )
            {
               obj->timer = (-1) * obj->pIndexData->condition;
            }
            REMOVE_BIT(obj->extra_flags, ITEM_ROT_DEATH);
         }
         REMOVE_BIT(obj->extra_flags, ITEM_VIS_DEATH);

         if
         (
            obj->pIndexData->limcount > obj->pIndexData->limtotal &&
            obj->pIndexData->limtotal > 0
         )
         {
            sprintf(log_buf, "%s's [%s] went poof!", ch->name, obj->short_descr);
            wiznet(log_buf, ch, obj, WIZ_ITEMS, WIZ_SECURE, get_trust(ch));
            log_string(log_buf);
            extract_obj(obj, FALSE);
         }
         else if (floating)
         {
            if
            (
               is_affected_obj(obj, gsn_alchemy) &&
               (
                  IS_NPC(ch) ||
                  ch->pcdata->special != SUBCLASS_ENCHANTER
               )
            )
            {
               if
               (
                  killer != ch &&
                  (
                     !IS_NPC(killer) ||
                     IS_AFFECTED(killer, AFF_CHARM)
                  )
               )
               {
                  /* fade it */
                  un_pulse(obj);
               }
               else
               {
                  /* rot it */
                  obj->timer = 12;
               }
            }
            if (IS_OBJ_STAT(obj, ITEM_ROT_DEATH))  /* get rid of it! */
            {
               if (obj->contains != NULL)
               {
                  OBJ_DATA* in;
                  OBJ_DATA* in_next;

                  act
                  (
                     "$p evaporates,scattering its contents.",
                     ch,
                     obj,
                     NULL,
                     TO_ROOM
                  );
                  for (in = obj->contains; in != NULL; in = in_next)
                  {
                     in_next = in->next_content;
                     obj_from_obj(in);
                     obj_to_room(in,ch->in_room);
                  }
               }
               else
               {
                  act("$p evaporates.", ch, obj, NULL, TO_ROOM);
               }
               extract_obj(obj, FALSE);
            }
            else
            {
               act("$p falls to the floor.", ch, obj, NULL, TO_ROOM);
               obj_to_room(obj, ch->in_room);
            }
         }
         else if (obj->wear_loc != WEAR_BRAND)
         {
            act("$p falls to the floor.",ch,obj,NULL,TO_ROOM);
            obj_to_room(obj,ch->in_room);
         }
      }
      return;
   }

   if (IS_NPC(ch))
   {
      name          = ch->short_descr;
      corpse        = create_object(get_obj_index(OBJ_VNUM_CORPSE_NPC), 0);
      corpse->timer = number_range(5, 8);
      free_string(corpse->talked);
      if (IS_NPC(killer))
      {
         corpse->talked = str_dup(killer->short_descr);
      }
      else
      {
         corpse->talked = str_dup(get_longname(killer, NULL));
      }
      if
      (
         ch->gold > 0 ||
         ch->silver > 0
      )
      {
         obj_to_obj(create_money(ch->gold, ch->silver), corpse);
         ch->gold = 0;
         ch->silver = 0;
      }
      corpse->cost = 0;
   }
   else
   {
      name             = get_longname(ch, NULL);
      corpse           = create_object(get_obj_index(OBJ_VNUM_CORPSE_PC), 0);
      corpse->timer    = number_range(20, 35);
      corpse->value[4] = ch->temple;
      free_string(corpse->talked);
      if (IS_NPC(killer))
      {
         corpse->talked = str_dup(killer->short_descr);
      }
      else
      {
         corpse->talked = str_dup(get_longname(killer, NULL));
      }
      free_string(corpse->owner);
      corpse->owner = str_dup(ch->name);
      if
      (
         ch->gold > 0 ||
         ch->silver > 0
      )
      {
         obj_to_obj(create_money(ch->gold, ch->silver), corpse);
         ch->gold = 0;
         ch->silver = 0;
      }
      if
      (
         !IS_IMMORTAL(ch) &&
         ch->house == HOUSE_BRETHREN &&
         !(
            ch->in_room->vnum >= ROOM_VNUM_ABYSS &&
            ch->in_room->vnum <= ROOM_VNUM_ABYSS + 8
         ) &&
         !house_down_1(NULL, HOUSE_CONCLAVE, TRUE)
      )
      {
         OBJ_INDEX_DATA* index;

         shard = NULL;
         if
         (
            (
               index = get_obj_index(OBJ_VNUM_BRETHREN)
            ) != NULL &&
            index->in_game_count > 0
         )
         {
            for (shard = object_list; shard != NULL; shard = shard->next)
            {
               if (shard->pIndexData->vnum == OBJ_VNUM_BRETHREN)
               {
                  break;
               }
            }
         }
         if
         (
            index &&
            shard == NULL
         )
         {
            shard = create_object(index, 0);
            act
            (
               "$n's blood begins to coalesce into $p.",
               ch,
               shard,
               NULL,
               TO_ROOM
            );
            act
            (
               "Your blood begins to coalesce into $p.",
               ch,
               shard,
               NULL,
               TO_CHAR
            );
            obj_to_obj(shard, corpse);
            house_shudder(HOUSE_BRETHREN);
         }
      }
      corpse->cost = 0;
   }
   corpse->level = ch->level;
   if
   (
      IS_SET(ch->act, ACT_UNDEAD) ||
      IS_SET(ch->form, FORM_UNDEAD)
   )
   SET_BIT(corpse->extra_flags, CORPSE_NO_ANIMATE);

   sprintf(buf, corpse->short_descr, name);
   free_string(corpse->short_descr);
   corpse->short_descr = str_dup(buf);
   sprintf(buf, "%s %ld", corpse->name, ch->id);
   free_string(corpse->name);
   corpse->name = str_dup(buf);
   /*
   *  If a criminal's head will be used on a pike,
   *  their corpse must be headless. - Wicket
   */
   if
   (
      killer->house == HOUSE_COVENANT &&
      (
         !IS_IMMORTAL(killer) ||
         can_see(ch, killer)
      )
   )
   {
      sprintf(buf, "the headless corpse of %s", name);
      free_string(corpse->short_descr);
      corpse->short_descr = str_dup(buf);
      sprintf(buf, "The headless corpse of %s is lying here.", name);
      free_string(corpse->description);
      corpse->description = str_dup(buf);
   }
   else
   {
      sprintf(buf, corpse->description, name);
      free_string(corpse->description);
      corpse->description = str_dup(buf);
   }

   for (obj = ch->carrying; obj != NULL; obj = obj_next)
   {
      bool floating = FALSE;

      obj_next = obj->next_content;
      if (obj->pIndexData->vnum == OBJ_VNUM_PHYLACTERY)
      {
         obj_from_char(obj);
         obj_to_room(obj, ch->in_room);
         continue;
      }
      if
      (
         obj->pIndexData->vnum == OBJ_VNUM_GENOCIDE_AXE &&
         new_genocide_owner != NULL &&
         new_genocide_owner != ch &&
         !IS_NPC(new_genocide_owner)
      )
      {
         obj_from_char(obj);
         ch->alignment = ch->true_alignment;
         obj_to_char(obj, new_genocide_owner);
         make_note
         (
            "Genocide Axe",
            "Genocide Owner",
            "Darkwood",
            new_genocide_owner->name,
            NOTE_NOTE
         );
         act_color
         (
            "$p tells you '{B{2I am yours now; wear me, Master!{n'",
            new_genocide_owner,
            obj,
            NULL,
            TO_CHAR
         );
      }
      if
      (
         obj != NULL &&
         !IS_IMMORTAL(ch) &&
         obj->pIndexData->vnum == OBJ_VNUM_DEATH_REVENGE
      )
      {
         ch->perm_stat[STAT_CON] -= 1;
         send_to_char
         (
            "With this death you feel part of your life force slip away.\n\r",
            ch
         );
      }

      if
      (
         !(
            obj->wear_loc == WEAR_BRAND ||
            (
               IS_SET(obj->wear_flags, ITEM_KEEP) &&
               !IS_NPC(ch)
            )
         )
      )
      {
         obj_from_char(obj);
      }
      if (obj->item_type == ITEM_POTION)
      {
         obj->timer = number_range(500, 1000);
      }
      if (obj->item_type == ITEM_SCROLL)
      {
         obj->timer = number_range(1000, 2500);
      }
      if (obj->pIndexData->vnum == OBJ_VNUM_HYDRA_SLAYER)
      {
         obj->timer = number_range(500, 1500);
      }
      else if (obj->pIndexData->vnum == OBJ_VNUM_HYDRA_HEAD)
      {
         obj->timer = number_range(300, 900);
      }

      if
      (
         is_affected_obj(obj, gsn_alchemy) &&
         (
            IS_NPC(ch) ||
            ch->pcdata->special != SUBCLASS_ENCHANTER
         )
      )
      {
         if
         (
            killer != ch &&
            (
               !IS_NPC(killer) ||
               IS_AFFECTED(killer, AFF_CHARM)
            )
         )
         {
            /* fade it */
            un_pulse(obj);
         }
         else
         {
            /* rot it */
            obj->timer = 12;
         }
      }
      if (IS_SET(obj->extra_flags, ITEM_ROT_DEATH) && !floating)
      {
         if (obj->pIndexData->quitouts == FALSE)
         {
            obj->timer = number_range(5, 10);
         }
         /*
         delayed rot timers for antfolk carapaces
         in antfolk.are - runge
         */
         if
         (
            obj->pIndexData->vnum == 28810 ||  /* black drone */
            obj->pIndexData->vnum == 28811 ||  /* red drone */
            obj->pIndexData->vnum == 28812 ||  /* pale drone */
            obj->pIndexData->vnum == 28813 ||  /* thick red */
            obj->pIndexData->vnum == 28814 ||  /* thick black */
            obj->pIndexData->vnum == 28815 ||  /* thick plain */
            obj->pIndexData->vnum == 28818 ||  /* queen's wings */
            obj->pIndexData->vnum == 28822 ||  /* spiked */
            obj->pIndexData->vnum == 28823     /* queen's carapace */
         )
         {
            obj->timer = 96;
         }
         if
         (
            obj->pIndexData->condition < 0 &&
            obj->pIndexData->quitouts == FALSE
         )
         {
            obj->timer = (-1) * obj->pIndexData->condition;
         }

         if
         (
            obj->pIndexData->condition < 0 &&
            obj->pIndexData->quitouts == FALSE
         )
         {
            obj->timer = (-1) * obj->pIndexData->condition;
         }
         REMOVE_BIT(obj->extra_flags, ITEM_ROT_DEATH);
      }
      REMOVE_BIT(obj->extra_flags, ITEM_VIS_DEATH);

      if
      (
         obj->pIndexData->limcount > obj->pIndexData->limtotal &&
         obj->pIndexData->limtotal > 0
      )
      {
         sprintf(log_buf, "%s's [%s] went poof!", ch->name, obj->short_descr);
         wiznet(log_buf, ch, obj, WIZ_ITEMS, WIZ_SECURE, get_trust(ch));
         log_string(log_buf);
         extract_obj(obj, FALSE);
      }
      else if (floating)
      {
         if
         (
            is_affected_obj(obj, gsn_alchemy) &&
            (
               IS_NPC(ch) ||
               ch->pcdata->special != SUBCLASS_ENCHANTER
            )
         )
         {
            if
            (
               killer != ch &&
               (
                  !IS_NPC(killer) ||
                  IS_AFFECTED(killer, AFF_CHARM)
               )
            )
            {
               /* fade it */
               un_pulse(obj);
            }
            else
            {
               /* rot it */
               obj->timer = 12;
            }
         }
         if (IS_OBJ_STAT(obj, ITEM_ROT_DEATH))  /* get rid of it! */
         {
            if (obj->contains != NULL)
            {
               OBJ_DATA* in;
               OBJ_DATA* in_next;

               act
               (
                  "$p evaporates, scattering its contents.",
                  ch,
                  obj,
                  NULL,
                  TO_ROOM
               );
               for (in = obj->contains; in != NULL; in = in_next)
               {
                  in_next = in->next_content;
                  obj_from_obj(in);
                  obj_to_room(in, ch->in_room);
               }
            }
            else
            act("$p evaporates.", ch, obj, NULL, TO_ROOM);
            extract_obj(obj, FALSE);
         }
         else
         {
            act("$p falls to the floor.", ch, obj, NULL, TO_ROOM);
            obj_to_room(obj, ch->in_room);
         }
      }
      else if
      (
         !(
            obj->wear_loc == WEAR_BRAND ||
            (
               IS_SET(obj->wear_flags, ITEM_KEEP) &&
               !IS_NPC(ch)
            )
         )
      )
      {
         obj_to_obj(obj, corpse);
      }
   }
   obj_to_room(corpse, ch->in_room);
   return;
}



/*
* Improved Death_cry contributed by Diavolo.
*/
void death_cry( CHAR_DATA *ch )
{
   ROOM_INDEX_DATA *was_in_room;
   char *msg;
   int door;
   int vnum;

   vnum = 0;
   msg = "You hear $n's death cry.";

   switch ( number_bits(4))
   {
      case  0: msg  = "$n hits the ground ... DEAD.";                     break;
      case  1:
      if (ch->material == 0)
      {
         msg  = "$n splatters blood on your armor.";
         break;
      }
      case  2:
      if (IS_SET(ch->parts,PART_GUTS))
      {
         msg = "$n spills $s guts all over the floor.";
         vnum = OBJ_VNUM_GUTS;
      }
      break;
      case  3:
      /*
      *  Temporary fix to prevent a rebel from losing their head. We can't "pike"
      *  their heads if they are also on the ground. I will change this once I
      *  figure out a better way to do this... - Wicket
      */
      if (IS_SET(ch->parts,PART_HEAD) && !IS_SET(ch->act,PLR_CRIMINAL))
      {
         msg  = "$n's severed head plops on the ground.";
         vnum = OBJ_VNUM_SEVERED_HEAD;
      }
      break;
      case  4:
      if (IS_SET(ch->parts,PART_HEART))
      {
         msg  = "$n's heart is torn from $s chest.";
         vnum = OBJ_VNUM_TORN_HEART;
      }
      break;
      case  5:
      if (IS_SET(ch->parts,PART_ARMS))
      {
         msg  = "$n's arm is sliced from $s dead body.";
         vnum = OBJ_VNUM_SLICED_ARM;
      }
      break;
      case  6:
      if (IS_SET(ch->parts,PART_LEGS))
      {
         msg  = "$n's leg is sliced from $s dead body.";
         vnum = OBJ_VNUM_SLICED_LEG;
      }
      break;
      case 7:
      /* Please see above comment regarding "OBJ_VNUM_SEVERED_HEAD" - Wicket */
      if (IS_SET(ch->parts,PART_BRAINS) /* && !IS_SET(ch->act,PLR_REBEL) */)
      {
         msg = "$n's head is shattered, and $s brains splash all over you.";
         vnum = OBJ_VNUM_BRAINS;
      }
   }

   act( msg, ch, NULL, NULL, TO_ROOM );

   if ( vnum != 0 )
   {
      char buf[MAX_STRING_LENGTH];
      OBJ_DATA *obj;
      char *name;

      name            = IS_NPC(ch) ? ch->short_descr : /* ch->name */ get_longname(ch,NULL);
      obj             = create_object( get_obj_index( vnum ), 0 );
      obj->timer      = number_range( 4, 7 );

      sprintf( buf, obj->short_descr, name );
      free_string( obj->short_descr );
      obj->short_descr = str_dup( buf );

      sprintf( buf, obj->description, name );
      free_string( obj->description );
      obj->description = str_dup( buf );

      if (obj->item_type == ITEM_FOOD)
      {
         if (IS_SET(ch->form,FORM_POISON))
         obj->value[3] = 1;
         else if (!IS_SET(ch->form,FORM_EDIBLE))
         obj->item_type = ITEM_TRASH;
      }

      obj_to_room( obj, ch->in_room );
   }

   if ( IS_NPC(ch) )
   msg = "You hear something's death cry.";
   else
   msg = "You hear someone's death cry.";

   was_in_room = ch->in_room;
   for ( door = 0; door <= 5; door++ )
   {
      EXIT_DATA *pexit;

      if ( ( pexit = was_in_room->exit[door] ) != NULL
      &&   pexit->u1.to_room != NULL
      &&   pexit->u1.to_room != was_in_room )
      {
         char_from_room(ch);
         char_to_room_1(ch, pexit->u1.to_room, TO_ROOM_AT);
         act( msg, ch, NULL, NULL, TO_ROOM );
      }
   }
   char_from_room(ch);
   char_to_room_1(ch, was_in_room, TO_ROOM_AT);

   return;
}


bool can_instakill(CHAR_DATA *ch, CHAR_DATA *victim)
{
   if ( IS_NPC(victim) && victim->pIndexData->pShop != NULL && !IS_IMMORTAL(ch))
   return FALSE;

   return TRUE;
}


void raw_kill( CHAR_DATA *ch,CHAR_DATA *victim )
{
   char buf[MAX_STRING_LENGTH];
   /*    char strsave[MAX_INPUT_LENGTH]; */
   CHAR_DATA *dch, *gch, *gch_next, *shadow;
   OBJ_DATA *obj, *carriedobj;
   ROOM_INDEX_DATA *location, *pRoomIndex;
   AFFECT_DATA* paf;
   int i;
   int carrynum;
   int rotd_flag = 0;
   char* scalp_name;
   MESSAGE * hung_message;
   int temp_quit;

   if (IS_NPC(victim))
   {
      if (victim->ghost)
      {
         /* No looping of dead npcs (i.e. mobprogs) */
         return;
      }
      victim->ghost = 1;  /* no multi-raw kills */
   }
   if
   (
      IS_NPC(victim) &&
      victim->pIndexData->pShop
   )
   {
      stash_valuables(victim);
   }
   if ( (hung_message = get_message_char(victim, MM_HANG1)) != NULL)
   {
      message_remove(hung_message);
   }
   if ( (hung_message = get_message_char(victim, MM_HANG2)) != NULL)
   {
      message_remove(hung_message);
   }
   if ( (hung_message = get_message_char(victim, MM_HANG3)) != NULL)
   {
      message_remove(hung_message);
   }
   if ( (hung_message = get_message_char(victim, MM_HANG4)) != NULL)
   {
      message_remove(hung_message);
   }
   /* No more hang */
   REMOVE_BIT(ch->affected_by2, AFF_HANG);

   if (victim->race != grn_arborian)
   {
      scalp_name = "scalp";
   }
   else
   {
      scalp_name = "root";
   }
   if
   (
      !IS_NPC(victim) &&
      (
         victim->pcdata->wanteds < 3 ||
         IS_SET(victim->act, PLR_CRIMINAL) ||
         IS_SET(victim->act2, PLR_LAWLESS)
      )
   )
   {
      for (gch = ch->in_room->people; gch; gch = gch->next_in_room)
      {
         if
         (
            IS_NPC(gch) ||
            gch->house != HOUSE_ENFORCER ||
            !is_same_group(gch, ch) ||
            victim == ch
         )
         {
            continue;
         }
         if
         (
            IS_SET(victim->act, PLR_CRIMINAL) ||
            IS_SET(victim->act2, PLR_LAWLESS)
         )
         {
            gch->pcdata->targetkills += 10;
         }
         else if (victim->pcdata->wanteds < 3)
         {
            gch->pcdata->targetkills -= gch->pcdata->targetkills / 3;
         }
      }
   }

   if (!IS_NPC(victim) && victim->pcdata->called_by)
   {
      CHAR_DATA* killer = ch;

      if
      (
         IS_NPC(ch) &&
         IS_AFFECTED(ch, AFF_CHARM) &&
         ch->master
      )
      {
         /* If it was a charmie, use the master */
         killer = ch->master;
      }
      if (killer->house == HOUSE_CRUSADER)
      {
         /* Autorelease */
         if (killer == victim->pcdata->called_by)
         {
            /* Person who called them killed them. */
            sprintf
            (
               buf,
               "{B{3%s has killed and released %s.{n",
               killer->name,
               victim->name
            );
         }
         else
         {
            if (IS_NPC(killer))
            {
               sprintf
               (
                  buf,
                  "{B{3%s has killed %s.{n",
                  killer->short_descr,
                  victim->name
               );
            }
            else
            {
               sprintf
               (
                  buf,
                  "{B{3%s has killed %s.{n",
                  killer->name,
                  victim->name
               );
            }
         }
         do_hecho(killer, buf);
         victim->pcdata->called_by = NULL;
      }
   }

   /* Death damage for Malistien's brand */
   if ( (obj = get_eq_char(victim,WEAR_BRAND)) != NULL
   && (obj->pIndexData->vnum == 17641)
   && victim != ch && ch != NULL )
   {
      send_to_char("You hear the screams of the justly!\n\r",ch);
      damage(ch,ch,250,gsn_justice_brand_wrath,DAM_OTHER,TRUE);
   }

   /* Brethren wimpy demon explosion on death */
   if (demonai_match(victim,DEMON_WIMP))
   {
      OBJ_DATA *obj;
      char *name;
      int cnt;
      act("$n explodes into a dozen fiery pieces.",victim,0,0,TO_ROOM);
      damage(ch,ch,victim->level*4,gsn_breath_fire,DAM_FIRE,DEMON_WIMP_DAM_TYPE);
      for (cnt = 1; cnt <= 6; cnt++)
      {
         name            = IS_NPC(victim) ? victim->short_descr : get_longname(victim,NULL);
         obj             = create_object( get_obj_index( OBJ_VNUM_GUTS ), 0 );
         obj->timer      = number_range( 4, 7 );
         obj->value[3]   = 1;
         sprintf( buf, obj->short_descr, name );
         free_string( obj->short_descr );
         obj->short_descr = str_dup( buf );
         sprintf( buf, obj->description, name );
         free_string( obj->description );
         obj->description = str_dup( buf );
         obj_to_room( obj, ch->in_room );
      }
   }

   /* count how many times a housed char dies */
   if
   (
      !IS_NPC(victim) &&
      !IS_IMMORTAL(victim) &&
      !IS_IMMORTAL(ch)
   )
   {
      if (!IS_NPC(ch))
      {
         if
         (
            ch->house ||
            victim->house
         )
         {
            if (ch->house == 0)
            {
               /* victim->house not 0 */
               house_kills[victim->house]++;
               unhoused_kills[victim->house]++;
            }
            else if (victim->house == 0)
            {
               unhoused_pk[ch->house]++;
               if (victim->pcdata->last_death < morale_reset_time)
               {
                  unique_kills[ch->house]++;
               }
               house_pks[ch->house]++;
            }
            else
            {
               house_kills[victim->house]++;
               if (victim->pcdata->last_death < morale_reset_time)
               {
                  unique_kills[ch->house]++;
               }
               house_pks[ch->house]++;
            }
            save_globals();
         }
         victim->pcdata->last_death = current_time;
      }
      else
      {
         if
         (
            IS_AFFECTED(ch, AFF_CHARM) &&
            ch->master &&
            !IS_NPC(ch->master)
         )
         {
            /* charmie */
            if
            (
               ch->master->house ||
               victim->house
            )
            {
               if (ch->master->house == 0)
               {
                  /* victim->house not 0 */
                  house_kills[victim->house]++;
                  unhoused_kills[victim->house]++;
               }
               else if (victim->house == 0)
               {
                  unhoused_pk[ch->master->house]++;
                  if (victim->pcdata->last_death < morale_reset_time)
                  {
                     unique_kills[ch->master->house]++;
                  }
                  house_pks[ch->master->house]++;
               }
               else
               {
                  house_kills[victim->house]++;
                  if (victim->pcdata->last_death < morale_reset_time)
                  {
                     unique_kills[ch->master->house]++;
                  }
                  house_pks[ch->master->house]++;
               }
               save_globals();
            }
            victim->pcdata->last_death = current_time;
         }
         else if (ch->house)
         {
            /* house guardian */
            if (victim->house == 0)
            {
               unhoused_pk[ch->house]++;
               if (victim->pcdata->last_death < morale_reset_time)
               {
                  unique_kills[ch->house]++;
               }
               house_pks[ch->house]++;
            }
            else
            {
               house_kills[victim->house]++;
               if (victim->pcdata->last_death < morale_reset_time)
               {
                  unique_kills[ch->house]++;
               }
               house_pks[ch->house]++;
            }
            victim->pcdata->last_death = current_time;
            save_globals();
         }
      }
   }

   group_gain( ch, victim );

   if ( !IS_NPC(victim) )
   {
      /* remove riding flag -wervdon */
      if( victim->is_riding )
      do_dismount(victim,NULL);

      /* no escaping 1212 by killing self anymore -wervdon */
      if (victim != NULL && victim->in_room != NULL)
      if (IS_SET(victim->in_room->extra_room_flags, ROOM_1212))
      rotd_flag = victim->in_room->vnum;

      /* lag to people who die at their pit and are wanted to avoid suicides*/
      if ( IS_SET(victim->act, PLR_CRIMINAL) &&
      victim->in_room->vnum == victim->temple )
      WAIT_STATE(victim, 60);

      if
      (
         IS_AFFECTED(ch, AFF_CHARM) &&
         ch->master &&
         !IS_NPC(ch->master)
      )
      {
         sprintf
         (
            log_buf,
            "%s killed by (%s's) %s at %d",
            victim->name,
            ch->master->name,
            (
               IS_NPC(ch) ?
               ch->short_descr :
               ch->name
            ),
            ch->in_room->vnum
         );
      }
      else
      {
         sprintf
         (
            log_buf,
            "%s killed by %s at %d",
            victim->name,
            (
               IS_NPC(ch) ?
               ch->short_descr :
               ch->name
            ),
            ch->in_room->vnum
         );
      }
      log_string(log_buf);

      if (IS_NPC(ch) && ch->master != NULL && !IS_NPC(ch->master))
      {
         sprintf(log_buf,  "%s owned by %s",ch->short_descr,ch->master->name );
         log_string( log_buf );
         if (ch->master->house == HOUSE_ANCIENT && !IS_IMMORTAL(ch->master))
         {
            if (!((IS_SET(victim->act2,PLR_ANCIENT_MARK)
            || IS_SET(victim->act2,PLR_ANCIENT_MARK_PERM))
            && (ch->master->pcdata->target == victim)))
            {
               sprintf(log_buf,  "Untargetted kill by Ancient.");
               log_string( log_buf );
               /*                  if ( !IS_SET(victim->act2,PLR_ANCIENT_MARK)
               && !IS_SET(victim->act2,PLR_ANCIENT_MARK_PERM) )
               ch->master->pcdata->targetkills--; */
               send_to_char("Oops. An untargetted kill.\n\r",ch->master);
               auto_mark_note(ch->master,victim,"was killed but not targetted by");
               if (IS_SET(victim->act2,PLR_ANCIENT_MARK))
               REMOVE_BIT(victim->act2,PLR_ANCIENT_MARK);
               victim->pcdata->mark_price = 0;
               victim->pcdata->mark_accepted = FALSE;
               bounty_note(victim);
            }
            else
            {
               OBJ_DATA *scalp;
               CHAR_DATA *tch;

               for (tch = char_list; tch != NULL; tch = tch->next)
               if (!IS_NPC(tch))
               {
                  if (!IS_NPC(tch) && tch->pcdata->target == ch)
                  {
                     tch->pcdata->target = NULL;
                     if (is_affected(tch,gsn_target)) affect_strip(tch,gsn_target);
                     send_to_char("The mark has been terminated. You stop targetting.\n\r",tch);
                  }
               }

               ch->master->pcdata->targetkills +=award_standing(victim);

               if (IS_SET(victim->act2,PLR_ANCIENT_MARK))
               REMOVE_BIT(victim->act2,PLR_ANCIENT_MARK);
               house_account[HOUSE_ANCIENT] +=victim->pcdata->mark_price;
               save_globals();
               bounty_note(victim);
               if (IS_SET(victim->act2,PLR_ANCIENT_MARK))
               REMOVE_BIT(victim->act2,PLR_ANCIENT_MARK);
               victim->pcdata->mark_price = 0;
               victim->pcdata->mark_accepted = FALSE;

               send_to_char("Assignment complete. The mark is terminated.\n\r",ch->master);
               auto_mark_note(ch->master,victim,"was assassinated by");
               if (is_affected(ch->master,gsn_cloak_form))
               act
               (
                  "$n violently carves off $N's $t!",
                  ch->master,
                  scalp_name,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You violently carve off $N's $t!",
                  ch->master,
                  scalp_name,
                  victim,
                  TO_CHAR
               );
               scalp = create_object(get_obj_index(OBJ_VNUM_SCALP),0);
               scalp->level = victim->level;
               sprintf
               (
                  buf,
                  "the bloody %s of %s",
                  scalp_name,
                  get_longname(victim, NULL)
               );
               free_string(scalp->short_descr);
               scalp->short_descr = str_dup(buf);
               sprintf
               (
                  buf,
                  "The bloody %s of %s curls on the ground.",
                  scalp_name,
                  get_longname(victim, NULL)
               );
               free_string(scalp->description);
               scalp->description = str_dup(buf);
               sprintf(buf,"%s",ch->master->name);
               free_string(scalp->owner);
               scalp->owner = str_dup(buf);
               free_string(scalp->name);
               scalp->name = str_dup(scalp_name);
               obj_to_char(scalp,ch->master);
            }
         }
      }
      else
      {
         if (!IS_NPC(ch) && (ch->house == HOUSE_ANCIENT) && !IS_IMMORTAL(ch))
         {
            if (!((IS_SET(victim->act2,PLR_ANCIENT_MARK)
            || IS_SET(victim->act2,PLR_ANCIENT_MARK_PERM))
            && (ch->pcdata->target == victim)))
            {
               sprintf(log_buf,  "Untargetted kill by Ancient.");
               log_string( log_buf );
               /*                  if ( !IS_SET(victim->act2,PLR_ANCIENT_MARK)
               && !IS_SET(victim->act2,PLR_ANCIENT_MARK_PERM) )
               ch->pcdata->targetkills--; */
               send_to_char("Oops. An untargetted kill.\n\r",ch);
               auto_mark_note(ch,victim,"was killed but not targetted by");
               if (IS_SET(victim->act2,PLR_ANCIENT_MARK))
               REMOVE_BIT(victim->act2,PLR_ANCIENT_MARK);
               victim->pcdata->mark_price = 0;
               victim->pcdata->mark_accepted = FALSE;
               bounty_note(victim);
            }
            else
            {
               OBJ_DATA *scalp;
               CHAR_DATA *tch;

               for (tch = char_list; tch != NULL; tch = tch->next)
               if (!IS_NPC(tch))
               {
                  if (!IS_NPC(tch) && tch->pcdata->target == ch)
                  {
                     tch->pcdata->target = NULL;
                     if (is_affected(tch,gsn_target)) affect_strip(tch,gsn_target);
                     send_to_char("The mark has been terminated. You stop targetting.\n\r",tch);
                  }
               }
               ch->pcdata->targetkills += award_standing(victim);

               if (IS_SET(victim->act2,PLR_ANCIENT_MARK))
               REMOVE_BIT(victim->act2,PLR_ANCIENT_MARK);
               house_account[HOUSE_ANCIENT] +=victim->pcdata->mark_price;
               save_globals();
               bounty_note(victim);
               victim->pcdata->mark_price = 0;
               victim->pcdata->mark_accepted = FALSE;

               send_to_char("Assignment complete. The mark is terminated.\n\r",ch);
               auto_mark_note(ch,victim,"was assassinated by");
               if (is_affected(ch,gsn_cloak_form))
               act
               (
                  "$n violently carves off $N's $t!",
                  ch,
                  scalp_name,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You violently carve off $N's $t!",
                  ch,
                  scalp_name,
                  victim,
                  TO_CHAR
               );
               scalp = create_object(get_obj_index(OBJ_VNUM_SCALP),0);
               scalp->level = victim->level;
               sprintf
               (
                  buf,
                  "the bloody %s of %s",
                  scalp_name,
                  get_longname(victim, NULL)
               );
               free_string(scalp->short_descr);
               scalp->short_descr = str_dup(buf);
               sprintf
               (
                  buf,
                  "The bloody %s of %s curls on the ground.",
                  scalp_name,
                  get_longname(victim, NULL)
               );
               free_string(scalp->description);
               scalp->description = str_dup(buf);
               sprintf(buf,"%s",ch->name);
               free_string(scalp->owner);
               scalp->owner = str_dup(buf);
               free_string(scalp->name);
               scalp->name = str_dup(scalp_name);
               obj_to_char(scalp,ch);
            }
         }
      }

      /* Death Penalty */
      if (IS_NPC(ch) && !IS_AFFECTED(ch, AFF_CHARM))
      victim->exp = UMIN(victim->exp,
      UMAX(victim->exp - (exp_per_level(victim) * .5),
      victim->exp_total - exp_per_level(victim)));
   }

   /* WIZNET: Display Deaths */
   sprintf(log_buf,  "%s got toasted by %s at %s [room %d]",
   (IS_NPC(victim) ? victim->short_descr : victim->name),
   (IS_NPC(ch) ? ch->short_descr : ch->name),
   ch->in_room->name, ch->in_room->vnum);
   if (IS_NPC(victim))
   wiznet(log_buf,NULL,NULL,WIZ_MOBDEATHS,0,0);
   else
   wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);

   /* WIZNET: Display criminal deaths if victim was almost naked */
   if (!IS_NPC(victim) && IS_SET(victim->act,PLR_CRIMINAL) )
   {
      carrynum = 0;
      for ( carriedobj = victim->carrying; carriedobj != NULL; carriedobj = carriedobj->next_content )
      if ( carriedobj->wear_loc != WEAR_NONE ) carrynum++;
      if (carrynum <= 5)
      {
         sprintf(buf,"%s died as a near-naked criminal.", victim->name);
         wiznet(buf,NULL,NULL,WIZ_DEATHS,0,0);
      }
   }

   /* if a ridden mob dies, the owner loses it -wervdon */
   if( IS_NPC(victim) )
   {
      for( gch=char_list;gch != NULL;gch = gch_next )
      {
         gch_next = gch->next;
         if( !IS_NPC(gch)
         && gch->is_riding
         && gch->is_riding->mount_type == MOUNT_MOBILE
         && (CHAR_DATA *)gch->is_riding->mount == victim )
         do_dismount(gch,NULL);
      }
   }

   /* Mobprog Death Trigger */
   if ( IS_NPC( victim ) && HAS_TRIGGER( victim, TRIG_DEATH) )
   {
      victim->position = POS_STANDING;
      victim->on = NULL;
      mp_percent_trigger( victim, ch, NULL, NULL, TRIG_DEATH );
   }

   stop_fighting( victim, TRUE );

   check_basilica_weapon_decay(victim);

   if (IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_DECOY)
   {
      death_cry(victim);
      act("$n vanishes in a poof of smoke!",victim,0,0,TO_ROOM);
   }
   else
   {
      death_cry( victim );

      /*
      *  When a wanted char dies to a member of the Empire, their head
      *  will be impaled upon an obsidian pike for all to see. - Wicket
      */
      if ( !IS_NPC(ch) && ch->house == HOUSE_EMPIRE && IS_SET(victim->act,PLR_CRIMINAL) )
      {
         char buf[MAX_STRING_LENGTH];
         OBJ_DATA *pike;
         char *name;
         name = IS_NPC(victim) ? victim->short_descr : get_longname(victim,NULL);
         pike = create_object( get_obj_index( OBJ_VNUM_EMPIRE_CRIM_PIKE ), 0 );

         sprintf( buf, pike->description, name );
         free_string( pike->description );
         pike->description = str_dup( buf );
         pike->timer       = number_range(18,30);

         act("You sever $N's head, impale it upon an obsidian pike, and strike it firmly into the ground.",
         ch,0,victim,TO_CHAR);
         act("$n severs $N's head, impales it upon an obsidian pike, and strikes it firmly into the ground!",
         ch,0,victim,TO_NOTVICT);

         obj_to_room( pike, ch->in_room );
      }

      /* Immortal Deaths */

      if (!IS_NPC(victim) && IS_IMMORTAL(victim))
      {
         if (victim->pcdata->imm_death)
         {
            act("$t.",victim,NULL,NULL,TO_ROOM);
            act("$t.",victim,NULL,NULL,TO_CHAR);
         }
         else
         {
            act("$n's skull glows brightly and $n rises from $s ashes!",victim,0,0,TO_ROOM);
            send_to_char("Your skull glows brightly and you rise from your ashes!\n\r",victim);
         }
         victim->hit      = victim->pcdata->perm_hit;
         victim->mana     = victim->pcdata->perm_mana;
         victim->move     = victim->pcdata->perm_move;
         victim->position = POS_STANDING;
         victim->on       = NULL;
         return;
      }

      /*
         -10 quittime means you do not drop weapons
         from strength loss (IMPORTANT)
         Otherwise we drop the weapon, and then put it in the corpse
         Definate memory corruption.
      */
      temp_quit = victim->quittime;
      victim->quittime = -10;
      make_corpse( ch,victim );
      victim->quittime = temp_quit;
      victim->noregen_dam = 0;
   }

   /* Remove all mobs from the victim's group */
   for (gch = char_list; gch != NULL; gch = gch_next)
   {
      gch_next = gch->next;
      if (IS_NPC(gch) && gch->master == victim)
      extract_char(gch,TRUE);
   }

   /* Create the shadow for the nightwalker spell 'nightfall' */
   if ( victim->nightfall != NULL )
   {
      if ( victim->nightfall->in_room == victim->in_room )
      {
         act("$n's soul is torn from its body and formed into a shadow!",victim,0,0,TO_ROOM);
         act("$n rips your soul away and forms a shadow!",victim->nightfall,0,victim,TO_VICT);
         shadow = create_mobile(get_mob_index(MOB_VNUM_NIGHTFALL));
         char_to_room(shadow,victim->in_room);
         free_string(shadow->short_descr);
         free_string(shadow->long_descr);
         sprintf(buf,"the shadow of %s",
         IS_NPC(victim) ? victim->short_descr : get_longname(victim,NULL));
         shadow->short_descr = str_dup(buf);
         sprintf(buf,"The shadow of %s is hovering here in silence.\n\r",
         IS_NPC(victim) ? victim->short_descr : get_longname(victim,NULL));
         shadow->long_descr = str_dup(buf);

         shadow->max_hit  = victim->max_hit;
         shadow->hit      = victim->max_hit;
         shadow->damroll  = victim->level/2;
         shadow->hitroll  = victim->level/3;
         shadow->level    = victim->level;
         shadow->armor[0] = -victim->level*4;
         shadow->armor[1] = -victim->level*4;
         shadow->armor[2] = -victim->level*4;
         shadow->armor[3] = -victim->level*3;
         SET_BIT(shadow->comm,COMM_QUIET);
         SET_BIT(shadow->affected_by,AFF_CHARM);
         shadow->leader   = victim->nightfall;
         shadow->master   = victim->nightfall;

         act("You grasp onto $n's soul for you own uses!",victim,0,victim->nightfall,TO_VICT);
      }
      else
      act("Your grasp on $n's soul fades away.",victim,0,victim->nightfall,TO_VICT);

      victim->nightfall = NULL;
   }

   if ( IS_NPC(victim) )
   {
      victim->pIndexData->killed++;
      kill_table[URANGE(0, victim->level, MAX_LEVEL-1)].killed++;
      if (victim->race == grn_doppelganger)
      {
         int total;
         AREA_DATA* parea;
         int count;
         int choice;

         extract_char( victim, TRUE);
         total = 0;
         for (parea = area_first; parea; parea = parea->next)
         {
            for
            (
               pRoomIndex = parea->rooms;
               pRoomIndex;
               pRoomIndex = pRoomIndex->next_in_area
            )
            {
               if
               (
                  !IS_SET(pRoomIndex->extra_room_flags, ROOM_1212) &&
                  pRoomIndex->guild == 0 &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_PRIVATE) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_SOLITARY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_SAFE) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_IMP_ONLY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_GODS_ONLY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_NEWBIES_ONLY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_LOW_ONLY) &&
                  pRoomIndex->people != NULL &&
                  IS_NPC(pRoomIndex->people)
               )
               {
                  total++;
               }
            }
         }
         choice = number_range(1, total);
         count = 0;
         pRoomIndex = NULL;
         for (parea = area_first; parea; parea = parea->next)
         {
            for
            (
               pRoomIndex = parea->rooms;
               pRoomIndex;
               pRoomIndex = pRoomIndex->next_in_area
            )
            {
               if
               (
                  !IS_SET(pRoomIndex->extra_room_flags, ROOM_1212) &&
                  pRoomIndex->guild == 0 &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_PRIVATE) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_SOLITARY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_SAFE) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_IMP_ONLY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_GODS_ONLY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_NEWBIES_ONLY) &&
                  !IS_SET(pRoomIndex->room_flags, ROOM_LOW_ONLY) &&
                  pRoomIndex->people != NULL &&
                  IS_NPC(pRoomIndex->people) &&
                  ++count == choice
               )
               {
                  break;
               }
            }
            if (pRoomIndex)
            {
               break;
            }
         }
         if (pRoomIndex != NULL)
         {
            gch = pRoomIndex->people;
            if (IS_NPC(gch))
            {
               dch = create_mobile(get_mob_index(MOB_VNUM_DOPPLEGANGER));
               char_to_room(dch,pRoomIndex);
               act("$n steps through a black gate and takes on a new form.",dch,NULL,NULL,TO_ROOM);
               send_to_char("You step through a black gate and shift your form!\n\r",dch);
               sprintf(buf,"doppelganger %s",gch->name);
               free_string(dch->name);
               dch->name = str_dup(buf);
               free_string(dch->short_descr);
               dch->short_descr      = str_dup(gch->short_descr);
               free_string(dch->long_descr);
               dch->long_descr       = str_dup(gch->long_descr);
               free_string(dch->description);
               dch->description      = str_dup(gch->description);
               dch->sex              = gch->sex;
               dch->level            = gch->level;
               dch->trust            = 0;
               dch->hit              = gch->hit;
               dch->max_hit          = gch->max_hit;
               dch->mana             = gch->mana;
               dch->max_mana         = gch->max_mana;
               dch->move             = gch->move;
               dch->max_move         = gch->max_move;
               dch->exp              = gch->exp;
               dch->affected_by      = gch->affected_by;
               dch->saving_throw     = gch->saving_throw;
               dch->sight            = gch->sight;
               dch->spell_power      = gch->spell_power;
               dch->holy_power       = gch->holy_power;
               dch->saving_spell     = gch->saving_spell;
               dch->saving_breath    = gch->saving_breath;
               dch->saving_maledict  = gch->saving_maledict;
               dch->saving_transport = gch->saving_transport;
               dch->hitroll          = gch->hitroll;
               dch->damroll          = gch->damroll;
               dch->form             = gch->form;
               dch->parts            = gch->parts;
               dch->size             = gch->size;
               if
               (
                  IS_AFFECTED(dch, AFF_SANCTUARY) &&
                  !is_affected(dch, gsn_sanctuary) &&
                  !is_affected(dch, gsn_chromatic_shield)
               )
               {
                  paf = new_affect();
                  paf->where     = TO_AFFECTS;
                  paf->level     = dch->level;
                  paf->duration  = -1;
                  paf->location  = APPLY_NONE;
                  paf->modifier  = 0;
                  paf->bitvector = AFF_SANCTUARY;
                  if (is_clergy(dch))
                  {
                     paf->type = gsn_sanctuary;
                  }
                  else
                  {
                     paf->type = gsn_chromatic_shield;
                  }
                  affect_to_char(dch, paf);
                  free_affect(paf);
               }
               for (i = 0; i < 4; i++)
               dch->armor[i] = gch->armor[i];
               for (i = 0; i < MAX_STATS; i++)
               {
                  dch->perm_stat[i] = gch->perm_stat[i];
                  dch->mod_stat[i]  = gch->mod_stat[i];
               }
               for (i = 0; i < 3; i++)
               dch->damage[i]    = gch->damage[i];
               act("$n looks around for prey.",dch,NULL,NULL,TO_ROOM);
               send_to_char("You look around for prey.\n\r",dch);
            }
         }
      }
      else
      extract_char( victim, TRUE );
      return;
   }

   /*
   *  Take care of spell, skill, and race affects
   */

   extract_char( victim, FALSE );

   /*
      -10 quittime means you do not drop weapons
      from strength loss (IMPORTANT)
      Otherwise we drop the weapon, and then put it in the corpse
      Definate memory corruption.
   */
   temp_quit = victim->quittime;
   victim->quittime = -10;
   if (!IS_NPC(victim))
   {
      for (paf = victim->affected; paf; paf = paf->next)
      {
         store_death_affect(paf);
      }
   }
   while (victim->affected)
   {
      affect_remove(victim, victim->affected);
   }
   victim->quittime = temp_quit;
   check_changeling_desc(victim);

   victim->form    = race_table[victim->race].form;
   victim->parts    = race_table[victim->race].parts;

   /* Re-apply true sex in case of previous sex altering equipment */
   if ( victim->sex != victim->pcdata->true_sex )
   victim->sex = victim->pcdata->true_sex;

   for (i = 0; i < 4; i++)
   victim->armor[i]= 100;
   victim->position    = POS_RESTING;
   victim->hit         = victim->pcdata->perm_hit/2;
   victim->mana        = victim->pcdata->perm_mana/2;
   victim->move        = victim->pcdata->perm_move/2;
   victim->pcdata->condition[COND_HUNGER] = 48;
   victim->pcdata->condition[COND_THIRST] = 48;
   victim->pcdata->condition[COND_DRUNK] = 0;
   victim->pcdata->condition[COND_FULL] = 0;
   victim->pcdata->condition[COND_DEHYDRATED] = 0;
   victim->pcdata->condition[COND_STARVING] = 0;
   victim->pcdata->learned[gsn_chimera_goat] = -1;
   victim->pcdata->learned[gsn_chimera_lion] = -1;
   REMOVE_BIT(victim->act,PLR_CRIMINAL);
   REMOVE_BIT(victim->act,PLR_MARKED);
   /*    REMOVE_BIT(victim->act,PLR_REBEL); */
   /* Remove Rantialen's 'immerse' bloodstain */
   if (IS_AFFECTED2(victim, AFF_AHZRA_BLOODSTAIN))
   {
      victim->alignment = victim->true_alignment;
      REMOVE_BIT(victim->affected_by2, AFF_AHZRA_BLOODSTAIN);
   }
   if (!IS_NPC(victim))
   {
      restore_death_affects(victim);
   }
   irv_update(victim, FALSE, TRUE);

   save_char_obj( victim );

   victim->ghost = 10;
   if (victim->class==GUILD_MONK-1)
   victim->ghost = 20;
   victim->quittime = 0;
   victim->pause = 0;
   send_to_char("You have died and turned into an invincible ghost for a few minutes.\n\r",victim);
   if (victim->temple != 0)
   location = get_room_index(victim->temple);
   else
   location = get_room_index(ROOM_VNUM_TEMPLE);

   if (location == NULL)
   {
      if (victim->alignment > 0)
      {
         location = get_room_index(10670);
         if (location != NULL)
         victim->temple = 10670;
      }
      else
      if (victim->alignment == 0)
      {
         location = get_room_index(10681);
         if (location != NULL) victim->temple = 10681;
      }
      else
      if (victim->alignment < 0)
      {
         location = get_room_index(10699);
         if (location != NULL) victim->temple = 10699;
      }
   }
   if (location == NULL)
   location = get_room_index(1212);
   if (rotd_flag)
   location = get_room_index(rotd_flag);

   char_to_room(victim,location);
   if (!IS_AFFECTED(victim, AFF_INFRARED))
   {
      paf = new_affect();
      paf->where = TO_AFFECTS;
      paf->type = gsn_infravision;
      paf->duration = 20;
      paf->bitvector = AFF_INFRARED;
      paf->level = victim->level;
      affect_to_char(victim, paf);
      free_affect(paf);
   }
   if (!IS_NPC(victim))
   {
      OBJ_DATA *obj;
      int counter;

      victim->pcdata->death_count++;

      counter = 5;
      obj = get_eq_char(victim,WEAR_BRAND);
      if ((obj != NULL) && (obj->pIndexData->vnum == 28903))
      counter = 10;

      if ((victim->pcdata->death_count%counter == 0) && !IS_IMMORTAL(victim))
      if (!IS_SET(victim->act2,PLR_LICH))
      {
         victim->perm_stat[STAT_CON] -= 1;
         send_to_char("With this death you feel part of your life force slip away.\n\r",victim);
      }
   }

   do_observe(victim, "", LOOK_AUTO);
   return;
}



void group_gain(CHAR_DATA* ch, CHAR_DATA* victim)
{
   char buf[MAX_STRING_LENGTH];
   CHAR_DATA *gch;
   CHAR_DATA *lch;
   int xp;
   int members;
   int group_levels;
   bool has_mage = FALSE;

   /*
   * Monsters don't get kill xp's or alignment changes.
   * P-killing doesn't help either.
   * Dying of mortal wounds or poison doesn't give xp to anyone!
   */
   if
   (
      victim == ch ||
      !IS_NPC(victim)  /* No xp for PKs */
   )
   {
      return;
   }

   members = 0;
   group_levels = 0;
   for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
   {
      if (is_same_group(gch, ch))
      {
         if (!IS_NPC(gch))
         {
            if
            (
               !has_mage &&
               !IS_NPC(gch) &&
               (
                  gch->class == CLASS_ANTI_PALADIN ||
                  gch->class == CLASS_CHANNELER ||
                  gch->class == CLASS_NIGHTWALKER ||
                  gch->class == CLASS_NECROMANCER ||
                  gch->class == CLASS_ELEMENTALIST
               )
            )
            {
               has_mage = TRUE;
            }
            members++;
         }
         else
         {
            group_levels += gch->level;
         }
         group_levels += gch->level;
      }
   }

   if ( members == 0 )
   {
      members = 1;
   }

   lch = (ch->leader != NULL) ? ch->leader : ch;

   for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
   {
      OBJ_DATA *obj;
      OBJ_DATA *obj_next;

      if ( !is_same_group( gch, ch ) || IS_NPC(gch))
      continue;

      if ( gch->level - lch->level > 8 )
      {
         send_to_char( "You are too high for this group.\n\r", gch );
         continue;
      }

      if ( gch->level - lch->level < -8 )
      {
         send_to_char( "You are too low for this group.\n\r", gch );
         continue;
      }


      xp = xp_compute(gch, victim, members, group_levels, has_mage);
      sprintf( buf, "You receive %d experience points.\n\r", xp );
      send_to_char( buf, gch );
      gain_exp( gch, xp );

      for ( obj = ch->carrying; obj != NULL; obj = obj_next )
      {
         obj_next = obj->next_content;
         if ( obj->wear_loc == WEAR_NONE )
         continue;

         if ( ( IS_OBJ_STAT(obj, ITEM_ANTI_EVIL)    && IS_EVIL(ch)    )
         ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_GOOD)    && IS_GOOD(ch)    )
         ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch) )
         ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_METHODICAL)  &&
         (ch->pcdata->ethos > 0))
         ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_NEUT)    &&
         (ch->pcdata->ethos == 0))
         ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_IMPULSIVE) &&
         (ch->pcdata->ethos < 0)))
         {
            act( "You are zapped by $p.", ch, obj, NULL, TO_CHAR );
            act( "$n is zapped by $p.",   ch, obj, NULL, TO_ROOM );
            obj_from_char( obj );
            obj_to_room( obj, ch->in_room );
         }
      }
   }

   return;
}



/*
* Compute xp for a kill.
* Also adjust alignment of killer.
* Edit this function to change xp computations.
*/
int xp_compute(CHAR_DATA* gch, CHAR_DATA* victim, int group_amount, int glevel, bool mage)
{
   int xp,base_exp;
   int level_range;
   double mult;
   CHAR_DATA * leader;

   if (mage)
   {
      check_impure(gch, NULL, IMPURE_GROUP_MAGE);
   }
   if (IS_NPC(victim) &&
   (victim->pIndexData->vnum >= 2900 && victim->pIndexData->vnum <3000))
   return 0;

   leader = (gch->leader != NULL) ? gch->leader : gch;

   if
   (
      has_skill(leader, gsn_battle_tactics) &&
      group_amount > 3 &&
      group_amount < 6
   )
   {
      if (get_skill(leader, gsn_battle_tactics) > 50)
      {
         group_amount = 3;
         glevel = 3*gch->level;
      }
      check_improve(leader, gsn_battle_tactics, TRUE, 1);
   }

   mult=((double)(gch->level)/glevel)*group_amount;
   if(mult>=1)
   {
      mult=(1+mult)/2;
   }
   else
   {
      mult=mult*mult;
   }
   mult = URANGE(.25,mult,1.1);

   level_range = victim->level - gch->level;

   /* compute the base exp */
   switch (level_range)
   {
      default :       base_exp =   0;         break;
      case -9 :       base_exp =   2;         break;
      case -8 :       base_exp =   4;         break;
      case -7 :       base_exp =   7;         break;
      case -6 :       base_exp =   12;         break;
      case -5 :       base_exp =  14;         break;
      case -4 :       base_exp =  25;         break;
      case -3 :       base_exp =  36;         break;
      case -2 :       base_exp =  55;         break;
      case -1 :       base_exp =  70;         break;
      case  0 :       base_exp =  88;         break;
      case  1 :       base_exp =  110;         break;
      case  2 :       base_exp = 131;         break;
      case  3 :       base_exp = 153;         break;
      case  4 :       base_exp = 165;         break;
   }

   if (level_range > 4)
   base_exp = 165 + 10 * (level_range - 4);
   if(mult<1&&level_range>4)
   base_exp = (2*base_exp+165)/3;

   /* do alignment computations */


   /* calculate exp multiplier */
   if (IS_SET(victim->act,ACT_NOALIGN))
   xp = base_exp;

   else if (gch->alignment > 0)  /* for goodie two shoes */
   {
      if (victim->alignment < 0)
      xp = (base_exp *4)/3;

      else if (victim->alignment > 0)
      xp = -30;

      else
      xp = base_exp;
   }

   else if (gch->alignment < 0) /* for baddies */
   {
      if (victim->alignment > 0)
      xp = (base_exp * 4)/3;

      else if (victim->alignment < 0)
      xp = base_exp/2;

      else
      xp = base_exp;
   }


   else /* neutral */
   {
      if (victim->alignment == 0)
      xp = (base_exp*12)/10;
      else
      xp = base_exp;
   }

   xp = (xp*2)/3;

   xp=xp*mult;
   /* randomize the rewards */
   xp = number_range (xp, xp * 5/4);

   /* adjust for grouping */
   if (group_amount == 1)
   xp = (xp * 4)/3;
   if (group_amount == 2)
   xp = (xp * 7)/3;  /* was 5/3rds werv */
   if (group_amount == 3)
   xp = (xp * 7)/3; /* 7/3rds original, 6/3rds after thryms first change -werv */
   if (group_amount > 3)
   xp /= (group_amount - 2);

   return xp;
}


void dam_message( CHAR_DATA *ch, CHAR_DATA *victim,int dam,int dt,bool immune )
{
   char buf1[256];
   char buf2[256];
   char buf3[256];
   OBJ_DATA* wield;
   CHAR_DATA* gch;
   const char* vs;
   const char* vp;
   const char* attack;
   char punct;
   bool color_on = TRUE;

   if (ch == NULL || victim == NULL)
   return;

   if (is_affected(victim, gsn_intangibility))
   {
      color_on = FALSE;
      vs = "pass right through";
      vp = "passes right through";
   }
   else if ( dam == 0   ) { vs = "miss";       vp = "misses";          }
   else if ( dam <=   4 ) { vs = "scratch";    vp = "scratches";       }
   else if ( dam <=   8 ) { vs = "graze";      vp = "grazes";          }
   else if ( dam <=  13 ) { vs = "hit";        vp = "hits";            }
   else if ( dam <=  18 ) { vs = "injure";     vp = "injures";         }
   else if ( dam <=  23 ) { vs = "wound";      vp = "wounds";          }
   else if ( dam <=  28 ) { vs = "maul";       vp = "mauls";           }
   else if ( dam <=  33 ) { vs = "decimate";   vp = "decimates";       }
   else if ( dam <=  38 ) { vs = "devastate";  vp = "devastates";      }
   else if ( dam <=  43 ) { vs = "maim";       vp = "maims";           }
   else if ( dam <=  55 ) { vs = "MUTILATE";   vp = "MUTILATES";       }
   else if ( dam <=  65 ) { vs = "DISEMBOWEL"; vp = "DISEMBOWELS";     }
   else if ( dam <=  75 ) { vs = "DISMEMBER";  vp = "DISMEMBERS";   }
   else if ( dam <=  85 ) { vs = "MASSACRE";   vp = "MASSACRES";       }
   else if ( dam <= 100 ) { vs = "MANGLE";     vp = "MANGLES";         }
   else if ( dam <= 130 ) { vs = "*** DEMOLISH ***";
   vp = "*** DEMOLISHES ***";                 }
   else if ( dam <= 160 ) { vs = "*** DEVASTATE ***";
   vp = "*** DEVASTATES ***";                 }
   else if ( dam <= 200)  { vs = "=== OBLITERATE ===";
   vp = "=== OBLITERATES ===";                }
   else if ( dam <= 280)  { vs = ">>> ANNIHILATE <<<";
   vp = ">>> ANNIHILATES <<<";                }
   else if ( dam <= 380)  { vs = "<<< ERADICATE >>>";
   vp = "<<< ERADICATES >>>";                 }
   else if ( dam <= 600)  { vs = "do UNSPEAKABLE things to";
   vp = "does UNSPEAKABLE things to";         }
   else                   { vs = "DO UNSPEAKABLE THINGS TO";
   vp = "DOES UNSPEAKABLE THINGS TO";         }

   punct   = (dam <= 33) ? '.' : '!';


   /* Now quickly set dual wield weapon dt to real weapon dt */
   if
   (
      dt == gsn_dual_wield ||
      dt == gsn_tertiary_wield
   )
   {
      if (dt == gsn_dual_wield)
      {
         wield = get_eq_char(ch,WEAR_DUAL_WIELD);
      }
      else
      {
         wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
      }
      dt = TYPE_HIT;
      if (wield != NULL)
      {
         dt += wield->value[3];
      }
      else
      {
         dt += ch->dam_type;
      }
   }

   if (dt == TYPE_HIT)
   {
      if (ch == victim)
      {
         sprintf( buf1, "$n %s $melf%c",vp,punct);
         if
         (
            IS_SET(ch->comm, COMM_ANSI) &&
            color_on
         )
         {
            sprintf( buf2, "You \x01B[1;31m%s\x01B[0;37m yourself%c",vs,punct);
         }
         else
         {
            sprintf( buf2, "You %s yourself%c",vs,punct);
         }
      }
      else
      {
         for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
         {
            if (gch != ch && gch != victim)
            {
               if
               (
                  IS_SET(gch->comm, COMM_ANSI) &&
                  color_on
               )
               {
                  sprintf
                  (
                     buf1,
                     "$n's \x01B[1;31m%s\x01B[0;37m %s%c",
                     vp,
                     get_descr_form(victim,gch,FALSE),
                     punct
                  );
               }
               else
               {
                  sprintf
                  (
                     buf1,
                     "$n's %s %s%c",
                     vp,
                     get_descr_form(victim,gch,FALSE),
                     punct
                  );
               }
               if (IS_IMMORTAL(gch) && IS_SET(gch->act, ACT_HOLYLIGHT))
               {
                  if
                  (
                     IS_SET(gch->comm,COMM_ANSI) &&
                     color_on
                  )
                  {
                     sprintf
                     (
                        buf1,
                        "$n's \x01B[1;31m%s\x01B[0;37m %s%c [%d]",
                        vp,
                        get_descr_form(victim,gch,FALSE),
                        punct,
                        dam
                     );
                  }
                  else
                  sprintf( buf1, "$n's %s %s%c [%d]",vp,get_descr_form(victim,gch,FALSE), punct,dam);
               }
               act(buf1,ch,NULL,gch,TO_VICT);
            }
         }
         if
         (
            IS_SET(ch->comm,COMM_ANSI) &&
            color_on
         )
         {
            sprintf( buf2, "You \x01B[1;31m%s\x01B[0;37m $N%c", vs, punct );
         }
         else
         sprintf( buf2, "You %s $N%c", vs, punct );
         if
         (
            IS_SET(victim->comm,COMM_ANSI) &&
            color_on
         )
         {
            sprintf( buf3, "$n \x01B[1;31m%s\x01B[0;37m you%c", vp, punct );
         }
         else
         sprintf( buf3, "$n %s you%c", vp, punct );

      }
   }
   else
   {
      if
      (
         dt > 0 &&
         dt < MAX_SKILL
      )
      {
         attack      = skill_table[dt].noun_damage;
      }
      else if
      (
         dt >= TYPE_HIT &&
         dt < TYPE_HIT + MAX_DAMAGE_MESSAGE
      )
      {
         attack      = attack_table[dt - TYPE_HIT].noun;
      }
      else
      {
         bug( "Dam_message: bad dt %d.", dt );
         dt  = TYPE_HIT;
         attack  = attack_table[0].name;
      }

      if (immune)
      {
         if (ch == victim)
         {
            sprintf(buf1,"$n is unaffected by $s own %s.",attack);
            sprintf(buf2,"Luckily, you are immune to that.");
         }
         else
         {
            sprintf(buf1,"$N is unaffected by $n's %s!",attack);
            sprintf(buf2,"$N is unaffected by your %s!",attack);
            sprintf(buf3,"$n's %s is powerless against you.",attack);
         }
      }
      else
      {
         if (ch == victim)
         {
            for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
            {
               if (gch != ch && gch != victim)
               {
                  if
                  (
                     IS_SET(gch->comm,COMM_ANSI) &&
                     color_on
                  )
                  sprintf( buf1, "$n's %s \x01B[1;31m%s\x01B[0;37m $m%c", attack, vp, punct );
                  else
                  sprintf( buf1, "$n's %s %s $m%c",  attack, vp, punct );
                  if (IS_IMMORTAL(gch)&&IS_SET(gch->act, ACT_HOLYLIGHT))
                  {
                     if
                     (
                        IS_SET(gch->comm,COMM_ANSI) &&
                        color_on
                     )
                     sprintf( buf1, "$n's %s \x01B[1;31m%s\x01B[0;37m [%d] $m%c", attack, vp,dam, punct);
                     else
                     sprintf( buf1, "$n's %s %s [%d] $m%c",attack, vp,dam, punct );
                  }
                  act(buf1,ch,NULL,gch,TO_VICT);
               }
            }
            if
            (
               IS_SET(ch->comm,COMM_ANSI) &&
               color_on
            )
            sprintf( buf2, "Your %s \x01B[1;31m%s\x01B[0;37m you%c",attack,vp,punct);
            else
            sprintf( buf2, "Your %s %s you%c",attack,vp,punct);
         }
         else
         {
            for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
            {
               if (gch != ch && gch != victim)
               {
                  if
                  (
                     IS_SET(gch->comm,COMM_ANSI) &&
                     color_on
                  )
                  sprintf( buf1, "$n's %s \x01B[1;31m%s\x01B[0;37m %s%c",  attack, vp,
                  get_descr_form(victim,gch,FALSE),punct);
                  else
                  sprintf(buf1, "$n's %s %s %s%c", attack, vp,
                  get_descr_form(victim,gch,FALSE), punct);
                  if (IS_IMMORTAL(gch) && IS_SET(gch->act, ACT_HOLYLIGHT))
                  {
                     if
                     (
                        IS_SET(gch->comm,COMM_ANSI) &&
                        color_on
                     )
                     sprintf( buf1, "$n's %s \x01B[1;31m%s\x01B[0;37m %s%c [%d]",  attack, vp,get_descr_form(victim,gch,FALSE),punct, dam);
                     else
                     sprintf(buf1, "$n's %s %s %s%c [%d]",attack,vp,get_descr_form(victim,gch,FALSE), punct, dam);
                  }
                  act(buf1,ch,NULL,gch,TO_VICT);
               }
            }
            if
            (
               IS_SET(ch->comm,COMM_ANSI) &&
               color_on
            )
            sprintf( buf2, "Your %s \x01B[1;31m%s\x01B[0;37m $N%c",  attack, vp, punct );
            else
            sprintf( buf2, "Your %s %s $N%c",  attack, vp, punct );
            if
            (
               IS_SET(victim->comm,COMM_ANSI) &&
               color_on
            )
            sprintf( buf3, "$n's %s \x01B[1;31m%s\x01B[0;37m you%c", attack, vp, punct );
            else
            sprintf( buf3, "$n's %s %s you%c", attack, vp, punct );
         }
      }
   }

   if (ch == victim)
   {
      act(buf2,ch,NULL,NULL,TO_CHAR);
   }
   else
   {
      act( buf2, ch, NULL, victim, TO_CHAR );
      act( buf3, ch, NULL, victim, TO_VICT );
   }
   /*
   *   Special Arena Code - Wervdon
   */
   if (ch->in_room->vnum >= 10437 && ch->in_room->vnum <= 10461)
   {
      int cnt;
      ROOM_INDEX_DATA *room;
      if
      (
         dt > 0 &&
         dt < MAX_SKILL
      )
      {
         attack      = skill_table[dt].noun_damage;
      }
      else if
      (
         dt >= TYPE_HIT &&
         dt < TYPE_HIT + MAX_DAMAGE_MESSAGE
      )
      {
         attack      = attack_table[dt - TYPE_HIT].noun;
      }
      else
      {
         dt  = TYPE_HIT;
         attack  = attack_table[0].name;
      }
      for (cnt = 10462; cnt <= 10496; cnt++)
      {
         room = get_room_index(cnt);
         if (room == NULL) continue;
         if (room->people == NULL) continue;
         for (gch = room->people; gch != NULL; gch = gch->next_in_room)
         {
            if (victim == ch)
            {
               if
               (
                  IS_SET(gch->comm,COMM_ANSI) &&
                  color_on
               )
               sprintf( buf1, "$n's %s \x01B[1;31m%s\x01B[0;37m $m%c", attack, vp, punct );
               else
               sprintf( buf1, "$n's %s %s $m%c",  attack, vp, punct );
               act(buf1,ch,NULL,gch,TO_VICT);
            }
            else
            {
               if
               (
                  IS_SET(gch->comm,COMM_ANSI) &&
                  color_on
               )
               sprintf( buf1, "$n's %s \x01B[1;31m%s\x01B[0;37m %s%c",  attack, vp,
               get_descr_form(victim,gch,FALSE),punct);
               else
               sprintf(buf1, "$n's %s %s %s%c", attack, vp,
               get_descr_form(victim,gch,FALSE), punct);
               act(buf1,ch,NULL,gch,TO_VICT);
            }
         }
      }
   }

   if (dt != gsn_poison && dt != gsn_plague && dt != gsn_soulcraft
   && dt != gsn_parrot
   && dt != gsn_starvation
   && dt != gsn_dehydrated)
   {
      if (!IS_IMMORTAL(ch))
      {
         if (!IS_NPC(victim))
         {
            ch->bloody_shrine = 10;
            ch->pause = 5;
         }
         else if (victim->pIndexData->vnum != MOB_VNUM_GNOME_SPY)
         {
            ch->bloody_shrine = 3;
            if (ch->pause <= 1) ch->pause = 1;
            if (victim->pIndexData->vnum == MOB_VNUM_OUTLAW_GIANT)
            {
               ch->bloody_shrine = 10;
               ch->pause = 30;
            }
         }
      }
      if (!IS_IMMORTAL(victim))
      {
         if (!IS_NPC(ch))
         {
            victim->bloody_shrine = 10;
            victim->pause = 5;
         }
         else if (ch->pIndexData->vnum != MOB_VNUM_GNOME_SPY)
         {
            victim->bloody_shrine = 3;
            if (victim->pause <= 1) victim->pause = 1;
            if (ch->pIndexData->vnum == MOB_VNUM_OUTLAW_GIANT)
            {
               ch->bloody_shrine = 10;
               ch->pause = 30;
            }
         }
      }
   }
   return;
}



/*
* Disarm a creature.
* Caller must check for successful attack.
*/
void disarm( CHAR_DATA *ch, CHAR_DATA *victim )
{
   OBJ_DATA *obj;
   OBJ_DATA *secondary;


   if ( ( obj = get_eq_char( victim, WEAR_WIELD ) ) == NULL )
   return;

   if ( IS_OBJ_STAT(obj,ITEM_NOREMOVE))
   {
      act("$S weapon will not budge!",ch,NULL,victim,TO_CHAR);
      act("$n tries to disarm you, but your weapon will not budge!",
      ch,NULL,victim,TO_VICT);
      act("$n tries to disarm $N, but fails.",ch,NULL,victim,TO_NOTVICT);
      return;
   }

   act( "$n DISARMS you and sends your weapon flying!",
   ch, NULL, victim, TO_VICT    );
   act( "You disarm $N!",  ch, NULL, victim, TO_CHAR    );
   act( "$n disarms $N!",  ch, NULL, victim, TO_NOTVICT );

   obj_from_char( obj );
   if ( IS_OBJ_STAT(obj,ITEM_NODROP) || IS_OBJ_STAT(obj,ITEM_INVENTORY) )
   obj_to_char( obj, victim );
   else
   {
      obj_to_room( obj, victim->in_room );
      if (IS_NPC(victim) && victim->wait == 0 && can_see_obj(victim,obj))
      get_obj(victim,obj,NULL,0);
   }

   reslot_weapon(victim);

   if ((secondary = get_eq_char(victim,WEAR_DUAL_WIELD)) != NULL)
   {
      unequip_char(victim,secondary);
      equip_char(victim,secondary,WEAR_WIELD);
   }
   return;
}

void do_berserk( CHAR_DATA *ch, char *argument)
{
   int chance, hp_percent;

   if ((chance = get_skill(ch,gsn_berserk)) == 0
   ||  (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BERSERK))
   ||  (!IS_NPC(ch)
   &&  /* ch->level < skill_table[gsn_berserk].skill_level[ch->class]))*/
   !has_skill(ch,gsn_berserk)))
   {
      send_to_char("You turn red in the face, but nothing happens.\n\r",ch);
      return;
   }

   if (IS_AFFECTED(ch,AFF_BERSERK) || is_affected(ch,gsn_berserk)
   ||  is_affected(ch, gsn_frenzy))
   {
      send_to_char("You get a little madder.\n\r",ch);
      return;
   }

   if (IS_AFFECTED(ch,AFF_CALM))
   {
      send_to_char("You're feeling to mellow to berserk.\n\r",ch);
      return;
   }

   if (ch->mana < 50)
   {
      send_to_char("You can't get up enough energy.\n\r",ch);
      return;
   }

   /* modifiers */

   /* fighting */
   if (ch->position == POS_FIGHTING)
   chance += 10;

   /* damage -- below 50% of hp helps, above hurts */
   if (ch->max_hit == 0)
   hp_percent = 0;
   else
   hp_percent = 100 * ch->hit/ch->max_hit;
   chance += 25 - hp_percent/2;

   if (number_percent() < chance)
   {
      AFFECT_DATA af;

      WAIT_STATE(ch,PULSE_VIOLENCE);
      ch->mana -= 50;
      ch->move /= 2;

      /* heal a little damage */
      ch->hit += (ch->drain_level + ch->level) * 2;
      ch->hit = UMIN(ch->hit,ch->max_hit);

      send_to_char("Your pulse races as you are consumed by rage!\n\r",ch);
      act("$n gets a wild look in $s eyes.",ch,NULL,NULL,TO_ROOM);
      check_improve(ch,gsn_berserk,TRUE,2);

      af.where        = TO_AFFECTS;
      af.type         = gsn_berserk;
      af.level        = ch->level + ch->drain_level;
      af.duration     = (ch->drain_level + ch->level) / 2;
      if (af.duration < 0)
      {
         af.duration = 0;
      }
      af.modifier     = UMAX(1,(ch->drain_level + ch->level)/5);
      af.bitvector    = AFF_BERSERK;

      af.location     = APPLY_HITROLL;
      affect_to_char(ch,&af);

      af.location     = APPLY_DAMROLL;
      affect_to_char(ch,&af);


      if (ch->race == grn_dwarf)
      {
         af.modifier = 0;
      }
      else
      {
         af.modifier = (ch->drain_level + ch->level);
      }
      af.location     = APPLY_AC;
      affect_to_char(ch,&af);
   }

   else
   {
      WAIT_STATE(ch,PULSE_VIOLENCE);
      ch->mana -= 25;

      send_to_char("Your pulse speeds up, but nothing happens.\n\r",ch);
      check_improve(ch,gsn_berserk,FALSE,2);
   }
}


/*
void do_deathstyle( CHAR_DATA *ch, char *argument)
{
   int chance;

   if ((chance = get_skill(ch,gsn_deathstyle)) <= 0
   ||  (!IS_NPC(ch)
   && *  ch->level < skill_table[gsn_deathstyle].skill_level[ch->class]) *
   !has_skill(ch,gsn_deathstyle))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_deathstyle))
   {
      send_to_char("Your rage is on the brink of losing control already.\n\r",ch);
      return;
   }

   if (ch->mana < 20 || ch->move < (ch->max_move/8))
   {
      send_to_char("The increased rage would be too much for you.\n\r",ch);
      return;
   }



   if (number_percent() < chance)
   {
      AFFECT_DATA af;

      ch->mana -= 20;
      ch->move *= .875;

      send_to_char("Your rage climbs to a controlled level!\n\r",ch);
      act("$n tenses $s muscles and grits $s teeth.",ch,NULL,NULL,TO_ROOM);
      check_improve(ch,gsn_deathstyle,TRUE,2);

      af.where        = TO_AFFECTS;
      af.type         = gsn_deathstyle;
      af.level        = ch->level;
      af.duration     = number_fuzzy(ch->level / 3);
      af.modifier     = 6;
      af.bitvector    = 0;

      af.location     = APPLY_HITROLL;
      affect_to_char(ch,&af);

      af.location     = APPLY_DAMROLL;
      affect_to_char(ch,&af);

      af.modifier     = -(ch->level / 2);
      af.location     = APPLY_AC;
      affect_to_char(ch,&af);

      af.modifier     = -5;
      af.location     = APPLY_INT;
      affect_to_char(ch,&af);

      af.location     = APPLY_WIS;
      affect_to_char(ch,&af);

      af.modifier     = 1;
      af.location     = APPLY_STR;
      affect_to_char(ch,&af);

      af.location     = APPLY_DEX;
      affect_to_char(ch,&af);

      af.modifier     = 100;
      af.location     = APPLY_HIT;
      affect_to_char(ch,&af);
   }

   else
   {
      ch->mana -= 10;

      send_to_char("Your pulse speeds up, but nothing happens.\n\r",ch);
      check_improve(ch,gsn_deathstyle,FALSE,2);
   }

}
*/

void do_bash(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   int chance;
   char buf[MAX_STRING_LENGTH];
   OBJ_DATA* obj;
   OBJ_DATA* wield;

   one_argument(argument,arg);

   if
   (
      (
         chance = get_skill(ch,gsn_bash)
      ) <= 0 ||
      (
         IS_NPC(ch) &&
         !IS_SET(ch->off_flags, OFF_BASH)
      ) ||
      (
         !IS_NPC(ch) &&
         !has_skill(ch, gsn_bash)
      )
   )
   {
      send_to_char("Bashing? What's that?\n\r", ch);
      return;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
      if (victim->in_room != ch->in_room)
      {
         send_to_char("They are too far away!", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (check_peace(ch))
   {
      return;
   }
   wield = get_eq_char(ch, WEAR_WIELD);
   if
   (
      wield != NULL &&
      wield->value[0] == WEAPON_BOW &&
      !check_tanking(ch) &&
      fire_volley(ch, NULL, TRUE)
   )
   {
      send_to_char("You cannot use close range combat techniques while wielding a ranged weapon.\n\r", ch);
      return;
   }

   if
   (
      victim->position < POS_FIGHTING ||
      victim->daze > 0
   )
   {
      act
      (
         "You will have to let $M get back up first.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if (victim == ch)
   {
      send_to_char("You try to bash your brains out, but fail.\n\r", ch);
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if
   (
      IS_AFFECTED(ch, AFF_CHARM) &&
      ch->master == victim
   )
   {
      act
      (
         "But $N is your friend!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   /*
   if (is_affected(victim,gsn_phasing) &&
   (number_percent() < (75+((victim->level-ch->level)*2))))
   {
   act("You phase out and $N's bash doesn't affect you.",victim,0,ch,TO_CHAR);
   act("$n phases out and $N's bash doesn't seem to affect him.",victim,0,ch,TO_NOTVICT);
   act("$n phases out and your bash doesn't seem to affect him.",victim,0,ch,TO_VICT);
   WAIT_STATE(ch,20);
   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (victim->fighting == NULL || ch->fighting == NULL))
   {
   sprintf(buf,"Help! %s is trying to bash me!",PERS(ch,victim));
   do_myell(victim,buf);
   sprintf(log_buf, "[%s] bashed [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
   log_string(log_buf);
   }
   return;
   }
   */
   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   if
   (
      (
         (
            obj = get_eq_char(victim, WEAR_FINGER_L)
         ) != NULL &&
         obj->pIndexData->vnum == 16029
      ) ||
      (
         (
            obj = get_eq_char(victim, WEAR_FINGER_R)
         ) != NULL &&
         obj->pIndexData->vnum == 16029
      ) ||
      (
         is_affected(victim, gsn_protective_shield) &&
         (
            number_percent() <
            (
               70 +
               (
                  (
                     victim->level - ch->level
                  ) * 2
               )
            )
         )
      )
   )
   {
      act
      (
         "$N's bash seems to slide around you.",
         victim,
         NULL,
         ch,
         TO_CHAR
      );
      act
      (
         "$N's bash seems to slide around $n.",
         victim,
         NULL,
         ch,
         TO_NOTVICT
      );
      act
      (
         "Your bash seems to slide around $n.",
         victim,
         NULL,
         ch,
         TO_VICT
      );
      WAIT_STATE(ch, 20);
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            victim->fighting == NULL ||
            ch->fighting == NULL
         )
      )
      {
         sprintf
         (
            log_buf,
            "[%s] bashed [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
         sprintf
         (
            buf,
            "Help! %s is trying to bash me!",
            PERS(ch, victim)
         );
         do_myell(victim, buf);
      }
      damage
      (
         ch,
         victim,
         0,
         gsn_bash,
         DAM_BASH,
         TRUE
      );
      return;
   }

   /* modifiers */

   /* size  and weight */
   chance += ch->carry_weight / 250;
   chance -= victim->carry_weight / 200;

   if (ch->size < victim->size)
   {
      chance += (ch->size - victim->size) * 20;
   }
   else
   {
      chance += (ch->size - victim->size) * 10;
   }


   /* stats */
   chance += get_curr_stat(ch, STAT_STR);
   chance -= get_curr_stat(victim, STAT_DEX) * 4 / 3;
   chance -= GET_AC(victim, AC_BASH) / 25;
   /* speed */
   if (IS_SET(ch->off_flags, OFF_FAST) || IS_AFFECTED(ch, AFF_HASTE))
   {
      chance += 10;
   }
   if (IS_SET(victim->off_flags, OFF_FAST) || IS_AFFECTED(victim, AFF_HASTE))
   {
      chance -= 30;
   }

   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         victim->fighting == NULL ||
         ch->fighting == NULL
      )
   )
   {
      sprintf
      (
         log_buf,
         "[%s] bashed [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
      sprintf
      (
         buf,
         "Help! %s is bashing me!",
         PERS(ch, victim)
      );
      do_myell(victim, buf);
   }


   if
   (
      !IS_NPC(victim) &&
      chance < get_skill(victim, gsn_dodge)
   )
   {
      chance -= 3 * (get_skill(victim, gsn_dodge) - chance);
   }

   /* now the attack */
   if (number_percent() < chance )
   {
      if (oblivion_blink(ch, victim))
      {
         return;
      }
      switch(number_range(1,6))
      {
         case(1):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               act
               (
                  "$n sends you hurtling backward with a powerful bash!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You slam into $N and send $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n sends $N hurtling backward with a powerful bash.",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               act
               (
                  "$n sends you flying backward with a powerful bash!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You slam into $N and send $M flying backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n sends $N flying backward with a powerful bash.",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n sends you sprawling with a powerful bash!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You slam into $N and send $M flying!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n sends $N sprawling with a powerful bash.",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(2):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               act
               (
                  "$n lowers $s shoulder and swims into you, sending you hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your shoulder and swim into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s shoulder and swims into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               act
               (
                  "$n lowers $s shoulder and flies into you, sending you flying backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your shoulder and fly into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s shoulder and flies into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;

            }
            else
            {
               act
               (
                  "$n lowers $s shoulder and rushes into you, sending you sprawling!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your shoulder and rush into $N, sending $M sprawling!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s shoulder and rushes into $N, sending $M sprawling!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(3):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               act
               (
                  "$n swims straight at you and plows into you with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You swim straight at $N and plow into $M with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n swims straight at $N and plows into $M with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else if
            (
               ch->in_room->sector_type == SECT_AIR ||
               IS_FLYING(ch)  
            )      
            {
               act
               (
                  "$n flies straight at you and plows into you with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You fly straight at $N and plow into $M with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n flies straight at $N and plows into $M with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n takes a running start at you and brings you down with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You take a running start at $N and bring $M down with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n takes a running start at $N and brings $M down with a vicious tackle!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(4):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               act
               (
                  "$n lunges at you in a violent body assault, knocking you backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lunge at $N in a violent body assault, knocking $M backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lunges at $N in a violent body assault, knocking $M backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;               
            }
            else if 
            (
               ch->in_room->sector_type == SECT_AIR ||
               IS_FLYING(ch)
            )
            {
               act
               (
                  "$n flies at you in a violent body assault, knocking you backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You flies at $N in a violent body assault, knocking $M backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n flies at $N in a violent body assault, knocking $M backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n lunges at you in a violent body assault, knocking you to the ground hard!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lunge at $N in a violent body assault, knocking $M to the ground hard!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lunges at $N in a violent body assault, knocking $M to the ground hard!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(5):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               act
               (
                  "$n lowers $s head and swims into you, sending you hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your head and swims into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s head and swims into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;               
            }
            else if (ch->in_room->sector_type == SECT_AIR)         
            {
               act
               (
                  "$n lowers $s head and flies into you, sending you hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your head and fly into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s head and flies into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n lowers $s head and slams into you, sending you sprawling!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your head and slam into $N, sending $M sprawling!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s head and slams into $N, sending $M sprawling!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(6):
         {
            if
            (
               ch->in_room->sector_type == SECT_UNDERWATER ||
               (
                  ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                  IS_AFFECTED(ch, AFF_SWIM)
               )
            )
            {
               act
               (
                  "$n lowers $s shoulder and plows into you, sending you hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your shoulder and plow into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s shoulder and plows into $N, sending $M hurtling backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else if (ch->in_room->sector_type == SECT_AIR)
            {
               act
               (
                  "$n lowers $s shoulder and flies into you, sending you flying backward!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your shoulder and fly into $N, sending $M flying backward!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s shoulder and flies into $N, sending $M flying backward!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n lowers $s shoulder and plows into you, sending you flying!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You lower your shoulder and plow into $N, sending $M flying!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lowers $s shoulder and plows into $N, sending $M flying!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
      }
      check_improve
      (
         ch,
         gsn_bash,
         TRUE,
         1
      );
      DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
      damage
      (
         ch,
         victim,
         number_range(2, 2 + 2 * ch->size + chance / 20),
         gsn_bash,
         DAM_BASH,
         TRUE
      );
      WAIT_STATE(ch, skill_table[gsn_bash].beats);
      victim->position = POS_RESTING;
   }
   else
   {
      damage
      (
         ch,
         victim,
         0,
         gsn_bash,
         DAM_BASH,
         FALSE
      );
      act
      (
         "You fall flat on your face!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n falls flat on $s face.",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      act
      (
         "You evade $n's bash, causing $m to fall flat on $s face.",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      check_improve
      (
         ch,
         gsn_bash,
         FALSE,
         1
      );
      ch->position = POS_RESTING;
      WAIT_STATE(ch, skill_table[gsn_bash].beats * 3 / 2);
   }
   check_killer(ch, victim);
}

void do_canopy_walk(CHAR_DATA *ch, char *argument)
{
   AFFECT_DATA af;
   ROOM_INDEX_DATA *pRoomIndex;
   char log_buf[MAX_STRING_LENGTH];
   int sn, cnt;
   bool exit = FALSE;

   sn = gsn_canopy_walk;
   if ( (get_skill(ch,sn)) <= 0 || !has_skill(ch,sn) )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if ( ch->fighting != NULL )
   {
      send_to_char( "You can't escape into the canopy, you're fighting!\n\r", ch);
      return;
   }
   if  (is_affected(ch,gsn_trapstun) )
   {
      send_to_char("You can't escape into the canopy, you're caught in a snare!\n\r",ch);
      return;
   }

   if
   (
      IS_SET(ch->in_room->extra_room_flags, ROOM_DEAD_ZONE) &&
      !IS_SET(ch->in_room->room_flags, ROOM_CONSECRATED)
   )
   {
      send_to_char("You cannot escape into the canopy!\n\r", ch);
      return;
   }
   if ( (IS_SET(ch->in_room->extra_room_flags,ROOM_1212)))
   {
      send_to_char("You fail.\n\r",ch);
      return;
   }

   if ((ch->in_room->sector_type != SECT_FOREST)
   && (ch->in_room->sector_type != SECT_UNDERGROUND)
   && (ch->in_room->sector_type != SECT_HILLS)
   && (ch->in_room->sector_type != SECT_MOUNTAIN))
   {
      send_to_char("There is no canopy here.\n\r",ch);
      return;
   }

   if (is_affected(ch,sn))
   {
      send_to_char("You are too tired to walk the canopies again.\n\r",ch);
      return;
   }
   if (ch->move < 50)
   {
      send_to_char("You are too tired to walk the canopies.\n\r",ch);
      return;
   }

   ch->move -= 50;
   if (number_percent() > get_skill(ch,sn))
   {
      send_to_char("You grab a vine and it breaks.\n\r",ch);
      check_improve(ch,sn,FALSE,2);
      return;
   }

   pRoomIndex = get_random_room(ch, RANDOM_AREA_FOREST);
   cnt = 0;
   while (!exit)
   {
      if (pRoomIndex == NULL)
      {
         bug("NULL room from get_random_room.",0);
         return;
      }
      if (cnt >= 50)
      {
         sprintf
         (
            log_buf,
            "[Canopy Walk] No forest exit found from room %d.",
            ch->in_room->vnum
         );
         log_string(log_buf);
         send_to_char("The canopy appears to be too small to travel upon.\n\r",ch);
         check_improve(ch,sn,FALSE,2);
         return;
      }
      if (ch->in_room != pRoomIndex)
      {
         exit = TRUE;
      }
      else
      {
         pRoomIndex = get_random_room(ch, RANDOM_AREA_FOREST);
         cnt++;
      }
   }

   check_improve(ch,sn,TRUE,2);
   act("$n grabs a vine from the canopy and swings away!",ch,NULL,NULL,TO_ROOM);
   send_to_char("You grab a vine from the canopy and swing away!\n\r",ch);
   WAIT_STATE(ch,12);

   af.where        = TO_AFFECTS;
   af.type         = sn;
   af.level        = ch->level;
   af.duration     = 6;
   af.location     = 0;
   af.modifier     = 0;
   af.bitvector    = 0;
   affect_to_char(ch,&af);

   if ( ch->is_riding )
   do_dismount(ch,NULL);

   char_from_room(ch);
   char_to_room(ch,pRoomIndex);
   act("$n climbs down from the canopy above and sets $s feet on solid ground.",ch,NULL,NULL,TO_ROOM);
   do_observe(ch, "", LOOK_AUTO);
   return;
}

/* Prevent problems with 'sm' pointing to both 'smoke' and 'smile' */
void do_sm(CHAR_DATA* ch, char* argument)
{
   if
   (
      !has_skill(ch, gsn_smoke_screen) ||
      !get_skill(ch, gsn_smoke_screen)
   )
   {
      check_social(ch, "smile", argument);
      return;
   }
   do_smoke_screen(ch, argument);
}

void do_smoke_screen(CHAR_DATA *ch, char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA af;
   ROOM_AFFECT_DATA raf;
   CHAR_DATA* guard;
   ROOM_INDEX_DATA *was_in_room;
   ROOM_INDEX_DATA *pRoomIndex;
   char log_buf[MAX_STRING_LENGTH];
   int door;
   int number;

   if
   (
      !has_skill(ch, gsn_smoke_screen) ||
      (
         number = get_skill(ch, gsn_smoke_screen)
      ) <= 0
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   switch (ch->position)
   {
      case (POS_DEAD):
      {
         send_to_char("Lie still; you are DEAD.\n\r", ch);
         return;
      }
      case (POS_INCAP):
      case (POS_MORTAL):
      {
         send_to_char("You are hurt far too bad for that.\n\r", ch);
         return;
      }
      case (POS_STUNNED):
      {
         send_to_char("You are too stunned to do that.\n\r", ch);
         return;
      }
      case (POS_SLEEPING):
      {
         send_to_char("In your dreams, or what?\n\r", ch);
         return;
      }
      case (POS_RESTING):
      {
         send_to_char( "Nah... You feel too relaxed...\n\r", ch);
         return;
      }
      case (POS_SITTING):
      {
         send_to_char( "Better stand up first.\n\r", ch);
         return;
      }
      default:
      {
         /* require POS_FIGHTING or better in case it comes from do_sm */
         break;
      }
   }

   if (is_affected(ch,gsn_trapstun))
   {
      send_to_char("You can't flee you're in a snare.\n\r",ch);
      return;
   }

   if (IS_SET(ch->in_room->extra_room_flags, ROOM_DEAD_ZONE))
   {
      send_to_char("You failed.\n\r", ch);
      return;
   }
   if ((IS_SET(ch->in_room->extra_room_flags, ROOM_1212)) || (ch->in_room->vnum ==  23610))
   {
      send_to_char("You fail.\n\r",ch);
      return;
   }

   was_in_room = ch->in_room;
   one_argument(argument,arg);

   if (house_down(ch,HOUSE_OUTLAW))
   return;

   if (ch->in_room->house != 0)
   {
      send_to_char("You can't do that in here.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_corrupt("smoke screen", &gsn_smoke_screen)))
   {
      send_to_char("You do not have any more smoke bombs yet.\n\r",ch);
      return;
   }

   if ( (number = number_percent()) > get_skill(ch,gsn_corrupt("smoke screen", &gsn_smoke_screen)))
   {
      send_to_char("You drop the smoke bomb and fail.\n\r",ch);
      check_improve(ch,gsn_corrupt("smoke screen", &gsn_smoke_screen),FALSE,2);
      return;
   }

   check_improve(ch,gsn_corrupt("smoke screen", &gsn_smoke_screen),TRUE,2);

   if (ch->in_room->house == 0)
   {
      for (guard = ch->in_room->people; guard; guard = guard->next_in_room)
      {
         if (guard->position <= POS_SLEEPING)
         {
            continue;
         }
         switch (guard_type(guard))
         {
            case (GUARD_SENTRY):
            case (GUARD_SENTINEL):
            {
               if
               (
                  number_percent() >
                  (
                     75 +
                     (
                        guard->level < ch->level ?
                        (guard->level - ch->level) * 5 :
                        0
                     )
                  )
               )
               {
                  continue;
               }
               act
               (
                  "$n tries to throw out a smoke bomb, but $N catches it!",
                  ch,
                  NULL,
                  guard,
                  TO_ROOM
               );
               act
               (
                  "$N catches your smoke bomb!",
                  ch,
                  NULL,
                  guard,
                  TO_CHAR
               );
               DAZE_STATE(ch, PULSE_VIOLENCE / 2);
               return;
            }
            default:
            {
               break;
            }
         }
      }
   }
   act("$n throws out a smoke screen!",ch,NULL,NULL,TO_ROOM);
   send_to_char("You throw out a smoke bomb and escape!\n\r",ch);
   stop_fighting(ch, TRUE);

   WAIT_STATE(ch,skill_table[gsn_corrupt("smoke screen", &gsn_smoke_screen)].beats);

   af.where        = TO_AFFECTS;
   af.type         = gsn_corrupt("smoke screen", &gsn_smoke_screen);
   af.level        = ch->level + ch->drain_level;
   af.duration     = 6;
   af.location     = 0;
   af.modifier     = 0;
   af.bitvector    = 0;
   affect_to_char(ch,&af);
   raf.where  = TO_ROOM;
   raf.duration = 1;
   raf.type = gsn_corrupt("smoke screen", &gsn_smoke_screen);
   raf.level = ch->level;
   raf.bitvector = 0;
   raf.caster = ch;
   act("You can't see for the smoke!",ch,0,0,TO_ROOM);
   affect_to_room(ch->in_room,&raf);

   /* borrowed from deathcry -werv */
   for ( door = 0; door <= 5; door++ )
   {
      EXIT_DATA *pexit;

      if ( ( pexit = was_in_room->exit[door] ) != NULL
      &&   pexit->u1.to_room != NULL
      &&   pexit->u1.to_room != was_in_room )
      {
         char_from_room(ch);
         char_to_room_1(ch, pexit->u1.to_room, TO_ROOM_AT);
         if (ch->in_room->house == 0)
         {
            affect_to_room(ch->in_room,&raf);
            act("You can't see for the smoke!",ch,0,0,TO_ROOM);
         }
      }
   }
   char_from_room(ch);
   char_to_room_1(ch, was_in_room, TO_ROOM_AT);

   sprintf(log_buf, "%s is using smokescreen in area %s.",ch->name,ch->in_room->area->name);
   log_string( log_buf );


   if( (pRoomIndex = get_random_room(ch,RANDOM_AREA)) == NULL )
   {
      bug("NULL room from get_random_room.",0);
      return;
   }

   char_from_room(ch);
   char_to_room(ch,pRoomIndex);

   do_observe(ch, "", LOOK_AUTO);
   return;
}


void do_dirt(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   int chance;
   char buf[MAX_STRING_LENGTH];
   OBJ_DATA* obj;

   one_argument(argument, arg);

   if
   (
      (chance = get_skill(ch, gsn_dirt)) <= 0 ||
      (
         IS_NPC(ch) &&
         !IS_SET(ch->off_flags, OFF_KICK_DIRT)
      ) ||
      (
         !IS_NPC(ch) &&
         !has_skill(ch, gsn_dirt)
      )
   )
   {
      send_to_char("You get your feet dirty.\n\r", ch);
      return;
   }

   obj = get_eq_char(ch, WEAR_FEET);
   if (obj == NULL)
   {
      obj = get_eq_char(ch, WEAR_HOOVES);
   }
   if (obj == NULL)
   {
      obj = get_eq_char(ch, WEAR_FOURHOOVES);
   }

   if (obj != NULL)
   {
      if (obj->pIndexData->vnum == OBJ_VNUM_SHACKLES)
      {
         WAIT_STATE(ch, 24);
         send_to_char("You can't kick anything while in chains!\n\r", ch);
         return;
      }
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't in combat!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r", ch);
      return;
   }

   if (check_peace(ch))
   {
      return;
   }

   if (IS_AFFECTED(victim, AFF_BLIND))
   {
      if (victim->race == grn_book)
      {
         act
         (
            "$E has already been blinded from the dirt on $S cover.",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
      }
      else
      {
         act
         (
            "$E has already been blinded from the dirt in $S eyes.",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
      }
      return;
   }

   if (victim->position == POS_SLEEPING)
   {
      if (victim->race == grn_book)
      {
         act
         (
            "Half of $E cover is on the ground.",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
      }
      else
      {
         act
         (
            "$E eyes are closed.",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
      }
      return;
   }

   if (victim == ch)
   {
      send_to_char("Very funny.\n\r", ch);
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if
   (
      IS_AFFECTED(ch, AFF_CHARM) &&
      ch->master == victim
   )
   {
      act
      (
         "But $N is such a good friend!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /* modifiers */

   /* dexterity */
   chance += get_curr_stat(ch,STAT_DEX);
   chance -= 2 * get_curr_stat(victim,STAT_DEX);

   /* speed  */
   if
   (
      IS_SET(ch->off_flags, OFF_FAST) ||
      IS_AFFECTED(ch, AFF_HASTE)
   )
   {
      chance += 10;
   }
   if
   (
      IS_SET(victim->off_flags, OFF_FAST) ||
      IS_AFFECTED(victim, AFF_HASTE)
   )
   {
      chance -= 25;
   }

   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level) * 2;

   /* sloppy hack to prevent false zeroes */
   if (chance % 5 == 0)
   {
      chance += 1;
   }

   /* terrain */

   switch(ch->in_room->sector_type)
   {
      case(SECT_INSIDE):              chance -= 20;   break;
      case(SECT_CITY):                chance -= 10;   break;
      case(SECT_FIELD):               chance +=  5;   break;
      case(SECT_FOREST):                              break;
      case(SECT_HILLS):                               break;
      case(SECT_MOUNTAIN):            chance -= 10;   break;
      case(SECT_UNDERWATER):          chance  =  0;   break;
      case(SECT_WATER_SWIM):          chance  =  0;   break;
      case(SECT_WATER_NOSWIM):        chance  =  0;   break;
      case(SECT_AIR):                 chance  =  0;   break;
      case(SECT_DESERT):              chance += 10;   break;
   }

   if (chance == 0)
   {
      send_to_char("There isn't any dirt to kick.\n\r", ch);
      return;
   }

   /* now the attack */

   if (number_percent() < chance)
   {
      /* Prevent immune mobs from being affected -- Wicket */
      if (check_immune(victim, DAM_OTHER) == IS_IMMUNE)
      {
         /* To get the unaffected message */
         damage
         (
            ch,
            victim,
            1,
            gsn_dirt,
            DAM_OTHER,
            TRUE
         );
         act
         (
            "$N is unaffected by $n's kicked dirt!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         check_improve
         (
            ch,
            gsn_dirt,
            TRUE,
            2
         );
         WAIT_STATE(ch, skill_table[gsn_dirt].beats);
      }
      else
      {
         AFFECT_DATA af;
         if (victim->race == grn_book)
         {
            act
            (
               "$n is blinded by the dirt on $s cover!",
               victim,
               NULL,
               NULL,
               TO_ROOM
            );
            act
            (
               "$n kicks dirt all over your cover!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
         }
         else
         {
            act
            (
               "$n is blinded by the dirt in $s eyes!",
               victim,
               NULL,
               NULL,
               TO_ROOM
            );
            act
            (
               "$n kicks dirt in your eyes!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
         }

         if
         (
            !IS_NPC(ch) &&
            !IS_NPC(victim) &&
            (
               (victim->fighting == NULL) ||
               (ch->fighting == NULL)
            )
         )
         {
            sprintf
            (
               log_buf,
               "[%s] dirt kicked [%s] at %d",
               ch->name,
               victim->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
            if (victim->race == grn_book)
            {
               do_myell(victim, "Help! Someone just kicked dirt all over my cover!");
            }
            else
            {
               do_myell(victim, "Help! Someone just kicked dirt in my eyes!");
            }
         }

         send_to_char("You cannot see a thing!\n\r", victim);
         check_improve
         (
            ch,
            gsn_dirt,
            TRUE,
            2
         );
         WAIT_STATE(ch, skill_table[gsn_dirt].beats);

         af.where        = TO_AFFECTS;
         af.type         = gsn_dirt;
         af.level        = ch->level + ch->drain_level;
         af.duration     = 0;
         af.location     = APPLY_HITROLL;
         af.modifier     = -4;
         af.bitvector    = AFF_BLIND;

         affect_to_char(victim, &af);
         damage
         (
            ch,
            victim,
            number_range(2,5),
            gsn_dirt,
            DAM_OTHER,
            TRUE
         );

      }
   }
   else
   {
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            victim->fighting == NULL ||
            ch->fighting == NULL
         )
      )
      {
         switch(number_range(0,1))
         {
            case (0):
            {
               if (victim->race == grn_book)
               {
                  sprintf
                  (
                     buf,
                     "Help! %s just tried to kick dirt all over my cover!",
                     PERS(ch, victim)
                  );
               }
               else
               {
                  sprintf
                  (
                     buf,
                     "Help! %s just tried to kick dirt in my eyes!",
                     PERS(ch, victim)
                  );
               }
               break;
            }
            case (1):
            {
               sprintf
               (
                  buf,
                  "Die, %s you dirty fool!",
                  PERS(ch, victim)
               );
               break;
            }
         }
         sprintf
         (
            log_buf,
            "[%s] dirt kicked [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
         do_myell(victim, buf);
      }

      damage
      (
         ch,
         victim,
         0,
         gsn_dirt,
         DAM_OTHER,
         TRUE
      );

      check_improve
      (
         ch,
         gsn_dirt,
         FALSE,
         2
      );
      WAIT_STATE(ch, skill_table[gsn_dirt].beats);
   }

   check_killer(ch, victim);
}

void do_trip(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   int chance;
   char buf[MAX_STRING_LENGTH];
   OBJ_DATA* obj;
   char* leg;
   char* ankle;
   OBJ_DATA* wield;

   one_argument(argument,arg);

   if
   (
      (chance = get_skill(ch, gsn_trip)) <= 0 ||
      (
         IS_NPC(ch) &&
         !IS_SET(ch->off_flags, OFF_TRIP)
      ) ||
      (
         !IS_NPC(ch) && /* ch->level < skill_table[gsn_trip].skill_level[ch->class]*/
         !has_skill(ch, gsn_trip))
      )
   {
      send_to_char("Tripping?  What's that?\n\r",ch);
      return;
   }

   obj = get_eq_char(ch, WEAR_FEET);
   if (obj == NULL)
   {
      obj = get_eq_char(ch, WEAR_HOOVES);
   }
   if (obj == NULL)
   {
      obj = get_eq_char(ch, WEAR_FOURHOOVES);
   }

   if (obj != NULL)
   {
      if (obj->pIndexData->vnum == OBJ_VNUM_SHACKLES)
      {
         WAIT_STATE(ch, 24);
         send_to_char("You cannot trip anything while in chains!\n\r", ch);
         return;
      }
   }
   if (ch->in_room->sector_type == SECT_UNDERWATER)
   {
      send_to_char("Tripping while underwater accomplishes nothing.\n\r", ch);
      return;
   }

   if (ch->in_room->sector_type == SECT_AIR)
   {
      send_to_char("How do you plan on doing that in midair?\n\r", ch);
      return;
   }
   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }

   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r", ch);
      return;
   }

   if
   (
      ch->in_room->sector_type == SECT_WATER_NOSWIM &&
      IS_AFFECTED(victim, AFF_SWIM)
   )
   {
      send_to_char("How do you trip someone who is swimming?  Is that even possible?\n\r", ch);
      return;
   }

   if
   (
      check_peace(ch) ||
      is_safe(ch, victim, 0)
   )
   {
      return;
   }

   wield = get_eq_char(ch, WEAR_WIELD);
   if
   (
      wield != NULL &&
      wield->value[0] == WEAPON_BOW &&
      !check_tanking(ch) &&
      fire_volley(ch, NULL, TRUE)
   )
   {
      send_to_char("You cannot use close range combat techniques while wielding a ranged weapon.\n\r", ch);
      return;
   }


   if (IS_FLYING(victim))
   {
      act
      (
         "$S feet aren't on the ground.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if
   (
      victim->position < POS_FIGHTING ||
      victim->daze > 0
   )
   {
      act
      (
         "$N is already down.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if (victim == ch)
   {
      send_to_char("You fall flat on your face!\n\r", ch);
      WAIT_STATE(ch,PULSE_VIOLENCE);
      act
      (
         "$n trips over $s own feet!",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      return;
   }

   if
   (
      IS_AFFECTED(ch, AFF_CHARM) &&
      ch->master == victim
   )
   {
      act
      (
         "$N is your beloved master.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /*
   if (is_affected(victim,gsn_phasing) &&
   (number_percent() < (75+((victim->level-ch->level)*2))))
   {
   act("You phase out and $N's trip doesn't affect you.",victim,0,ch,TO_CHAR);
   act("$n phases out and $N's trip doesn't seem to affect him.",victim,0,ch,TO_NOTVICT);
   act("$n phases out and your trip doesn't seem to affect him.",victim,0,ch,TO_VICT);
   WAIT_STATE(ch,2*PULSE_VIOLENCE);
   return;
   }
   */
   /* modifiers */

   /* size */
   if (ch->size < victim->size)
   {
      chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */
   }

   /* dex */
   chance += get_curr_stat(ch,STAT_DEX);
   chance -= get_curr_stat(victim,STAT_DEX) * 3 / 2;

   /* speed */
   if
   (
      IS_SET(ch->off_flags, OFF_FAST) ||
      IS_AFFECTED(ch, AFF_HASTE)
   )
   {
      chance += 10;
   }
   if
   (
      IS_SET(victim->off_flags, OFF_FAST) ||
      IS_AFFECTED(victim, AFF_HASTE)
   )
   {
      chance -= 20;
   }
   if(is_affected(victim, gsn_cloak_form))
   {
      chance+=10;
   }
   if(IS_SET(victim->act, PLR_HONORBOUND))
   {
      chance-=30;
   }

   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level) * 2;


   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   /* now the attack */
   if (victim->race != grn_arborian)
   {
      if (number_bits(1))
      {
         leg = "left leg";
         ankle = "left ankle";
      }
      else
      {
         leg = "right leg";
         ankle = "right ankle";
      }
   }
   else
   {
      leg = "roots";
      ankle = "roots";
   }
   if (number_percent() < chance)
   {
      if (ch->race == grn_arborian)
      {
         switch (number_bits(1))
         {
            case (0):
            {
               act
               (
                  "$n quickly sticks $s roots behind your $t and trips you!",
                  ch,
                  leg,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You quickly stick your roots behind $N's $t and trip $M!",
                  ch,
                  leg,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n quickly sticks $s roots behind $N's $t and trip $M!",
                  ch,
                  leg,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            case (1):
            {
               act
               (
                  "$n grabs your $t with a tendril and trips you!",
                  ch,
                  leg,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N's $t with a tendril and trip $M!",
                  ch,
                  leg,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grab $N's $t with a tendril and trips $M!",
                  ch,
                  leg,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
      }
      else
      {
         switch (number_range(1, 3))
         {
            case (1):
            {
               act
               (
                  "$n quickly sticks $s leg behind your $t and trips you!",
                  ch,
                  leg,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You quickly stick your leg behind $N's $t and trip $M!",
                  ch,
                  leg,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n quickly sticks $s leg behind $N's $t and trips $M!",
                  ch,
                  leg,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            case (2):
            {
               act
               (
                  "$n kicks out your $t and trips you!",
                  ch,
                  leg,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You kick out $N's $t and trip $M!",
                  ch,
                  leg,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n kicks out $N's $t and trips $M!",
                  ch,
                  leg,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            case (3):
            {
               if  (ch->race == grn_draconian)
               {
                  act
                  (
                     "$n whips $s tail out and lashes your $t, tripping you!",
                     ch,
                     ankle,
                     victim,
                     TO_VICT
                  );
                  act
                  (
                     "You whip your tail out and lash $N's $t, tripping $M!",
                     ch,
                     ankle,
                     victim,
                     TO_CHAR
                  );
                  act
                  (
                     "$n whips $s tail out and lashes $N's $t, tripping $M!",
                     ch,
                     ankle,
                     victim,
                     TO_NOTVICT
                  );
                  break;
               }
               else
               {
                  act
                  (
                     "$n hooks your $t with $s foot and trips you!",
                     ch,
                     ankle,
                     victim,
                     TO_VICT
                  );
                  act
                  (
                     "You hook $N's $t with your foot and trip $M!",
                     ch,
                     ankle,
                     victim,
                     TO_CHAR
                  );
                  act
                  (
                     "$n hooks $N's $t with $s foot and trips $M!",
                     ch,
                     ankle,
                     victim,
                     TO_NOTVICT
                  );
                  break;
               }
            }
         }
      }
      check_improve
      (
         ch,
         gsn_trip,
         TRUE,
         1
      );

      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            ch->fighting == NULL ||
            victim->fighting == NULL
         )
      )
      {
         sprintf
         (
            log_buf,
            "[%s] tripped [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
         sprintf
         (
            buf,
            "Help! %s just tripped me!",
            PERS(ch, victim)
         );
         do_myell(victim, buf);
      }
      DAZE_STATE(victim, PULSE_VIOLENCE);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      victim->position = POS_RESTING;
      damage
      (
         ch,
         victim,
         number_range(2, 2 +  2 * victim->size),
         gsn_trip,
         DAM_BASH,
         TRUE
      );
      check_downstrike(ch, victim);
   }
   else
   {
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            ch->fighting == NULL ||
            victim->fighting == NULL
         )
      )
      {
         sprintf
         (
            log_buf,
            "[%s] tripped [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
         sprintf
         (
            buf,
            "Help! %s just tried to trip me!",
            PERS(ch, victim)
         );
         do_myell(victim, buf);
      }
      damage
      (
         ch,
         victim,
         0,
         gsn_trip,
         DAM_BASH,
         TRUE
      );
      WAIT_STATE(ch, PULSE_VIOLENCE);
      check_improve
      (
         ch,
         gsn_trip,
         FALSE,
         1
      );
   }
   check_killer(ch, victim);
}


void do_steel_nerves(CHAR_DATA *ch, char *argument)
{
   AFFECT_DATA af;
   int chance;

   if ( (chance = get_skill(ch,gsn_steel_nerves)) <= 0
   ||  /* (ch->level < skill_table[gsn_steel_nerves].skill_level[ch->class])*/
   !has_skill(ch,gsn_steel_nerves))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (house_down(ch,HOUSE_CRUSADER))
   return;

   if (is_affected(ch,gsn_steel_nerves))
   {
      send_to_char("You feel as invincible as you will ever feel.\n\r",ch);
      return;
   }

   if (ch->mana < 50)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }

   if (!IS_NPC(ch) && (number_percent() > ch->pcdata->learned[gsn_steel_nerves]))
   {
      ch->mana -= 25;
      send_to_char("You try to make yourself feel invincible, but fail.\n\r",ch);
      check_improve(ch,gsn_steel_nerves,FALSE,1);
      return;
   }

   af.where = TO_AFFECTS;
   af.duration = 3 + (ch->drain_level + ch->level)/10;
   af.location = APPLY_MOVE;
   af.level = ch->level + ch->drain_level;
   af.type = gsn_steel_nerves;
   af.bitvector = 0;
   if (ch->level < 30)
   {
      af.location = APPLY_NONE;
      af.modifier = 0;
   }
   else if (ch->level < 40)
   {
      af.modifier = 50;
   }
   else if (ch->level < 50)
   {
      af.modifier = 100;
   }
   else
   {
      af.modifier = 150;
   }
   affect_to_char(ch,&af);
   if (IS_AFFECTED(ch, AFF_SANCTUARY))
   {
      AFFECT_DATA* paf;
      AFFECT_DATA* paf_next;
      /*
      Remove all affects that grant sanctuary, including
      non-gsn_sanctuary affects
      */
      for (paf = ch->affected; paf != NULL; paf = paf_next)
      {
         paf_next = paf->next;
         if (IS_SET(paf->bitvector, AFF_SANCTUARY))
         {
            send_to_char(get_herb_spell_name(paf, FALSE, 0), ch);
            send_to_char("\n\r", ch );
            affect_remove(ch, paf);
         }
      }
   }
   /*
   Case of perma sanc items, probably not needed
   if (IS_AFFECTED(ch, AFF_SANCTUARY))
   {
   REMOVE_BIT(ch->affected_by, AFF_SANCTUARY);
   return;
   }
   */

   send_to_char("You build up an intense mental resolve and prepare for coming battles.\n\r",ch);
   act("$n seems to glower and look deadly.",ch,NULL,NULL,TO_ROOM);
   ch->mana -= 50;
   check_improve(ch,gsn_steel_nerves,TRUE,1);
   return;
}


void do_battlecry( CHAR_DATA *ch, char *argument)
{
   AFFECT_DATA af;
   int chance;

   if ( (chance = get_skill(ch,gsn_battlecry)) <= 0
   || /*  (ch->level < skill_table[gsn_battlecry].skill_level[ch->class]) */
   !has_skill(ch,gsn_battlecry))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (house_down(ch,HOUSE_CRUSADER))
   return;


   if (is_affected(ch,gsn_battlecry))
   {
      send_to_char("You are already as angry as you can be.\n\r",ch);
      return;
   }
   if (ch->mana < 40)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }
   if (!IS_NPC(ch) && (number_percent() > ch->pcdata->learned[gsn_battlecry]))
   {
      send_to_char("You build up your rage but it dies down too fast.\n\r",ch);
      ch->mana -= 20;
      return;
   }

   ch->mana -= 40;
   af.where = TO_AFFECTS;
   af.level = ch->level + ch->drain_level;
   af.duration = (ch->drain_level + ch->level)/2;
   af.type = gsn_battlecry;
   af.modifier = 3;
   af.location = APPLY_HITROLL;
   af.bitvector = 0;
   affect_to_char(ch,&af);

   send_to_char("You are filled with total fury as you let out a battlecry!\n\r",ch);
   act("$n lets out a chilling battlecry and begins frothing at the mouth.",ch,NULL,NULL,TO_ROOM);
   return;
}

void do_whirlwind(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *vch;
   CHAR_DATA *vch_next;
   int startoff = FALSE;
   int chance;
   char buf[MAX_STRING_LENGTH];

   if ( IS_NPC(ch) )
   return;

   if ( (chance = get_skill(ch,gsn_whirlwind)) <= 0 || !has_skill(ch,gsn_whirlwind) )
   {
      send_to_char("You have not mastered that technique.\n\r", ch);
      return;
   }

   if (check_peace(ch)) return;

   if ( house_down(ch,HOUSE_CRUSADER) )
   return;

   /* This segment counts people in the room.  It ignores people out of PK and
   * MOBs less than 2/3 the whirlers level.  Other than that, everyone with the
   * whirler counts as a friend (other Crusaders count as 1) and everyone NOT
   * grouped counts as a foe.  If there are more foes than friends, whirl is
   * allowed, otherwise, it is not, and a small wait_state is applied.
   */

   /* Now for the attack itself */
   if( number_percent() < chance)
   {
      send_to_char("You spin into action, lashing out with a series of powerful strikes!\n\r",ch);
      act("$n lashes out with a deadly flurry of blows!",ch,NULL,NULL,TO_ROOM);
      if (ch->fighting == NULL) startoff = TRUE;
      for(vch=ch->in_room->people; vch!=NULL;vch=vch_next)
      {
         vch_next=vch->next_in_room;
         chance = number_percent();

         if
         (
            vch->fighting != ch &&
            (
               (
                  get_trust(ch) < vch->invis_level
               ) ||
               is_safe
               (
                  ch,
                  vch,
                  IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK
               ) ||
               is_same_group(ch,vch)
            )
         )
         continue;

         if (!startoff && vch->fighting != ch)
         continue;

         if (oblivion_blink(ch, vch))
         {
            continue;
         }
         if(  !IS_NPC(ch) && !IS_NPC(vch)
         && (ch->fighting == NULL || vch->fighting == NULL))
         {
            switch(number_range(0,2))
            {
               case (0):
               sprintf(buf,"Argh, %s is attacking like a whirlwind!",PERS(ch,vch));
               break;
               case (1):
               case (2):
               sprintf(buf,"Help! %s just attacked me!",PERS(ch,vch));
            }
            if (vch != ch)
            {
               do_myell(vch,buf);
               sprintf(log_buf, "[%s] whirlwinded [%s] at %d", ch->name, vch->name,
               ch->in_room->vnum);
               log_string(log_buf);
            }
         }

         one_hit(ch,vch,gsn_whirlwind);

         if( ch->class == CLASS_MONK )
         {
            if( chance < get_skill(ch,gsn_second_attack)/3 )
            {
               one_hit(ch,vch,gsn_whirlwind);
               check_improve(ch,gsn_second_attack,TRUE,3);
            }
            else check_improve(ch,gsn_second_attack,FALSE,3);
         }
         else
         if (get_eq_char(ch,WEAR_DUAL_WIELD) != NULL)
         {
            if( chance < get_skill(ch,gsn_dual_wield)/3)
            {
               one_hit(ch,vch,gsn_whirlwind);
               check_improve(ch,gsn_dual_wield,TRUE,3);
            }
            else check_improve(ch,gsn_dual_wield,FALSE,3);
         }
      }
      check_improve(ch,gsn_whirlwind,TRUE,1);
      WAIT_STATE(ch,skill_table[gsn_whirlwind].beats);
   }
   else
   {
      send_to_char("You leap to action, but stumble before you strike anyone!\n\r",ch);
      act("$n leaps into action, but clumsily stumbles.",ch,NULL,NULL,TO_ROOM);
      check_improve(ch,gsn_whirlwind,FALSE,1);
      WAIT_STATE(ch,(skill_table[gsn_whirlwind].beats)/2);
   }
   return;
}

void do_hit( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;

   one_argument( argument, arg );

   if ( ch->position != POS_FIGHTING )
   {
      send_to_char( "You're not fighting anyone.\n\r", ch );
      return;
   }

   if ( arg[0] == '\0' )
   {
      send_to_char( "Switch targets to whom?\n\r", ch );
      return;
   }

   if ( ( victim = get_char_room( ch, arg ) ) == NULL )
   {
      send_to_char( "They aren't here.\n\r", ch );
      return;
   }

   if ( victim == ch )
   {
      send_to_char( "Are you crazy?\n\r", ch );
      return;
   }

   if ( victim->fighting != ch )
   {
      send_to_char( "That person isn't fighting you.\n\r", ch );
      return;
   }

   act( "You switch your focus and target $N.", ch, NULL, victim, TO_CHAR );
   ch->fighting = victim;
   return;
}

void do_kill( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;

   one_argument( argument, arg );

   if ( arg[0] == '\0' )
   {
      send_to_char( "Kill whom?\n\r", ch );
      return;
   }

   if ( ( victim = get_char_room( ch, arg ) ) == NULL )
   {
      send_to_char( "They aren't here.\n\r", ch );
      return;
   }

   if (check_peace(ch)) return;

   /*  Allow player killing   */
   if ( !IS_NPC(victim) )
   {
      send_to_char( "You must MURDER a player.\n\r", ch );
      return;
   }
   if ( victim == ch )
   {
      send_to_char( "You hit yourself.  Ouch!\n\r", ch );
      multi_hit( ch, ch, TYPE_UNDEFINED );
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
   {
      act( "$N is your beloved master.", ch, NULL, victim, TO_CHAR );
      return;
   }

   if( ch->fighting == victim )
   {
      send_to_char( "You do the best you can!\n\r", ch );
      return;
   }

   WAIT_STATE( ch, 1 * PULSE_VIOLENCE );

   if( ch->fighting != NULL )
   {
      if( victim->fighting == NULL )
      {
         one_hit( ch, victim, TYPE_UNDEFINED );
      } else
      {
         send_to_char( "You're both too busy to fight each other.\n\r", ch );
      }
      return;
   }
   check_perception(ch, victim, "attacking a charmed follower");
   multi_hit( ch, victim, TYPE_UNDEFINED );
   return;
}



void do_murde( CHAR_DATA *ch, char *argument )
{
   send_to_char( "If you want to MURDER, spell it out.\n\r", ch );
   return;
}



void do_murder( CHAR_DATA *ch, char *argument )
{
   char buf[MAX_STRING_LENGTH];
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   bool extra = FALSE;

   one_argument( argument, arg );

   if ( arg[0] == '\0' )
   {
      send_to_char( "Murder whom?\n\r", ch );
      return;
   }

   if (IS_AFFECTED(ch,AFF_CHARM) || (IS_NPC(ch) && IS_SET(ch->act,ACT_PET)))
   return;

   if ( ( victim = get_char_room( ch, arg ) ) == NULL )
   {
      send_to_char( "They aren't here.\n\r", ch );
      return;
   }

   if (check_peace(ch)) return;

   if ( victim == ch )
   {
      send_to_char( "Suicide is a mortal sin.\n\r", ch );
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
   {
      act( "$N is your beloved master.", ch, NULL, victim, TO_CHAR );
      return;
   }

   if ( ch->fighting == victim )
   {
      send_to_char( "You do the best you can!\n\r", ch );
      return;
   }

   WAIT_STATE( ch, 1 * PULSE_VIOLENCE );

   if( ch->fighting )
   {
      if( !victim->fighting )
      {
         extra = TRUE;
      } else
      {
         send_to_char( "You're both too busy to fight each other.\n\r", ch );
         return;
      }
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }
   if (IS_NPC(ch))
   sprintf(buf, "Help! I am being attacked by %s!", PERS(ch, victim));
   else
   {
      switch(number_range(1,8))
      {
         /* In each case, get_longname was changed to PERS - Cirdan */
         case (1):
         sprintf(buf, "Help!  I am being attacked by %s!",PERS(ch,victim));
         break;
         case (2):
         sprintf(buf, "Die %s, you tactless killer!", PERS(ch,victim));
         break;
         case (3):
         sprintf(buf, "Help!  %s is attacking me!", PERS(ch,victim));
         break;
         case (4):
         sprintf(buf, "Help!  Save me from %s!", PERS(ch,victim));
         break;
         case (5):
         sprintf(buf, "How dare you attack me %s!", PERS(ch,victim));
         break;
         case (6):
         sprintf(buf, "Damn!  %s is hurting me!",PERS(ch,victim));
         break;
         case (7):
         sprintf(buf, "Die %s, you annoying swine!",PERS(ch,victim));
         break;
         case (8):
         sprintf(buf, "%s!  Prepare to die!", PERS(ch,victim));
         break;
      }
   }
   do_myell( victim, buf );
   if (!IS_NPC(victim))
   {
      sprintf(log_buf, "[%s] murdered [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }

   if( extra )
   {
      one_hit( ch, victim, TYPE_UNDEFINED );
      return;
   }

   multi_hit( ch, victim, TYPE_UNDEFINED );
   return;
}


void do_ambush( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   char buf[MAX_STRING_LENGTH];
   int chance;

   if ( (get_skill(ch,gsn_ambush) <= 0)
   || !has_skill(ch,gsn_ambush) )
   {
      send_to_char("You don't know how to properly ambush someone.\n\r", ch );
      return;
   }

   one_argument( argument, arg);
   if (arg[0] == '\0')
   {
      send_to_char("Ambush whom?\n\r",ch);
      return;
   }

   if (ch->fighting != NULL)
   {
      send_to_char("But you're still fighting!\n\r",ch);
      return;
   }
   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   else if (!IS_AFFECTED(ch, AFF_CAMOUFLAGE) || can_see(victim, ch) )
   {
      send_to_char("But they can still see you.\n\r",ch);
      return;
   }

   if ( victim == ch )
   {
      send_to_char("That's just not possible.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   chance = get_skill(ch,gsn_moving_ambush);
   if (victim->fighting != NULL
   && ( chance < 1
   || /*ch->level < skill_table[gsn_moving_ambush].skill_level[ch->class]*/
   !has_skill(ch,gsn_moving_ambush)))
   {
      send_to_char("They are moving around too much to ambush.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (is_affected(victim,gsn_halo_of_eyes) && can_see(victim,ch) &&
   number_percent() < 30)
   {
      send_to_char("You notice one of the eyes surrounding them looking straight at you!\n\r",ch);
      chance = 0;
   }

   if (victim->fighting != NULL)
   {
      if (number_percent() >= chance)
      {
         send_to_char("You can't quite pin them down for your ambush.\n\r",ch);
         check_improve(ch,gsn_moving_ambush,FALSE,1);
         return;
      } else
      {
         check_improve(ch,gsn_moving_ambush,TRUE,1);
      }
   }

   if (!IS_NPC(ch) && !IS_NPC(victim) && (victim->fighting == NULL ||
   victim->fighting->master != ch))
   {
      sprintf(buf,"Help! I've been ambushed by %s!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] ambushed [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }

   WAIT_STATE( ch, skill_table[gsn_ambush].beats );
   if ( (number_percent( ) < get_skill(ch, gsn_ambush) )
   || ( get_skill(ch,gsn_ambush) >= 2 && !IS_AWAKE(victim) ) )
   {
      check_improve(ch,gsn_ambush, TRUE,1);
      multi_hit( ch, victim, gsn_ambush );
   }
   else
   {
      check_improve(ch,gsn_ambush, FALSE,1);
      damage( ch, victim, 0, gsn_ambush, DAM_OTHER, TRUE);
   }

   return;
}


void do_backstab( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   OBJ_DATA *obj;
   int dam;
   char buf[MAX_STRING_LENGTH];

   one_argument( argument, arg );


   if ( (get_skill(ch,gsn_backstab) <= 0 )
   || /*ch->level < skill_table[gsn_backstab].skill_level[ch->class]*/
   !has_skill(ch,gsn_backstab))
   {
      if (!IS_NPC(ch))
      {
         send_to_char("You don't know how to backstab.\n\r",ch);
         return;
      }
   }

   if (arg[0] == '\0')
   {
      send_to_char("Backstab whom?\n\r",ch);
      return;
   }

   if (ch->fighting != NULL)
   {
      send_to_char("You're facing the wrong end.\n\r",ch);
      return;
   }

   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if ( victim == ch )
   {
      send_to_char( "How can you sneak up on yourself?\n\r", ch );
      return;
   }


   if ( ( obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL)
   {
      send_to_char( "You need to wield a weapon to backstab.\n\r", ch );
      return;
   }

   if ( obj->value[0] != 2 )
   {
      send_to_char( "You must wield a dagger to backstab.\n\r", ch );
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if ( victim->fighting != NULL )
   {
      send_to_char( "That person is moving around too much to backstab.\n\r", ch );
      return;
   }

   if ( victim->hit < victim->max_hit*9/10)
   {
      act( "$N is hurt and suspicious ... you can't sneak up.",
      ch, NULL, victim, TO_CHAR );
      return;
   }

   WAIT_STATE( ch, skill_table[gsn_backstab].beats );

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (is_affected(victim,gsn_halo_of_eyes) && can_see(victim,ch) &&
   number_percent() < 30)
   {
      send_to_char("You notice one of the eyes surrounding them looking straight at you!\n\r",ch);
      check_improve(ch,gsn_backstab,FALSE,1);
      if (!IS_NPC(ch) && !IS_NPC(victim) && victim->fighting == NULL)
      {
         switch(number_range(0,1))
         {
            case (0):
            sprintf(buf,"Die, %s you backstabbing fool!",PERS(ch,victim));
            break;
            case (1):
            sprintf(buf,"Help! I'm being backstabbed by %s!",PERS(ch,victim));
            break;
         }
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] backstabbed [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }


      damage( ch, victim, 0, gsn_backstab,DAM_OTHER,TRUE);
      return;
   }

   if ( number_percent( ) < get_skill(ch,gsn_backstab)
   || ( get_skill(ch,gsn_backstab) >= 2 && !IS_AWAKE(victim) ) )
   {
      check_improve(ch,gsn_backstab,TRUE,1);
      if (!IS_NPC(ch) && !IS_NPC(victim) && victim->fighting == NULL)
      {
         switch(number_range(0,1))
         {
            case (0):
            sprintf(buf,"Die, %s you backstabbing fool!",PERS(ch,victim));
            break;
            case (1):
            sprintf(buf,"Help! I'm being backstabbed by %s!",PERS(ch,victim));
            break;
         }
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] backstabbed [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }


      one_hit( ch, victim, gsn_backstab );
   }
   else
   {
      check_improve(ch,gsn_backstab,FALSE,1);
      if (!IS_NPC(ch) && !IS_NPC(victim) && victim->fighting == NULL)
      {
         switch(number_range(0,1))
         {
            case (0):
            sprintf(buf,"Die, %s you backstabbing fool!",PERS(ch,victim));
            break;
            case (1):
            sprintf(buf,"Help! I'm being backstabbed by %s!",PERS(ch,victim));
            break;
         }
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] backstabbed [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }


      damage( ch, victim, 0, gsn_backstab,DAM_OTHER,TRUE);
   }


   if (get_skill(ch, gsn_dual_backstab) < 1 ||
   !has_skill(ch,gsn_dual_backstab))
   return;

   if (number_range(0,3) == 0)
   {
      if (get_skill(ch,gsn_dual_backstab) != 100)
      check_improve(ch,gsn_dual_backstab,FALSE,1);
      return;
   }

   if (number_percent() > (get_skill(ch,gsn_dual_backstab) + ch->level - victim->level) )
   {
      check_improve(ch,gsn_dual_backstab,FALSE,1);
      dam  = 0;
   }
   else
   {
      dam = dice(obj->value[1], obj->value[2]) * get_skill(ch,gsn_dual_backstab)/100;
      if ((ch->drain_level + ch->level) < 35)     dam *= number_range(2,4);
      else if ((ch->drain_level + ch->level) < 40)     dam *= number_range(2,5);
      else if ((ch->drain_level + ch->level) < 45)    dam *= number_range(3,5);
      else if ((ch->drain_level + ch->level) < 50)    dam *= number_range(4,6);
      else dam *= number_range(4,7);
      dam += (ch->damroll * get_skill(ch,gsn_dual_backstab)/100);
   }
   dam *= battlecry_multiplier(ch,victim,gsn_dual_backstab);
   damage(ch,victim,dam,gsn_dual_backstab,attack_table[obj->value[3]].damage,TRUE);

   return;
}

void do_rescue( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   CHAR_DATA *fch;

   if ( (get_skill(ch,gsn_rescue)) <= 0
   ||   (!IS_NPC(ch)
   && /* ch->level < skill_table[gsn_rescue].skill_level[ch->class]*/
   !has_skill(ch,gsn_rescue)))
   {
      send_to_char("Your thoughts are noble, but you cannot bring yourself to do it.\n\r",ch);
      return;
   }

   one_argument( argument, arg );
   if ( arg[0] == '\0' )
   {
      send_to_char( "Rescue whom?\n\r", ch );
      return;
   }

   if ( ( victim = get_char_room( ch, arg ) ) == NULL )
   {
      send_to_char( "They aren't here.\n\r", ch );
      return;
   }

   if (check_peace(ch)) return;

   if ( victim == ch )
   {
      send_to_char( "What about fleeing instead?\n\r", ch );
      return;
   }

   if ( !IS_NPC(ch) && IS_NPC(victim) )
   {
      send_to_char( "Doesn't need your help!\n\r", ch );
      return;
   }

   /*
   if ( ch->fighting == victim )
   {
   send_to_char( "Too late.\n\r", ch );
   return;
   }
   */
   if ( ( fch = victim->fighting ) == NULL )
   {
      send_to_char( "That person is not fighting right now.\n\r", ch );
      return;
   }
   /*
   if (is_safe(ch,victim))
   return;
   */

   if (is_safe(ch, victim->fighting, 0))
   {
      return;
   }

   if(IS_NPC(victim->fighting) && victim->fighting->house != 0) {
      return;
   }

   WAIT_STATE( ch, skill_table[gsn_rescue].beats );
   if ( number_percent( ) > get_skill(ch,gsn_rescue))
   {
      send_to_char( "You fail the rescue.\n\r", ch );
      check_improve(ch,gsn_rescue,FALSE,1);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   WAIT_STATE(victim,12);
   act( "You rescue $N!",  ch, NULL, victim, TO_CHAR    );
   act( "$n rescues you!", ch, NULL, victim, TO_VICT    );
   act( "$n rescues $N!",  ch, NULL, victim, TO_NOTVICT );
   check_improve(ch,gsn_rescue,TRUE,1);

   stop_fighting( fch, FALSE );
   stop_fighting( victim, FALSE );

   set_fighting( ch, fch );
   set_fighting( fch, ch );
   return;
}



void do_kick(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* victim;
   int dam;
   int jump_skill;
   int bonus;
   OBJ_DATA* obj;
   OBJ_DATA* wield;

   if
   (
      (get_skill(ch, gsn_kick) <= 0) ||
      !has_skill(ch, gsn_kick)
   )
   {
      send_to_char("You better leave the martial arts to fighters.\n\r", ch );
      return;
   }

   wield = get_eq_char(ch, WEAR_WIELD);
   if
   (
      wield != NULL &&
      wield->value[0] == WEAPON_BOW &&
      !check_tanking(ch) &&
      fire_volley(ch, NULL, TRUE)
   )
   {
      send_to_char("You cannot use close range combat techniques while wielding a ranged weapon.\n\r", ch);
      return;
   }

   if
   (
      IS_NPC(ch) &&
      !IS_SET(ch->off_flags, OFF_KICK)
   )
   {
      return;
   }

   if
   (
      (victim = ch->fighting) == NULL
   )
   {
      send_to_char("You aren't fighting anyone.\n\r", ch);
      return;
   }

   WAIT_STATE(ch, skill_table[gsn_kick].beats);
   obj = get_eq_char(ch, WEAR_FEET);
   if (obj == NULL)
   {
      obj = get_eq_char(ch, WEAR_HOOVES);
   }
   if (obj == NULL)
   {
      obj = get_eq_char(ch, WEAR_FOURHOOVES);
   }
   if (obj != NULL)
   {
      if (obj->pIndexData->vnum == OBJ_VNUM_SHACKLES)
      {
         send_to_char("You can't kick anything while in chains!\n\r",ch);
         return;
      }
   }

   if (get_skill(ch, gsn_kick) > number_percent())
   {
      dam = (ch->drain_level + ch->level)/2;
      dam += number_range(0, (ch->drain_level + ch->level)/6);
      dam += number_range(0, (ch->drain_level + ch->level)/6);
      dam += number_range(0, (ch->drain_level + ch->level)/6);
      dam += number_range(0, (ch->drain_level + ch->level)/6);
      dam += number_range(0, (ch->drain_level + ch->level)/6);
      dam += number_range(0, (ch->drain_level + ch->level)/6);
      dam += number_range(ch->level/5, ch->level/4);

      if (!IS_NPC(ch))
      {
         if (!str_cmp(class_table[ch->class].name, "channeler"))
         if (!str_cmp(class_table[ch->class].name, "necromancer"))
         if (!str_cmp(class_table[ch->class].name, "elementalist"))
         {
            dam *= 3;
            dam /= 4;
         }
      }

      if
      (
         (jump_skill = get_skill(ch, gsn_jump_kick)) > 0 &&
         has_skill(ch, gsn_jump_kick) &&
         (
            ch->in_room->sector_type != SECT_AIR &&
            ch->in_room->sector_type != SECT_UNDERWATER
         )
      )
      {
         if(number_percent() < (UMAX(5, jump_skill-20)))
         {
            switch(number_range(1,4))
            {
               case(1):
               {
                  if (victim->race == grn_arborian)
                  {
                     act
                     (
                        "You leap into the air and kick $N in the cornstalk with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_CHAR
                     );
                     act
                     (
                        "$n leaps into the air and kicks you in the cornstalk with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_VICT
                     );
                     act
                     (
                        "$n leaps into the air and kicks $N in the cornstalk with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_NOTVICT
                     );
                  }
                  else
                  {
                     act
                     (
                        "You leap into the air and kick $N in the head with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_CHAR
                     );
                     act
                     (
                        "$n leaps into the air, striking you with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_VICT
                     );
                     act
                     (
                        "$n leaps into the air, striking $N with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_NOTVICT
                     );
                  }
                  break;
               }
               case(2):
               {
                  if (victim->race == grn_arborian)
                  {
                     act
                     (
                        "You leap into the air and kick $N in the trunk with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_CHAR
                     );
                     act
                     (
                        "$n leaps into the air and kicks you in the trunk with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_VICT
                     );
                     act
                     (
                        "$n leaps into the air and kicks $N in the trunk with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_NOTVICT
                     );
                  }
                  else
                  {
                     act
                     (
                        "You leap into the air and kick $N under the chin with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_CHAR
                     );
                     act
                     (
                        "$n leaps into the air and kicks you under the chin with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_VICT
                     );
                     act
                     (
                        "$n leaps into the air and kicks $N under the chin with a powerful jump kick!",
                        ch,
                        NULL,
                        victim,
                        TO_NOTVICT
                     );
                  }
                  break;
               }
               case(3):
               {
                  act
                  (
                     "You leap into the air and do a backflip, striking $N with a powerful kick!",
                     ch,
                     NULL,
                     victim,
                     TO_CHAR
                  );
                  act
                  (
                     "$n leaps into the air and does a backflip, striking you with a powerful kick!",
                     ch,
                     NULL,
                     victim,
                     TO_VICT
                  );
                  act
                  (
                     "$n leaps into the air and does a backflip, striking $N with a powerful kick!",
                     ch,
                     NULL,
                     victim,
                     TO_NOTVICT
                  );
                  break;
               }
               case(4):
               {
                  act
                  (
                     "You leap into the air and fly sideways at $N, striking $M with a powerful jump kick!",
                     ch,
                     NULL,
                     victim,
                     TO_CHAR
                  );
                  act
                  (
                     "$n leaps into the air and flies sideways at you, striking you with a powerful jump kick!",
                     ch,
                     NULL,
                     victim,
                     TO_VICT
                  );
                  act
                  (
                     "$n leaps into the air and flies sideways at $N, striking $M with a powerful jump kick!",
                     ch,
                     NULL,
                     victim,
                     TO_NOTVICT
                  );
                  break;
               }
            }



            bonus = ( (ch->level * 2) / 4 );
            bonus += ( (jump_skill * 3) / 4 );
            dam += (dam*bonus)/100;

            check_improve(ch,gsn_jump_kick,TRUE,4);

            if(number_percent() < (jump_skill / 3))
            {
               act
               (
                  "$N sprawls backward from the force of your kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "You sprawl backward from the force of $n's kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$N sprawls backward from the force of $n's kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               WAIT_STATE(victim, (skill_table[gsn_kick].beats*3/4));
            }
         }
         else
         {
            check_improve
            (
               ch,
               gsn_jump_kick,
               FALSE,
               4
            );
         }
      }

      switch(number_range(1,5))
      {
         case(1):
         {
            if
            (
               ch->class == CLASS_MONK ||
               (
                  ch->class == CLASS_THIEF &&
                  ch->pcdata->special == SUBCLASS_NINJA
               )
            )
            {
               act
               (
                  "You strike $N with a powerful side kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n strikes you with a powerful side kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n strikes $N with a powerful side kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "You rear back and strike $N with a powerful low kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n rears back and strikes you with a powerful low kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n rears back and strikes $N with a powerful low kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(2):
         {
            if
            (
               ch->class == CLASS_MONK ||
               (
                  ch->class == CLASS_THIEF &&
                  ch->pcdata->special == SUBCLASS_NINJA
               )
            )
            {
               act
               (
                  "You turn around and strike $N with a deadly back kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n turns around and strikes you with a deadly back kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n turns around and strikes $N with a deadly back kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "You raise your leg and kick $N with your heel!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n raises $s leg and kicks you with $s heel!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n raises $s leg and kicks $N with $s heel!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(3):
         {
            if
            (
               ch->class == CLASS_MONK ||
               (
                  ch->class == CLASS_THIEF &&
                  ch->pcdata->special == SUBCLASS_NINJA
               )
            )
            {
               act
               (
                  "You attack $N with a quick front snap kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n attacks you with a quick front snap kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n attacks $N with a quick front snap kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "You rear back and kick out at $N!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n rears back and kicks out at you!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n rears back and kicks out at $N!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(4):
         {
            if
            (
               ch->class == CLASS_MONK ||
               (
                  ch->class == CLASS_THIEF &&
                  ch->pcdata->special == SUBCLASS_NINJA
               )
            )
            {
               act
               (
                  "You attack $N with a spinning back kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n attacks you with a spinning back kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n attacks $N with a spinning back kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "You attack $N with a stomp kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n attacks you with a stomp kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n attacks $N with a stomp kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(5):
         {
            if
            (
               ch->class == CLASS_MONK ||
               (
                  ch->class == CLASS_THIEF &&
                  ch->pcdata->special == SUBCLASS_NINJA
               )
            )
            {
               act
               (
                  "You lash out at $N with an inside crescent kick!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n lashes out at you with an inside crescent kick!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$n lashes out at $N with an inside crescent kick!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               if (victim->race == grn_arborian)
               {
                  act
                  (
                     "You strike at $N's trunk with a heel kick!",
                     ch,
                     NULL,
                     victim,
                     TO_CHAR
                  );
                  act
                  (
                     "$n strikes at your trunk with a heel kick!",
                     ch,
                     NULL,
                     victim,
                     TO_VICT
                  );
                  act
                  (
                     "$n strikes at $N's trunk with a heel kick!",
                     ch,
                     NULL,
                     victim,
                     TO_NOTVICT
                  );
                  break;
               }
               else
               {
                  act
                  (
                     "You strike at $N's torso with a heel kick!",
                     ch,
                     NULL,
                     victim,
                     TO_CHAR
                  );
                  act
                  (
                     "$n strikes at your torso with a heel kick!",
                     ch,
                     NULL,
                     victim,
                     TO_VICT
                  );
                  act
                  (
                     "$n strikes at $N's torso with a heel kick!",
                     ch,
                     NULL,
                     victim,
                     TO_NOTVICT
                  );
                  break;
               }
            }
         }
      }
      dam *= battlecry_multiplier(ch, victim, gsn_kick);
      if (ch->in_room->sector_type == SECT_UNDERWATER)
      {
         dam = dam /2;
      }
      damage
      (
         ch,
         victim,
         dam,
         gsn_kick,
         DAM_BASH,
         TRUE
      );
      check_improve
      (
         ch,
         gsn_kick,
         TRUE,
         1
      );
      check_follow_through(ch, victim, dam);
   }
   else
   {
      damage
      (
         ch,
         victim,
         0,
         gsn_kick,
         DAM_BASH,
         TRUE
      );
      check_improve(ch, gsn_kick, FALSE,1);
   }
   check_killer(ch, victim);
   return;
}

void do_knockdown( CHAR_DATA *ch, char *argument )
{
   CHAR_DATA *victim;
   int dam;

   if ((get_skill(ch,gsn_knockdown) <= 0) || !has_skill(ch,gsn_knockdown))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if ( ( victim = ch->fighting ) == NULL )
   {
      send_to_char( "You aren't fighting anyone.\n\r", ch );
      return;
   }

   if (number_percent() > get_skill(ch,gsn_knockdown)){
      send_to_char("You fail to knock them down.\n\r",ch);
      check_improve(ch,gsn_knockdown, FALSE,1);
      return;
   }
   /* the damage */

   act("You knock $N to the ground!",ch,NULL,victim,TO_CHAR);
   act("$n knocks you to the ground!",ch,NULL,victim,TO_VICT);
   act("$n knocks $N to the ground!",ch,NULL,victim,TO_NOTVICT);
   dam = number_range(ch->level * 3/2, ch->level*2);


   /* the bash */
   if (number_percent() < get_skill(ch,gsn_knockdown)*2/3){
      if (victim->daze == 0)
      DAZE_STATE(victim,20);
   }

   /* critical hit */
   if (number_percent() < 8)
   {
      send_to_char("You land a critical hit while they are on the ground!\n\r",ch);
      dam *= (ch->level/15);
   } else
   dam *= battlecry_multiplier(ch, victim, gsn_knockdown);

   damage(ch,victim,dam, gsn_knockdown,DAM_BASH,TRUE);

   if (ch->fighting == victim)
   check_ground_control(ch,victim,get_skill(ch,gsn_knockdown)*2/3,dam);

   check_improve(ch,gsn_knockdown, TRUE,1);
   WAIT_STATE(ch, 24);
   return;
}


void do_pounce( CHAR_DATA *ch, char *argument )
{
   CHAR_DATA *victim;
   OBJ_DATA *obj = NULL;
   int dam;

   if ((get_skill(ch,gsn_pouncing_tiger)) <= 0 ||!has_skill(ch,gsn_pouncing_tiger))
   {
      send_to_char( "Huh?\n\r", ch );
      return;
   }


   if ( ( victim = ch->fighting ) == NULL )
   {
      send_to_char( "You aren't fighting anyone.\n\r", ch );
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (number_percent() > get_skill(ch,gsn_pouncing_tiger)){
      WAIT_STATE(ch,24);
      send_to_char("You fail to pounce.\n\r",ch);
      check_improve(ch,gsn_pouncing_tiger, FALSE,1);
      return;
   }


   /* the damage */

   act("You crouch, then leap in a mighty pounce!",ch,NULL,victim,TO_CHAR);
   act("$n crouches and lands on you with a mighty pounce!",ch,NULL,victim,TO_VICT);
   act("$n crouches and leaps into a mighty pounce landing on $N!",ch,NULL,victim,TO_NOTVICT);
   dam = ch->level*2 + (number_range(0,ch->level))*3/2;
   dam *= battlecry_multiplier(ch, victim, gsn_pouncing_tiger);
   damage(ch,victim,dam, gsn_pouncing_tiger,DAM_BASH,TRUE);


   /* the bash */
   if (victim->daze == 0)
   if (number_percent() < get_skill(ch,gsn_pouncing_tiger)/2){
      send_to_char("Your pounce knocks them from their feet!\n\r",ch);
      send_to_char("The pounce knocks you from your feet!\n\r",victim);
      DAZE_STATE(victim,20);
   }

   /* the disarm */

   if (number_percent() < get_skill(ch,gsn_pouncing_tiger)/4)
   {
      if ( ( obj = get_eq_char( victim, WEAR_WIELD ) ) != NULL ){
         send_to_char("Your pounce knocks the weapon from their hand!\n\r",ch);
         disarm( ch, victim );
      }
   }

   check_improve(ch,gsn_pouncing_tiger, TRUE,1);
   WAIT_STATE(ch, 24);
   return;
}


void do_disarm(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* victim;
   OBJ_DATA* obj;
   int chance;
   int hth;
   int ch_weapon;
   int vict_weapon;
   int ch_vict_weapon;

   hth = 0;

   if ((chance = get_skill(ch, gsn_disarm)) <= 0)
   {
      send_to_char("You don't know how to disarm opponents.\n\r", ch);
      return;
   }

   if
   (
      get_eq_char(ch, WEAR_WIELD) == NULL &&
      (
         (hth = get_skill(ch, gsn_hand_to_hand)) <= 0 ||
         (
            IS_NPC(ch) &&
            !IS_SET(ch->off_flags, OFF_DISARM)
         )
      )
   )
   {
      send_to_char("You must wield a weapon to disarm.\n\r", ch);
      return;
   }

   if ((victim = ch->fighting) == NULL)
   {
      send_to_char("You aren't fighting anyone.\n\r", ch);
      return;
   }

   if ((obj = get_eq_char(victim, WEAR_WIELD)) == NULL)
   {
      send_to_char( "Your opponent is not wielding a weapon.\n\r", ch );
      return;
   }

   /* find weapon skills */
   ch_weapon = get_weapon_skill(ch, get_weapon_sn(ch));
   vict_weapon = get_weapon_skill(victim, get_weapon_sn(victim));
   ch_vict_weapon = get_weapon_skill(ch, get_weapon_sn(victim));

   /* modifiers */
   /*    chance *= 6;
   chance /=10;*/

   /* skill */
   if ( get_eq_char(ch, WEAR_WIELD) == NULL)
   {
      chance = chance * hth/150;
   }
   else
   {
      chance = chance * ch_weapon/100;
   }

   chance += (ch_vict_weapon/2 - vict_weapon) / 2;

   /* dex vs. strength */
   chance += get_curr_stat(ch,STAT_DEX);
   chance -= 2 * get_curr_stat(victim,STAT_STR);
   if (check_two_hand_wield(victim))
   {
      chance -= 2 * get_curr_stat(victim, STAT_STR);
   }


   /* level */
   chance += (ch->drain_level + ch->level - victim->drain_level - victim->level) * 2;

   /* and now the attack */
   if (number_percent() < chance)
   {
      WAIT_STATE(ch, skill_table[gsn_disarm].beats);
      disarm(ch, victim);
      check_improve
      (
         ch,
         gsn_disarm,
         TRUE,
         1
      );
   }
   else
   {
      WAIT_STATE(ch, skill_table[gsn_disarm].beats);
      act
      (
         "You fail to disarm $N.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n tries to disarm you, but fails.",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n tries to disarm $N, but fails.",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      check_improve
      (
         ch,
         gsn_disarm,
         FALSE,
         1
      );
   }
   check_killer(ch, victim);
   return;
}


void do_circle_stab(CHAR_DATA* ch, char* argument)
{
   bool attempt_dual;
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   CHAR_DATA* v_check;
   CHAR_DATA* v_next;
   OBJ_DATA* obj;
   int chance;
   int dam;
   int dam_type;

   attempt_dual = FALSE;
   one_argument(argument, arg);

   if ( (chance = get_skill(ch,gsn_circle)) <= 0
   ||  IS_NPC(ch)
   ||  (!IS_NPC(ch) && /*ch->level < skill_table[gsn_circle].skill_level[ch->class]*/ !has_skill(ch,gsn_circle)) )
   {
      send_to_char("Circling? What's that?\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone.\n\r",ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (ch->fighting == NULL)
   {
      send_to_char("You can't circle someone like that.\n\r",ch);
      return;
   }


   for (v_check = ch->in_room->people; v_check != NULL; v_check = v_next)
   {
      v_next = v_check->next_in_room;

      if (v_check->fighting == ch)
      {
         send_to_char("Not while you're defending yourself!\n\r",ch);
         return;
      }
   }

   if (victim == ch)
   {
      send_to_char("huh?\n\r", ch);
      return;
   }

   if (check_peace(ch)) return;

   obj = get_eq_char(ch,WEAR_WIELD);
   if (obj == NULL || obj->value[0] != WEAPON_DAGGER)
   {
      attempt_dual = TRUE;
      obj = get_eq_char(ch,WEAR_DUAL_WIELD);
   }

   if (obj == NULL)
   {
      send_to_char("You must wield a dagger to circle stab.\n\r",ch);
      return;
   }

   if (obj->value[0] != 2)
   {
      send_to_char("You must wield a dagger to circle stab.\n\r",ch);
      return;
   }
   dam_type = attack_table[obj->value[3]].damage;

   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);
   chance = URANGE(5, chance, 95);

   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   WAIT_STATE(ch,skill_table[gsn_circle].beats);

   if (number_percent() < chance)
   {
      act("You circle around $N to land a critical strike.",ch,NULL,victim,TO_CHAR);
      act("$n cirlces around you to land a critical strike.",ch,NULL,victim,TO_VICT);
      act("$n circles $N to land a critical strike.",ch,NULL,victim,TO_NOTVICT);
      check_improve(ch,gsn_circle,TRUE,1);
      dam = dice(obj->value[1],obj->value[2]);
      dam += 40;

      if ((ch->drain_level + ch->level) <= 15)
      dam *= 1;
      else if ((ch->drain_level + ch->level) <= 20)
      dam *= 3/2;
      else if ((ch->drain_level + ch->level) < 25)
      dam *= 2;
      else if ((ch->drain_level + ch->level) < 30)
      dam *= 7/3;
      else if ((ch->drain_level + ch->level) < 40)
      dam *= 5/2;
      else if ((ch->drain_level + ch->level) <= 49)
      dam *= 7/2;
      else if ((ch->drain_level + ch->level) <= 55)
      dam *= 10/3;
      else dam *= 10/3;

      dam *= battlecry_multiplier(ch,victim,gsn_circle);

      damage(ch,victim,dam,gsn_circle, dam_type, TRUE);
   }
   else
   {
      check_improve(ch,gsn_circle,FALSE,1);

      damage(ch,victim,0,gsn_circle,DAM_OTHER,TRUE);
   }

   return;
}


void do_surrender( CHAR_DATA *ch, char *argument )
{
   CHAR_DATA *mob;
   if ( (mob = ch->fighting) == NULL )
   {
      send_to_char( "But you're not fighting!\n\r", ch );
      return;
   }

   act( "You surrender to $N!", ch, NULL, mob, TO_CHAR );
   act( "$n surrenders to you!", ch, NULL, mob, TO_VICT );
   act( "$n tries to surrender to $N!", ch, NULL, mob, TO_NOTVICT );
   stop_fighting( ch, TRUE );

   if ( !IS_NPC( ch ) && IS_NPC( mob )
   &&   ( !HAS_TRIGGER( mob, TRIG_SURR )
   || !mp_percent_trigger( mob, ch, NULL, NULL, TRIG_SURR ) ) )
   {
      act( "$N seems to ignore your cowardly act!", ch, NULL, mob, TO_CHAR );
      multi_hit( mob, ch, TYPE_UNDEFINED );
   }
}


void do_sla( CHAR_DATA *ch, char *argument )
{
   send_to_char( "If you want to SLAY, spell it out.\n\r", ch );
   return;
}



void do_slay( CHAR_DATA *ch, char *argument )
{
   CHAR_DATA* victim;
   char arg[MAX_INPUT_LENGTH];

   one_argument(argument, arg);
   if (arg[0] == '\0')
   {
      send_to_char("Slay whom?\n\r", ch);
      return;
   }

   if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (ch == victim)
   {
      send_to_char("Suicide is a mortal sin.\n\r", ch);
      return;
   }

   if
   (
      !IS_NPC(victim) &&
      (
         (
            get_trust(victim) >= get_trust(ch) &&
            !IS_NPC(ch)
         ) ||
         (
            IS_NPC(ch) &&
            IS_IMMORTAL(victim)
         )
      )
   )
   {
      send_to_char("You failed.\n\r", ch);
      return;
   }
   if (IS_NPC(ch) && ch->house != 0)
   {
      send_to_char("You failed.\n\r", ch);
      return;
   }

   act
   (
      "You point at $M and $S heart stops!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n points at you and your heart suddenly stops!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n points at $N and $E falls over clenching $S chest!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );

   raw_kill(ch, victim );
   return;
}


void spell_evil_eye(int sn,int level, CHAR_DATA *ch,void *vo, int target)
{
   CHAR_DATA *victim = (CHAR_DATA *) vo;
   int dam, modify, saves;

   if (victim == ch)
   {
      send_to_char("You can't do such a thing.\n\r",ch);
      return;
   }

   act("$n's eyes turn pitch-black and a surging darkness erupts at $N.",ch,NULL,victim,TO_NOTVICT);
   act("Your eyes turn pitch-black and a stream of pure negative energy streams out at $N.",ch,NULL,victim,TO_CHAR);
   send_to_char("You feel a sudden intense agony burning into your skull.\n\r",victim);

   if (IS_SET(victim->affected_by,AFF_BLIND) )
   {
      dam = dice(level,8);
      if (saves_spell(ch,level,victim, DAM_NEGATIVE,SAVE_DEATH) )
      dam /= 2;
      damage(ch,victim,dam*race_adjust(ch)/25.0,sn,DAM_NEGATIVE, TRUE);
      return;
   }

   saves = 0;
   for (modify = 0; modify < 4; modify ++)
   {
      if (saves_spell(ch, level, victim, DAM_NEGATIVE,SAVE_DEATH))
      saves++;
   }

   if (saves == 0 && can_instakill(ch, victim))
   {
      act("$n's surging darkness devastates $N's skull, killing $M instantly!",ch,NULL,victim,TO_NOTVICT);
      act("Your darkness slays $N!",ch,NULL,victim,TO_CHAR);
      send_to_char("With a violent burning sensation your mind vaporises.\n\r",victim);
      raw_kill(ch,victim);
      return;
   }

   dam = dice(level, 16);
   dam /= (saves + 1);

   damage(ch,victim,dam*race_adjust(ch)/25.0,sn,DAM_NEGATIVE,TRUE);
   return;

}


void spell_power_word_kill(int sn,int level,CHAR_DATA *ch,void *vo, int target)
{
   CHAR_DATA *victim = (CHAR_DATA *) vo;
   int dam,saves,modify;

   saves = 0;

   act("$n points a finger at $N and utters the word, 'Die'.",ch,NULL,victim,TO_NOTVICT);
   act("$n points a finger at you and utters the word, 'Die'.",ch,NULL,victim,TO_VICT);
   send_to_char("You intone a word of unholy power.\n\r",ch);

   for ( modify = 0; modify < 4; modify++)
   {
      if (saves_spell(ch,level,victim,DAM_NEGATIVE,SAVE_DEATH))
      saves++;
   }
   if (saves == 0  && can_instakill (ch, victim))
   {
      act("$N shudders in shock as $S heart explodes!", ch, NULL,victim,TO_NOTVICT);
      send_to_char("You feel your heart rupture in a violent explosion of pain!\n\r",victim);
      act("Your word of power vaporises $N's heart, killing $M instantly!",ch,NULL,victim,TO_CHAR);
      raw_kill(ch,victim);
      return;
   }
   dam = dice(level,14);
   dam /= UMAX(saves,1);
   damage(ch,victim,dam*race_adjust(ch)/25.0,sn,DAM_NEGATIVE,TRUE);

   return;
}



void do_breath_morph(CHAR_DATA *ch, char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   void *vo;
   int sn, level;

   if (ch->morph_form[0] == 0)
   {
      send_to_char("You aren't in a draconic form, you can't do that.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (ch->morph_form[2] == 0)
   {
      send_to_char("You breath hard but nothing but thick wisps of gas come out.\n\r",ch);
      act("$n breathes out hard but nothing more than thick smoke comes out.",ch,NULL,NULL,TO_ROOM);
      return;
   }
   if (ch->mana < 40)
   {
      send_to_char("You do not have the mana.\n\r",ch);
      return;
   }
   one_argument(argument, arg);
   sn = ch->morph_form[1];
   level = ch->level;

   if (number_percent() > get_skill(ch, gsn_breath_morph))
   {
      send_to_char("You breath hard but nothing but thick wisps of gas come out.\n\r",ch);
      act("$n breathes out hard but nothing more than thick smoke comes out.",ch,NULL,NULL,TO_ROOM);
      check_improve(ch,sn,FALSE,1);
      return;
   }
   check_improve(ch,sn,TRUE,1);

   vo = NULL;
   if (arg[0] == '\0')
   victim = ch->fighting;
   else (victim = get_char_room(ch,arg));

   if (victim == NULL)
   {
      send_to_char("Dragon blast on whom?\n\r",ch);
      return;
   }

   vo = (void *) victim;
   ch->mana -= 40;
   /*    ch->morph_form[2] -= 1;*/

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   WAIT_STATE(ch,skill_table[sn].beats);
   magic_spell_vict(ch, victim, CAST_BITS_PLR_SKILL, level, sn);
   return;
}

void do_critical_strike(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* victim;
   int chance, dam;
   char arg[MAX_INPUT_LENGTH];
   OBJ_DATA* wield;
   int multiplier;
   char buf[MAX_STRING_LENGTH];
   int dam_type = 0;

   dam = 0;
   one_argument(argument,arg);
   if
   (
      (chance = get_skill(ch, gsn_critical_strike)) <= 0 ||
      !has_skill(ch,gsn_critical_strike)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r", ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't strike yourself!\n\r", ch);
      return;
   }

   if (check_peace(ch)) return;

   wield = get_eq_char(ch, WEAR_WIELD);
   if (wield == NULL)
   {
      send_to_char("You must have a weapon to critical strike.\n\r", ch);
      return;
   }
   switch (wield->value[0])
   {
      default:
      send_to_char("You can't critical strike without a bladed weapon.\n\r", ch);
      return;
      case (WEAPON_SWORD):
      case (WEAPON_DAGGER):
      case (WEAPON_SPEAR):
      case (WEAPON_AXE):
      case (WEAPON_POLEARM):
      break;
   }
   dam_type = attack_table[wield->value[3]].damage;
   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   chance -= get_curr_stat(victim, STAT_DEX);
   chance += get_curr_stat(ch, STAT_DEX);
   if (IS_AFFECTED(ch, AFF_HASTE))
   {
      chance += 10;
   }
   if (IS_AFFECTED(victim, AFF_HASTE))
   {
      chance -= 20;
   }
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);

   switch(number_range(1, 8))
   {
      case(1):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's roots!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's roots!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your roots!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strike at $N's neck!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's neck!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your neck!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(2):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's trunk!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's trunk!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your trunk!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strike at $N's left kidney!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's left kidney!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your left kidney!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(3):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's tendrils!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's tendrils!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your tendrils!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strike at $N's right kidney!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's right kidney!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your right kidney!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(4):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's cornstalk!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's cornstalk!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your cornstalk!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strike at $N's head!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's head!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your head!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(5):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's tendrils!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's tendrils!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your tendrils!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strikes at $N's lungs by way of $S armpit!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's lungs by way of $S armpit!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your lungs by way of $S armpit!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(6):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's roots!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's roots!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your roots!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strikes at $N's heart!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's heart!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your heart!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(7):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's trunk!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's trunk!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your trunk!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strikes at $N's spleen!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's spleen!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your spleen!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(8):
      {
         if (victim->race == grn_arborian)
         {
            act
            (
               "$n quickly strike at $N's cornstalk!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's cornstalk!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your cornstalk!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "$n quickly strikes at $N's liver!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You quickly strike at $N's liver!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n quickly strikes at your liver!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
   }
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         victim->fighting == NULL ||
         ch->fighting == NULL
      )
   )
   {
      sprintf
      (
         log_buf, "[%s] critical striked [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
      sprintf
      (
         buf,
         "Help! %s is trying to stab me!",
         PERS(ch, victim)
      );
      do_myell(victim,buf);
   }

   if (number_percent() < chance)
   {
      check_improve(ch, gsn_critical_strike, TRUE,1);
      WAIT_STATE(ch, skill_table[gsn_critical_strike].beats);
      if (wield->pIndexData->new_format)
      {
         dam = dice(wield->value[1],wield->value[2]);
      }
      else
      {
         dam = number_range(wield->value[1],wield->value[2]);
      }

      dam += GET_DAMROLL(ch);
      dam *= get_skill(ch, gsn_critical_strike);
      dam /= 100;
      dam += number_range(25, 40);
      multiplier = number_range((ch->drain_level + ch->level)/8, (ch->drain_level + ch->level)/4);
      multiplier /= 10;
      multiplier += 5/4;
      dam *= multiplier;
      dam *= battlecry_multiplier(ch, victim, gsn_critical_strike);
      if (IS_WEAPON_STAT(wield, WEAPON_SHARP))
      {
         int percent;

         if ((percent = number_percent()) <= (chance / 5))
         dam = 2 * dam + (dam * 2 * percent / 100);
      }
      if (dam <= 0)
      {
         dam = 1;
      }
      if
      (
         victim != NULL &&
         IS_WEAPON_STAT(wield, WEAPON_POISON)
      )
      {
         int level;
         AFFECT_DATA af;
         AFFECT_DATA *af2;
         level = ch->level;
         send_to_char("You feel poison coursing through your veins.\n\r", victim);
         act
         (
            "$n is poisoned by the venom on $p.",
            victim,
            wield,
            NULL,
            TO_ROOM
         );
         af.where     = TO_AFFECTS;
         af.type      = gsn_poison;
         af.level     = level * 3/4;
         af.duration  = level / 2;
         af.location  = APPLY_STR;
         af.modifier  = -1;
         af.bitvector = AFF_POISON;
         affect_join( victim, &af, 10 );
         af2 =affect_find(victim->affected, gsn_poison);
         if (af2 != NULL)
         {
            free_string(af2->caster);
            if
            (
               IS_NPC(ch) &&
               IS_AFFECTED(ch, AFF_CHARM) &&
               ch->master &&
               !IS_NPC(ch->master)
            )
            {
               af2->caster = str_dup(ch->master->name);
            }
            else
            {
               af2->caster = str_dup(ch->name);
            }
         }
      }
      damage
      (
         ch,
         victim,
         dam,
         gsn_critical_strike,
         dam_type,
         TRUE
      );
   }
   else
   {
      damage
      (
         ch,
         victim,
         dam,
         gsn_critical_strike,
         dam_type,
         TRUE
      );
      check_improve
      (
         ch,
         gsn_critical_strike,
         FALSE,
         1
      );
      WAIT_STATE(ch, skill_table[gsn_critical_strike].beats);
   }
   return;
}


void do_lunge( CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *victim;
   int chance, dam;
   char arg[MAX_INPUT_LENGTH];
   OBJ_DATA *wield;
   int multiplier;
   char buf[MAX_STRING_LENGTH];
   bool attempt_dual;
   int dam_type = 0;

   dam = 0;
   one_argument(argument,arg);
   if ((chance = get_skill(ch,gsn_lunge) ) <= 0
   || /*(ch->level < skill_table[gsn_lunge].skill_level[ch->class])*/
   !has_skill(ch,gsn_lunge) )
   {
      send_to_char("Lunging? What's that?\n\r",ch);
      return;
   }
   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }
   else if ( (victim = get_char_room(ch,arg)) == NULL )
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't lunge at yourself!\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   wield = get_eq_char(ch,WEAR_WIELD);
   if ((wield == NULL)
   || (( wield->value[0] != WEAPON_SWORD)
   && ( wield->value[0] != WEAPON_SPEAR)
   && ( wield->value[0] != WEAPON_POLEARM) ))
   {
      attempt_dual = TRUE;
      wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   }

   if (wield == NULL)
   {
      send_to_char("You must be wielding a sword, spear, or polearm to lunge.\n\r",ch);
      return;
   }

   if ((wield == NULL)
   || (( wield->value[0] != WEAPON_SWORD)
   && ( wield->value[0] != WEAPON_SPEAR)
   && ( wield->value[0] != WEAPON_POLEARM) ))
   {
      send_to_char("You must be wielding a sword, spear, or polearm to lunge.\n\r",ch);
      return;
   }
   dam_type = attack_table[wield->value[3]].damage;
   if (is_safe(ch, victim, 0))
   {
      return;
   }

   chance += ch->carry_weight/25;
   chance -= victim->carry_weight/20;
   chance += (ch->size - victim->size)*20;
   chance -= get_curr_stat(victim,STAT_DEX);
   chance += get_curr_stat(ch,STAT_STR)/3;
   chance += get_curr_stat(ch,STAT_DEX)/2;
   if (IS_AFFECTED(ch,AFF_HASTE) )
   chance += 10;
   if (IS_AFFECTED(victim,AFF_HASTE) )
   chance -= 20;
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   act("$n attempts to impale $N with a quick lunge!",ch,0,victim,TO_NOTVICT);
   act("You attempt to impale $N with a quick lunge!",ch,0,victim,TO_CHAR);
   act("$n attempts to impale you with a quick lunge!",ch,0,victim,TO_VICT);
   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (victim->fighting == NULL || ch->fighting == NULL))
   {
      sprintf(buf,"Help! %s is trying to run me through!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] lunged [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }

   if (number_percent() < chance)
   {
      check_improve(ch,gsn_lunge,TRUE,1);
      WAIT_STATE(ch,skill_table[gsn_lunge].beats);
      if (wield->pIndexData->new_format)
      dam = dice(wield->value[1],wield->value[2]);
      else
      dam = number_range(wield->value[1],wield->value[2]);

      if (get_skill(ch,gsn_enhanced_damage) > 0 )
      {
         if (number_percent() <= get_skill(ch,gsn_enhanced_damage) )
         {
            check_improve(ch,gsn_enhanced_damage,TRUE,1);
            dam += (dam*number_range(50,100)*
            (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_enhanced_damage]))/10000;
         }
      }

      dam += GET_DAMROLL(ch);
      dam *= get_skill(ch,gsn_lunge);
      dam /= 100;
      dam += number_range(25,40);
      multiplier = number_range((ch->drain_level + ch->level)/8,(ch->drain_level + ch->level)/4);
      multiplier /= 10;
      multiplier += 5/4;
      dam *= multiplier;
      dam *= battlecry_multiplier(ch, victim, gsn_lunge);

      if (dam <= 0)
      dam = 1;
      damage(ch,victim,dam,gsn_lunge,dam_type,TRUE);
   }
   else
   {
      damage(ch,victim,dam,gsn_lunge,dam_type,TRUE);
      check_improve(ch,gsn_lunge,FALSE,1);
      WAIT_STATE(ch,skill_table[gsn_lunge].beats);
   }
   return;
}

void do_blackjack( CHAR_DATA *ch,char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA af;
   CHAR_DATA *victim;
   int chance,size;
   char buf[MAX_STRING_LENGTH];

   if (IS_NPC(ch) )
   return;

   one_argument(argument,arg);

   if ((chance = get_skill(ch,gsn_blackjack)) <= 0
   || /*( ch->level < skill_table[gsn_blackjack].skill_level[ch->class])*/
   !has_skill(ch,gsn_blackjack) )
   {
      send_to_char("You don't know how to blackjack.\n\r",ch);
      return;
   }
   if (arg[0] == '\0')
   {
      send_to_char("Blackjack who?\n\r",ch);
      return;
   }
   if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (victim == ch)
   {
      send_to_char("Amusing, but not possible.\n\r",ch);
      return;
   }
   if (victim->race == grn_arborian)
   {
      send_to_char("You can't blackjack them.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (is_affected(victim,gsn_halo_of_eyes) && can_see(victim,ch) &&
   number_percent() < 30)
   {
      send_to_char("You notice one of the eyes surrounding them looking straight at you!\n\r",ch);
      chance = 0;
   }
   if (is_safe(ch, victim, 0))
   {
      return;
   }
   size=victim->size-ch->size;
   if(size>2) {
      send_to_char("That person is too large to blackjack.\n\r",ch);
      return;
   }
   if (victim->position == POS_SLEEPING)
   {
      send_to_char("But that person is already asleep!\n\r",ch);
      return;
   }
   if (victim->position == POS_FIGHTING)
   {
      send_to_char("They are moving about too much.\n\r",ch);
      return;
   }
   if (is_affected(victim,gsn_blackjack_timer) || is_affected(victim,gsn_blackjack) )
   {
      send_to_char("They are guarding their head too well right now.\n\r",ch);
      return;
   }
   chance *= 75;
   chance /= 100;
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);
   if(size>0)
   chance -= 15*size;
   if (IS_AFFECTED(victim,AFF_HASTE))
   chance -= 20;
   if (IS_AFFECTED(ch,AFF_HASTE))
   chance += 10;
   if (get_eq_char(victim,WEAR_HEAD) != NULL)
   chance -= 10;
   if(is_affected(victim,gsn_cloak_form))
   chance+=10;

   af.where = TO_AFFECTS;
   af.level = ch->level + victim->drain_level;
   af.location = 0;
   af.modifier = 0;
   af.bitvector = 0;

   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   if (number_percent() < chance)
   {
      check_perception(ch, victim, "swinging a heavy sack");
      act("You whack $N over the head with a heavy looking sack. Ouch.",ch,0,victim,TO_CHAR);
      act("$n whacks $N over the head with a heavy looking sack. Ouch.",ch,0,victim,TO_NOTVICT);
      send_to_char("You feel a sudden pain erupt through the back of your skull.\n\r",victim);
      af.type = gsn_blackjack;
      af.duration = 2;
      affect_to_char(victim,&af);
      af.bitvector = 0;
      af.type=gsn_blackjack_timer;
      af.duration=4;
      affect_to_char(victim,&af);
      victim->position = POS_SLEEPING;
      check_improve(ch,gsn_blackjack,TRUE,1);
      if (!IS_NPC(ch) && !IS_IMMORTAL(ch) && !IS_IMMORTAL(victim))
      {
         if (!IS_NPC(victim) || IS_AFFECTED(victim,AFF_CHARM))
         {
            QUIT_STATE(ch, 20);
            QUIT_STATE(victim, 20);
         }
      }
      WAIT_STATE(ch,2*PULSE_VIOLENCE);
      if (!IS_NPC(victim))
      {
         sprintf(log_buf, "[%s] blackjacked [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      return;
   }
   else
   {
      act("You attempt to blackjack $N but fail.",ch,0,victim,TO_CHAR);
      act("$n attempts to blackjack $N but misses.",ch,0,victim,TO_NOTVICT);
      act("$n hits you over the head with a heavy sack.",ch,0,victim,TO_VICT);
      af.type=gsn_blackjack_timer;
      af.bitvector = 0;
      af.duration = 2;
      affect_to_char(victim,&af);
      check_improve(ch,gsn_blackjack,FALSE,1);
      damage(ch,victim,2 + 2*number_range(2,5), gsn_blackjack,DAM_BASH,TRUE);
      WAIT_STATE(ch, 2*PULSE_VIOLENCE);
      if (!IS_NPC(victim))
      {
         /* get_longname changed to PERS in failed blackjack attempt - Cirdan */
         sprintf(buf, "Help! %s tried to blackjack me!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] blackjacked [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
         multi_hit(ch,victim,TYPE_UNDEFINED);
      }
   }
   return;
}


void do_bandage(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA af;

   one_argument(argument,arg);

   if ( (get_skill(ch,gsn_bandage) <= 0) || !has_skill(ch,gsn_bandage) )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (house_down(ch,HOUSE_CRUSADER))
   return;
   /*
   if (!IS_SET(ch->act,PLR_HONORBOUND) && !IS_IMMORTAL(ch)) {
   send_to_char("Only the honorbound are capable of mastering that skill.\n\r",ch);
   return;
   }
   */

   if (is_affected(ch,gsn_bandage))
   {
      send_to_char("You can't apply more aid yet.\n\r",ch);
      return;
   }
   if (ch->mana < 15)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   victim = ch;
   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (!IS_NPC(ch) && (number_percent() > ch->pcdata->learned[gsn_bandage]))
   {
      act("You fail to apply battle dressing to $N's wounds.",ch,0,victim,TO_CHAR);
      act("$n fumbles with $s bandages but fails to use them effectively.",ch,0,0,TO_ROOM);
      ch->mana -= 7;
      check_improve(ch,gsn_bandage,FALSE,3);
      return;
   }
   ch->mana -= 15;

   if (victim != ch)
   {
      act("$n applies bandages to $N's battle wounds.",ch,0,victim,TO_NOTVICT);
      act("You apply bandages to $N's battle wounds.",ch,0,victim,TO_CHAR);
      act("$n applies bandages to your battle wounds.",ch,0,victim,TO_VICT);
   }
   else
   {
      act("$n applies bandages to $mself.",ch,0,0,TO_ROOM);
      send_to_char("You apply battle dressing to yourself.\n\r",ch);
   }

   if (is_affected(victim, gsn_corrupt("smite", &gsn_smite)))
   {
      send_to_char("You feel better, but the wounds do not close.\n\r",victim);
      return;
   }

   send_to_char("You feel better.\n\r",victim);

   victim->hit = UMIN(victim->hit + (3*ch->level), victim->max_hit);
   victim->on = NULL;
   if (number_percent() < 25)
   {
      if (IS_AFFECTED(victim,AFF_PLAGUE))
      {
         affect_strip(victim,gsn_plague);
         act("The sores on $n's body vanish.\n\r",victim,0,0,TO_ROOM);
         send_to_char("The sores on your body vanish.\n\r",victim);
      }
   }
   if (number_percent() < 25)
   {
      if (is_affected(victim, gsn_blindness))
      {
         affect_strip(victim, gsn_blindness);
         send_to_char("Your vision returns!\n\r",victim);
      }
   }
   if (number_percent() < 25)
   {
      if (is_affected(victim,gsn_poison))
      {
         affect_strip(victim,gsn_poison);
         send_to_char("A warm feeling goes through your body.\n\r",victim);
         act("$n looks better.",victim,0,0,TO_ROOM);
      }
      if (is_affected(victim,gsn_poison_dust))
      {
         affect_strip(victim,gsn_poison_dust);
         send_to_char("The dust in your eyes is cleaned out.\n\r",victim);
         act("The dust in $n's eyes looks cleaned out.",victim,0,0,TO_ROOM);
      }
   }

   check_improve(ch,gsn_bandage,TRUE,3);
   af.where = TO_AFFECTS;
   af.type = gsn_bandage;
   af.location = 0;
   af.duration = 3;
   af.modifier = 0;
   af.bitvector = 0;
   af.level = ch->level;
   affect_to_char(ch,&af);
   return;
}

void do_herb(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   AFFECT_DATA af;
   int heal;

   one_argument(argument,arg);

   if( ((get_skill(ch,gsn_herb) <= 0) || !has_skill(ch,gsn_herb))
   && ( !IS_NPC(ch) || ch->pIndexData->vnum != 5705 ))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (is_affected(ch,gsn_herb))
   {
      send_to_char("You can't find any more herbs.\n\r",ch);
      return;
   }
   if ((ch->in_room->sector_type != SECT_FOREST)
   && (ch->in_room->sector_type != SECT_UNDERGROUND)
   && (ch->in_room->sector_type != SECT_HILLS)
   && (ch->in_room->sector_type != SECT_MOUNTAIN) )
   {
      send_to_char("You can't find any herbs here.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   victim = ch;
   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   /* Prevent more than one heal from the crusader paladin healer */
   if ( IS_NPC(ch)
   && ch->pIndexData->vnum == 5705
   && is_affected(victim,gsn_herb) )
   {
      do_emote(ch,"observes his collection of herbs and shakes his head.");
      sprintf( buf, "You must wait until I can find more herbs for you, %s.", victim->name );
      do_say( ch, buf );
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (is_affected(victim, gsn_corrupt("smite", &gsn_smite)))
   {
      send_to_char("You feel better, but the wounds do not close.\n\r",victim);
      return;
   }
   if (is_affected(victim, gsn_black_mantle))
   {
      send_to_char("The black mantle absorbs your healing.\n\r",victim);
      return;
   }

   if (!IS_NPC(ch) && (number_percent() > ch->pcdata->learned[gsn_herb]))
   {
      send_to_char("You search for herbs but fail to find any.\n\r",ch);
      act("$n looks about in the bushes but finds nothing.",ch,0,0,TO_ROOM);
      check_improve(ch,gsn_herb,FALSE,4);
      return;
   }

   if (victim != ch)
   {
      act("$n applies herbs to $N.",ch,0,victim,TO_NOTVICT);
      act("You apply herbs to $N.",ch,0,victim,TO_CHAR);
      act("$n applies herbs to you.",ch,0,victim,TO_VICT);
   }

   if (victim == ch)
   {
      act("$n applies herbs to $mself.",ch,0,0,TO_ROOM);
      send_to_char("You find herbs and apply them to yourself.\n\r",ch);
   }

   send_to_char("You feel better.\n\r",victim);

   if (IS_AFFECTED(victim,AFF_PLAGUE) && number_percent() > 30)
   {
      affect_strip(victim,gsn_plague);
      act("The sores on $n's body vanish.\n\r",victim,0,0,TO_ROOM);
      send_to_char("The sores on your body vanish.\n\r",victim);
   }

   check_improve(ch,gsn_herb,TRUE,4);
   heal = (4*(ch->drain_level + ch->level));
   if (is_affected(victim, gsn_mantle_oblivion))
   {
      heal /= 2;
   }
   victim->hit = UMIN(victim->hit + heal, victim->max_hit);
   victim->on = NULL;
   af.where = TO_AFFECTS;
   af.type = gsn_herb;
   af.location = 0;
   af.duration = 4;
   af.modifier = 0;
   af.bitvector = 0;
   af.level = ch->level + ch->drain_level;

   if ( IS_NPC(ch) && ch->pIndexData->vnum == 5705 )
   affect_to_char(victim,&af);
   else
   affect_to_char(ch,&af);

   return;
}

void do_cleave(CHAR_DATA *ch,char *argument)
{
   OBJ_DATA *weapon;
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   int dam, chance, dam_type;
   char buf[MAX_STRING_LENGTH];
   int sn;
   int skill;
   bool off_hand = FALSE;

   if ( ( ( chance = get_skill(ch,gsn_cleave)) <= 0)
   || /*(ch->level < skill_table[gsn_cleave].skill_level[ch->class])*/
   !has_skill(ch,gsn_cleave) )
   {
      send_to_char("You don't know how to cleave.\n\r",ch);
      return;
   }

   one_argument(argument,arg);
   weapon = get_eq_char(ch,WEAR_WIELD);

   if (weapon == NULL)
   {
      send_to_char("You need to wield a sword or axe to cleave.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if ((weapon->value[0] != WEAPON_SWORD)
   && (weapon->value[0] != WEAPON_AXE))
   {
      weapon = get_eq_char(ch,WEAR_DUAL_WIELD);
      if (weapon == NULL)
      {
         send_to_char("You need to wield a sword or axe to cleave.\n\r",ch);
         return;
      }
      off_hand = TRUE;
   }
   if ((weapon->value[0] != WEAPON_SWORD)
   && (weapon->value[0] != WEAPON_AXE) )
   {
      send_to_char("You need to wield a sword or axe to cleave.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }
   else if ( (victim = get_char_room(ch,arg)) == NULL )
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (victim == ch)
   {
      send_to_char("You can't do such a thing.\n\r",ch);
      return;
   }
   if (victim->fighting != NULL)
   {
      send_to_char("They are moving too much to cleave.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (victim->hit < victim->max_hit)
   {
      send_to_char("They are too hurt and watchful to cleave right now...\n\r",ch);
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   dam = (dice(weapon->value[1],weapon->value[2]) + get_curr_stat(ch,STAT_STR) * 2) * 6;
   dam_type = attack_table[weapon->value[3]].damage;

   dam = dam * ((float)ch->level/50.0);

   if (off_hand) dam = dam - dam/3;

   sn = get_weapon_sn(ch);
   skill = get_weapon_skill(ch,sn) + (IS_NPC(ch) ? 100 :ch->pcdata->learned[gsn_cleave])+10;
   skill = skill/2;
   dam = dam * ((float)skill/100.0);

   /* skill to this point */
   chance = chance/5;

   /* the sharper your blade, the easier it cuts */
   if (IS_WEAPON_STAT(weapon,WEAPON_SHARP)) chance += 10;

   /* mandatory level stuff */
   chance += (ch->level - victim->level)*5;
   if (victim->level > ch->level + 5)
   chance += (ch->level - victim->level)*3;

   /* damage and raw strength */
   chance += dice(weapon->value[1],weapon->value[2]);
   chance += 2*get_curr_stat(ch,STAT_STR) - 25;

   /* size affects bigger is harder to cleave */
   chance += (ch->size-victim->size)*10;

   /* surprise attacks */
   if (!can_see(victim,ch))
   chance += 5;

   /* cheese reduction */
   if (victim->level >= 60) chance /= 2;
   if (victim->max_hit > 10000) chance /= 2;

   /* max min chances (non pk) */
   if (chance > 90) chance = 90;
   if (chance < 3)  chance = 3;

   if (IS_NPC(victim) && IS_SET(victim->act2,ACT_NO_DEATHSTRIKE)) chance = 0;

   /* resist/vuln modifying */
   switch(check_immune(victim,dam_type))
   {
      case IS_IMMUNE: chance = 0;
      case IS_RESISTANT: chance -= 15;
      case IS_VULNERABLE: chance += 15;
   }
   if (IS_SET(victim->imm_flags,IMM_WEAPON))
   chance = 0;


   /* pk max chances */
   if (!IS_NPC(victim))
   {
      chance = UMIN(chance,3+(ch->level-victim->level)/2);
   }
   if (number_percent() < 50)
   sprintf(buf,"Die, %s you butchering fool!",PERS(ch,victim));
   else
   sprintf(buf,"Help! %s just tried to cleave me in half!",PERS(ch,victim));

   act("You make a brutal swing at $N in an attempt to cleave them in half.",ch,0,victim,TO_CHAR);
   act("$n attempts to cleave you in half with a brutal slice.",ch,0,victim,TO_VICT);
   act("$n makes an attempt to cleave $N in half.",ch,0,victim,TO_NOTVICT);

   if ((number_percent() > chance) || !can_instakill(ch, victim))
   {
      check_improve(ch,gsn_cleave,FALSE,5);
      damage(ch,victim,dam,gsn_cleave,dam_type,TRUE);
      WAIT_STATE(ch,24);
      if (!IS_NPC(victim) && !IS_NPC(ch) && victim->hit > 1)
      {
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] cleaved [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      return;
   }

   act("Your cleave slices $S body in half with a clean cut!",ch,0,victim,TO_CHAR);
   act("$n cleaves you in half, tearing your body into two bloody bits!",ch,0,victim,TO_VICT);
   act("$n cleaves $N into two bits of bloody flesh!",ch,0,victim,TO_NOTVICT);
   check_improve(ch,gsn_cleave,TRUE,3);
   WAIT_STATE(ch,24);
   raw_kill(ch,victim);
   return;
}

void do_deathstrike(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   int chance, dam;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_INPUT_LENGTH];
   /*    AFFECT_DATA af;    */

   one_argument(argument,arg);
   if (IS_NPC(ch))
   return;

   if ((get_skill(ch,gsn_deathstrike) <= 0)
   || /*ch->level < skill_table[gsn_deathstrike].skill_level[ch->class]*/
   !has_skill(ch,gsn_deathstrike))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;


   if (is_affected(ch,gsn_deathstrike))
   {
      send_to_char("You can't build up the intensity to deathstrike yet.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   {
      send_to_char("Attempt to destroy who's skull?\n\r",ch);
      return;
   }
   if ( (victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't do that.\n\r",ch);
      return;
   }
   if (victim->fighting != NULL || victim->position == POS_FIGHTING)
   {
      send_to_char("They are moving around too much to get in close for the kill.\n\r",ch);
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (victim->hit < victim->max_hit)
   {
      send_to_char("They have too much blood on them right now to locate their strike point.\n\r",ch);
      return;
   }
   chance = get_skill(ch,gsn_deathstrike)/2;
   chance += ch->level;
   chance -= victim->level;
   if (!can_see(victim,ch))
   chance += 10;
   if (victim->position == POS_FIGHTING)
   chance -= 25;
   else if (victim->position == POS_SLEEPING)
   chance += 10;

   if (!IS_NPC(victim))
   chance /= 15;
   chance = URANGE(2,chance,90);
   if (IS_NPC(victim) && IS_SET(victim->act2,ACT_NO_DEATHSTRIKE))
   chance = 0;
   /*
   af.where = TO_AFFECTS;
   af.type = gsn_deathstrike;
   af.location = 0;
   af.modifier = 0;
   af.duration = 5;
   af.bitvector = 0;
   af.level = ch->level;
   affect_to_char(ch,&af);
   */
   act("$n strikes out at $N with deadly intensity.",ch,0,victim,TO_NOTVICT);
   act("You strike out at $N with deadly intensity.",ch,0,victim,TO_CHAR);
   act("$n strikes at you with deadly intensity.",ch,0,victim,TO_VICT);

   if (IS_SET(victim->imm_flags,IMM_WEAPON))
   chance = 0;
   WAIT_STATE(ch,24);
   if (number_percent() < chance
   && can_instakill(ch, victim))
   {
      send_to_char("With agonising pain your skull is smashed by the blow!\n\r",victim);
      act("Your blow shatters $N's skull into bloody fragments!",ch,0,victim,TO_CHAR);
      act("$N's skull is shattered into bits of mangled flesh and bone by $n's strike!",ch,0,victim,TO_NOTVICT);
      raw_kill(ch,victim);
      check_improve(ch,gsn_deathstrike,TRUE,3);
      return;
   }
   else
   {
      send_to_char("You feel a sharp pain searing your skull!\n\r",victim);
      act("Your deathstrike smashes $N's skull but fails to kill.",ch,0,victim,TO_CHAR);
      dam = ch->level * 3;
      dam += dice(ch->level, 4);
      damage(ch,victim,dam,gsn_deathstrike,DAM_PIERCE,TRUE);
      check_improve(ch,gsn_deathstrike,FALSE,3);
      if (!IS_NPC(victim) && !IS_NPC(ch) && (victim->hit > 1))
      {
         sprintf(buf,"Help! %s just tried to kill me!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] deathstriked [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      multi_hit(victim,ch,TYPE_UNDEFINED);
   }

   return;
}

void do_crush(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* victim;
   int chance;
   int dam;
   long id;
   OBJ_DATA* wield;

   /* not sure how to format this particular IF */
   if
   (
      (chance = get_skill(ch, gsn_crush)) <= 0 ||
      /*ch->level < skill_table[gsn_crush].skill_level[ch->class]*/
      !has_skill(ch, gsn_crush)
   )
   if (!IS_NPC(ch))
   {
      send_to_char("Crushing, how do you do that again?\n\r", ch);
      return;
   }

   wield = get_eq_char(ch, WEAR_WIELD);
   if
   (
      wield != NULL &&
      wield->value[0] == WEAPON_BOW &&
      !check_tanking(ch) &&
      fire_volley(ch, NULL, TRUE)
   )
   {
      send_to_char("You cannot use close range combat techniques while wielding a ranged weapon.\n\r", ch);
      return;
   }

   if
   (
      ch->in_room->sector_type == SECT_UNDERWATER ||
      (
         ch->in_room->sector_type == SECT_WATER_NOSWIM &&
         IS_AFFECTED(ch, AFF_SWIM)
      ) ||
      ch->in_room->sector_type == SECT_AIR
   )
   {
      send_to_char("There is no way you can do this effectively here.\n\r", ch);
      return;
   }

   if ((victim = ch->fighting) == NULL)
   {
      send_to_char("You aren't fighting anyone.\n\r", ch);
      return;
   }
   if
   (
      victim->position < POS_FIGHTING ||
      victim->daze > 0
   )
   {
      act
      (
         "You'll have to let $M get back up first.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   chance -= chance/4;
   chance += (ch->drain_level + ch->level - victim->drain_level - victim->level) * 2;
   chance += get_curr_stat(ch,STAT_STR);
   chance -= get_curr_stat(victim,STAT_DEX)/3;
   chance -= get_curr_stat(victim,STAT_STR)/2;
   if (ch->size < victim->size)
   {
      chance += (ch->size - victim->size)*25;
   }
   else
   {
      chance += (ch->size - victim->size)*10;
   }
   if (number_percent() < chance)
   {
      /*
      if (is_affected(victim,gsn_phasing) &&
      (number_percent() < (75+((victim->level-ch->level)*2))))
      {
      act("You phase out and $N's crush doesn't affect you.",victim,0,ch,TO_CHAR);
      act("$n phases out and $N's crush doesn't seem to affect him.",victim,0,ch,TO_NOTVICT);
      act("$n phases out and your crush doesn't seem to affect him.",victim,0,ch,TO_VICT);
      WAIT_STATE(ch,2*PULSE_VIOLENCE);
      return;
      }
      */
      if (check_shadowstrike(ch, TRUE, TRUE))
      {
         return;
      }
      if (check_roll(ch, victim, gsn_crush))
      {
         check_improve
         (
            ch,
            gsn_crush,
            TRUE,
            2
         );
         act
         (
            "$N rolls free of $n's crush.",
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         act
         (
            "You roll out of $n's crush attempt.",
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            "$N rolls free of your crush attempt.",
            ch,
            0,
            victim,
            TO_CHAR
         );
         WAIT_STATE(ch, 2*PULSE_VIOLENCE);
         return;
      }
      switch(number_range(1,4))
      {
         case(1):
         {
            act
            (
               "$n grabs you and slams you to the ground with bone crushing force!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You grab $N and slam $M to the ground with bone crushing force!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n slams $N to the ground with bone crushing force!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(2):
         {
            if (victim->race == grn_arborian)
            {
               act
               (
                  "$n grabs you by the roots and slams you around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N by the roots and slam $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs $N by the roots and slams $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else if (victim->race == grn_draconian)
            {
               act
               (
                  "$n grabs you by the tail and slams you around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N by the tail and slam $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs $N by the tail and slams $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else if (victim->race == grn_illithid)
            {
               act
               (
                  "$n grabs you by the tentacles and slams you around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N by the tentacles and slam $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs $N by the tentacles and slams $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else if (victim->race == grn_minotaur)
            {
               act
               (
                  "$n grabs you by the horns and slams you around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N by the horns and slam $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs $N by the horns and slams $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n grabs you by the legs and slams you around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N by the legs and slam $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs $N by the legs and slams $M around repeatedly like a rag doll!",
                  ch,
                  0,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
         case(3):
         {
            act
            (
               "$n grabs you, lifts you to $s shoulders, and slams you into the ground violently!",
               ch,
               0,
               victim,
               TO_VICT
            );
            act
            (
               "You grab $N, lift $M to your shoulders, and slam $M into the ground violently!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n grabs $N, lifts $M to $s shoulders, and slams $M into the ground violently!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(4):
         {
            if (victim->race == grn_arborian)
            {
               act
               (
                  "$n grabs you by the back of the corn stalk and slams you to the ground!",
                  ch,
                  0,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N by the back of the corn stalk and slam $M to the ground!",
                  ch,
                  0,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs $N by the back of the corn stalk and slams $M to the ground!",
                  ch,
                  0,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n grabs you by the back of the head and slams you to the ground!",
                  ch,
                  0,
                  victim,
                  TO_VICT
               );
               act
               (
                  "You grab $N by the back of the head and slam $M to the ground!",
                  ch,
                  0,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs $N by the back of the head and slams $M to the ground!",
                  ch,
                  0,
                  victim,
                  TO_NOTVICT
               );
               break;
            }
         }
      }
      check_improve
      (
         ch,
         gsn_crush,
         TRUE,
         4
      );
      if ((ch->drain_level + ch->level) < 20)
      {
         dam = 20;
      }
      else if ((ch->drain_level + ch->level) < 25)
      {
         dam = 30;
      }
      else if ((ch->drain_level + ch->level) < 30)
      {
         dam = 40;
      }
      else if ((ch->drain_level + ch->level) < 35)
      {
         dam = 50;
      }
      else if ((ch->drain_level + ch->level) < 40)
      {
         dam = 60;
      }
      else if ((ch->drain_level + ch->level) < 52)
      {
         dam = 70;
      }
      else
      {
         dam = 70;
      }
      dam += str_app[get_curr_stat(ch, STAT_STR)].todam;
      DAZE_STATE(victim, PULSE_VIOLENCE * 3 / 2);
      WAIT_STATE(ch, 2 * PULSE_VIOLENCE);
      id = victim->id;
      damage
      (
         ch,
         victim,
         dam,
         gsn_crush,
         DAM_BASH,
         TRUE
      );
      victim->position = POS_RESTING;

      /* not sure where the brackets go here, think before the return */
      if
      (
         ch->fighting == victim &&
         victim->id == id &&
         (
            (ch->in_room->sector_type != SECT_WATER_NOSWIM) &&
            (ch->in_room->sector_type != SECT_UNDERWATER)
         )
      )
      {
         check_ground_control
         (
            ch,
            victim,
            chance,
            dam
         );
      }
      return;
   }
   act
   (
      "Your crush attempt misses $N.",
      ch,
      0,
      victim,
      TO_CHAR
   );
   act
   (
      "$n lashes out wildly with $s arms but misses.",
      ch,
      0,
      0,
      TO_ROOM
   );
   WAIT_STATE(ch, 2*PULSE_VIOLENCE);
   check_improve
   (
      ch,
      gsn_crush,
      FALSE,
      3
   );
   return;

}

void check_ground_control(CHAR_DATA* ch, CHAR_DATA* victim, int chance, int dam)
{
   if (chance < 10)
   {
      return;
   }
   if (dam == 0)
   {
      return;
   }

   chance = get_skill(ch, gsn_ground_control);
   chance /= 3;

   chance -= number_range(5, 15);
   chance = URANGE(5, chance, 30);

   if (/*ch->level < skill_table[gsn_ground_control].skill_level[ch->class]*/
   !has_skill(ch,gsn_ground_control))
   {
      return;
   }
   if (number_percent() > chance)
   {
      check_improve
      (
         ch,
         gsn_ground_control,
         FALSE,
         3
      );
      return;

   }
   switch(number_range(1,6))
   {
      case(1):
      {
         if
         (
            ch->class == CLASS_MONK ||
            (
               ch->class == CLASS_THIEF &&
               ch->pcdata->special == SUBCLASS_NINJA
            )
         )
         {
            act
            (
               "You jump on $N and twist your hips, grinding $M against the ground with your feet!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n jumps on $N twists $s hips, grinding $M against the ground with $s feet!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n jumps on you and twists $s hips, grinding you against the ground with $s feet!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "With brutal skill you grind $N against the ground with your weight.",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n takes hold of $N and grinds $M against the ground.",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n grinds you against the ground with brutal skill.",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(2):
      {
         if
         (
            ch->class == CLASS_MONK ||
            (
               ch->class == CLASS_THIEF &&
               ch->pcdata->special == SUBCLASS_NINJA
            )
         )
         {
            act
            (
               "You leap into the air and land on $N with your iron head, smashing $M against the ground!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n leaps into the air and lands on $N with $s iron head, smashing $M against the ground!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n leaps into the air and lands on you with $s iron head, smashing you against the ground!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "You fall atop $N and grind your forearm across $S face with great fury!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n falls atop $N and grinds $s forearm across $S face with great fury!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n falls atop you and grinds $s forearm across your face with great fury!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(3):
      {
         if
         (
            ch->class == CLASS_MONK ||
            (
               ch->class == CLASS_THIEF &&
               ch->pcdata->special == SUBCLASS_NINJA
            )
         )
         {
            act
            (
               "You leap into the air and land on $N with both feet in a powerful stomp!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n leaps into the air and lands on $N with both feet in a powerful stomp!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n leaps into the air and lands on you with both feet in a powerful stomp!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "You take advantage of $N's position and kick $M while $E is on the ground!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n takes advantage of $N's position and kicks $M while $E is on the ground!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n takes advantage of your position and kicks you while you are on the ground!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(4):
      {
         if
         (
            ch->class == CLASS_MONK ||
            (
               ch->class == CLASS_THIEF &&
               ch->pcdata->special == SUBCLASS_NINJA
            )
         )
         {
            act
            (
               "You spread your arms and leap into the air, landing on $N with a knee stomp!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n spreads $s arms and leaps into the air, landing on $N with a knee stomp!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n spreads $s arms and leaps into the air, landing on you with a knee stomp!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "You drop beside $N and begin to drive your fist into $S face over and over!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n drops beside $N and begins to drive $s fist into $S face over and over!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n drops beside you and begins to drive $s fist into your face over and over!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(5):
      {
         if
         (
            ch->class == CLASS_MONK ||
            (
               ch->class == CLASS_THIEF &&
               ch->pcdata->special == SUBCLASS_NINJA
            )
         )
         {
            act
            (
               "You raise your leg and stomp on $N's face!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n raises $s leg and stomps on $N's face!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n raises $s leg and stomps on your face!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "You drop on $N with your elbow!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n drops on $N with $s elbow!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n drops on you with $s elbow!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
      case(6):
      {
         if
         (
            ch->class == CLASS_MONK ||
            (
               ch->class == CLASS_THIEF &&
               ch->pcdata->special == SUBCLASS_NINJA
            )
         )
         {
            act
            (
               "You do a front flip and land on $N with your heels!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n does a front flip and lands on $N with $s heels!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n does a front flip and lands on you with $s heels!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
         else
         {
            act
            (
               "You stomp $N against the ground repeatedly!",
               ch,
               0,
               victim,
               TO_CHAR
            );
            act
            (
               "$n stomps $N against the ground repeatedly!",
               ch,
               0,
               victim,
               TO_NOTVICT
            );
            act
            (
               "$n stomps you against the ground repeatedly!",
               ch,
               0,
               victim,
               TO_VICT
            );
            break;
         }
      }
   }
   dam -= 10;
   check_improve
   (
      ch,
      gsn_ground_control,
      TRUE,
      2
   );
   damage
   (
      ch,
      victim,
      dam,
      gsn_ground_control,
      DAM_BASH,
      TRUE
   );
   return;

}


void do_riot(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *gch;
   int bonus;
   AFFECT_DATA af;

   if ( (get_skill(ch,gsn_riot) <= 0 )
   || /*ch->level < skill_table[gsn_riot].skill_level[ch->class]*/
   !has_skill(ch,gsn_riot))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (check_peace(ch)) return;

   if (house_down(ch,HOUSE_OUTLAW))
   return;

   if (ch->mana < 40)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_riot))
   {
      send_to_char("You can't stir up another riot yet.\n\r",ch);
      return;
   }
   if (!IS_NPC(ch) && (number_percent() > ch->pcdata->learned[gsn_riot]))
   {
      send_to_char("You try to incite a riot amongst your group but fail.\n\r",ch);
      act("$n gestures around angrily, trying to build up anger and discord but fails.",ch,0,0,TO_ROOM);
      ch->mana -= 20;
      check_improve(ch,gsn_riot,FALSE,2);
      return;
   }

   send_to_char("You stir up a riot with your actions!\n\r",ch);
   af.where = TO_AFFECTS;
   af.type = gsn_riot;
   af.level = ch->level + ch->drain_level;
   af.bitvector = 0;
   af.duration = ( 2 + (ch->drain_level + ch->level)/8);
   af.location = APPLY_HITROLL;

   if ((ch->drain_level + ch->level) < 20)
   bonus = 6;
   else if ((ch->drain_level + ch->level) < 25)
   bonus = 7;
   else if ((ch->drain_level + ch->level) < 30)
   bonus = 8;
   else if ((ch->drain_level + ch->level) < 35)
   bonus = 9;
   else if ((ch->drain_level + ch->level) < 38)
   bonus = 10;
   else
   bonus = 12;

   af.modifier = bonus;
   affect_to_char(ch,&af);
   af.location = APPLY_DAMROLL;
   affect_to_char(ch,&af);
   send_to_char("You are filled with terrible fury!\n\r",ch);

   for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
   {
      if (!is_same_group(ch,gch) || !IS_AWAKE(gch))
      continue;
      if (is_affected(gch,gsn_riot))
      continue;
      if (gch->trust > 51)
      continue;
      if (gch == ch)
      continue;
      af.location = APPLY_DAMROLL;
      affect_to_char(gch,&af);
      af.location = APPLY_HITROLL;
      affect_to_char(gch,&af);
      send_to_char("You are filled with a terrible fury!\n\r",gch);
      act("$n gets a terrible look of anger in $s eyes.",gch,0,0,TO_ROOM);
   }

   check_improve(ch,gsn_riot,TRUE,2);
   ch->mana -= 40;
   return;
}



void do_tail(CHAR_DATA *ch, char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   int chance, dam;
   int knock;

   one_argument(argument,arg);


   if ( (chance = get_skill(ch,gsn_tail)) <= 0
   ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_TAIL))
   ||   (!IS_NPC(ch)
   &&   /* ch->level < skill_table[gsn_tail].skill_level[ch->class]*/
   !has_skill(ch,gsn_tail)))
   {
      send_to_char("You don't have a tail to strike with like that.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }

   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   chance = URANGE(5,chance,90);

   chance += (ch->level - victim->level);
   chance -= get_curr_stat(victim,STAT_DEX);
   chance += get_curr_stat(ch,STAT_DEX)/3;
   chance += get_curr_stat(ch,STAT_STR)/3;

   act("$n violently lashes out with $s tail.",ch,0,0,TO_ROOM);
   send_to_char("You violently lash out with your tail!\n\r",ch);

   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   if (number_percent() > chance)
   {
      damage(ch,victim,0,gsn_tail,DAM_BASH,TRUE);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   dam = dice(ch->level, 3);
   knock = (ch->level + 15);

   damage(ch,victim,dam,gsn_tail,DAM_BASH,TRUE);
   if (number_percent() < knock && victim->daze == 0)
   {
      act("$n is sent crashing to the ground by the force of the blow!",victim,0,0,TO_ROOM);
      send_to_char("The tail strike sends you crashing to the ground!\n\r",victim);
      DAZE_STATE(victim,( 3 * PULSE_VIOLENCE/2));
   }
   WAIT_STATE(ch,2*PULSE_VIOLENCE);
   return;
}


void do_spellbane(CHAR_DATA* ch, char* argument)
{
   AFFECT_DATA af;

   if
   (
      get_skill(ch, gsn_spellbane) < 10 ||
      !has_skill(ch, gsn_spellbane)
   )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (house_down(ch, HOUSE_CRUSADER))
   {
      return;
   }
   if (is_affected(ch, gsn_spellbane))
   {
      send_to_char
      (
         "You relax, allowing your soul to be open and vulnerable to influence.\n\r",
         ch
      );
      act
      (
         "$n relaxes, allowing $s soul to be open and vulnerable to influence.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      affect_strip(ch, gsn_spellbane);
      return;
   }
   if (ch->mana < 50)
   {
      send_to_char("You do not have the mana.\n\r", ch);
      return;
   }
   if (number_percent() > get_skill(ch, gsn_spellbane))
   {
      /*      send_to_char("You think of your hatred of magic but can not sustain it.\n\r",ch); */
      send_to_char
      (
         "You attempt to focus on the purity of your soul but are distracted.\n\r",
         ch
      );
      /* act("$n makes some angry gestures and goes red in the face, but nothing happens.",ch,0,0,TO_ROOM); */
      act
      (
         "$n attempts to focus on the purity of $s soul but is distracted.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      ch->mana -= 25;
      check_improve(ch, gsn_spellbane,FALSE, 1);
      return;
   }
   af.where = TO_AFFECTS;
   af.type = gsn_spellbane;
   af.level = ch->level + ch->drain_level;
   af.duration = (5 + (ch->drain_level + ch->level) / 5);
   af.location = APPLY_SAVES;
   af.modifier = (-5 -(ch->drain_level + ch->level) / 4);
   af.bitvector = 0;
   affect_to_char(ch, &af);
   act
   (
      "$n focuses on protecting $mself from the taint of magic.",
      ch,
      NULL,
      NULL,
      TO_ROOM
   );
   send_to_char
   (
      "Through purity of soul, you feel protected from the taint of magic.\n\r",
      ch
   );
   /****** Removed and put back on the Wise One
   if (is_affected(ch,gsn_undead_drain))
   {
   if (saves_spell(ch,50,ch,DAM_OTHER,SAVE_OTHER))
   {
   send_to_char("Your spellbane burns away the negative draining magic of the undead.\n\r",ch);

   affect_strip(ch,gsn_undead_drain);
   }
   }
   ******/

   check_improve(ch, gsn_spellbane, TRUE, 1);
   ch->mana -= 50;
   return;
}


bool spellbaned(CHAR_DATA *caster, CHAR_DATA *victim, int sn)
{
   char buf[MAX_STRING_LENGTH];
   bool status = FALSE;
   int chance;
   CHAR_DATA* master_vch;

   if (!is_affected(victim,gsn_spellbane))
   {
      if (!IS_NPC(victim))
      {
         return FALSE;
      }
      if (victim->pIndexData->vnum != MOB_VNUM_CRUSADER)
      {
         return FALSE;
      }
   }

   if
   (
      IS_IMMORTAL(caster) &&
      (
         !IS_IMMORTAL(victim) ||
         (
            !IS_NPC(caster) &&
            caster == victim
         )
      )
   )
   {
      return FALSE;
   }

   if
   (
      sn < 1 ||
      sn >= MAX_SKILL
   )
   {
      return FALSE;
   }

   if (skill_table[sn].spell_fun == spell_null)
   {
      return FALSE;
   }

   if
   (
      sn == gsn_spiritblade &&
      number_percent() > 50
   )
   {
      return FALSE;
   }

   if
   (
      skill_table[sn].target == TAR_CHAR_HEALING ||
      skill_table[sn].target == TAR_CHAR_DEFENSIVE ||
      skill_table[sn].target == TAR_CHAR_SELF ||
      skill_table[sn].target == TAR_OBJ_CHAR_DEF
   )
   {
      status = TRUE;
   }
   else
   {
      /* Players get flat 85% chance of defense against any spell */
      chance = 85;

      /* The Crusader guardian gets 90% chance of defense against any spell */
      if (IS_NPC(victim) && (victim->pIndexData->vnum == MOB_VNUM_CRUSADER))
      {
         chance = 90;
      }
      else if (sn == gsn_hand_of_vengeance)
      {
         /* ----------------------------------------------------------------
            If the offensive magic is the Hand of Vengeance cast upon
            a spellbaner or his charmie, we lower his chances of spellbaning
            by 2% for every criminal flag beyond five flags.  Remember that
            normally, a spellbaner that might be a criminal gets a flat 85%
            chance.  This means that spellbane will have absolutely no chance
            to defend against the Hand of Vengeance if the spellbaner has at
            least 47 flags.  Since the number of flags are permanent, this
            gives a common spellbaner criminal no chance the rest of his
            life against anyone who casts Hand of Vengeance.
            - Comment by Xurinos
            A floor of 15% chance added, no matter how many marks the
            crusader has. - Fizz
            ---------------------------------------------------------------- */
         master_vch = victim;
         while
         (
            IS_NPC(master_vch) &&
            master_vch->master &&
            master_vch->master != master_vch &&
            master_vch->master->master != master_vch &&
            IS_AFFECTED(master_vch, AFF_CHARM)
         )
         {
            master_vch = master_vch->master;
         }
         if (!IS_NPC(master_vch))
         {
            int wanteds = master_vch->pcdata->wanteds;

            if (IS_SET(master_vch->act2, PLR_LAWLESS))
            {
               /* Lawless always carries with it maximum penalty */
               chance = 15;
            }
            else if (wanteds > 5)
            {
               chance -= (wanteds - 5) * 2;
               if (chance < 15)
               {
                  chance = 15;
               }
            }
         }
      }
      if (number_percent() <= chance)
      {
         status = TRUE;
      }
   }

   if (status)
   {
      if
      (
         !is_supplicating ||
         (
            IS_IMMORTAL(caster) &&
            !IS_NPC(caster)
         )
      )
      {
         act
         (
            "The purity of $n's soul reflects $N's spell!",
            victim,
            NULL,
            caster,
            TO_NOTVICT
         );
         act
         (
            "The purity of your soul reflects $N's spell!",
            victim,
            NULL,
            caster,
            TO_CHAR
         );
         act
         (
            "The purity of $n's soul reflects your spell!",
            victim,
            NULL,
            caster,
            TO_VICT
         );
      }
      else
      {
         if (caster == victim)
         {
            act
            (
               "The purity of $n's soul nullifies $s prayers to $z!",
               victim,
               NULL,
               NULL,
               TO_ROOM
            );
            act
            (
               "The purity of your soul nullifies your prayers to $z!",
               victim,
               NULL,
               NULL,
               TO_CHAR
            );
         }
         else
         {
            act
            (
               "The purity of $n's soul nullifies $N's prayers to $Z!",
               victim,
               NULL,
               caster,
               TO_NOTVICT
            );
            act
            (
               "The purity of your soul nullifies $N's prayers to $Z!",
               victim,
               NULL,
               caster,
               TO_CHAR
            );
            act
            (
               "The purity of $n's soul nullifies your prayers to $Z!",
               victim,
               NULL,
               caster,
               TO_VICT
            );
         }
      }
      if (!is_safe(caster, victim, 0))
      {
         if
         (
            !IS_NPC(caster) &&
            !IS_NPC(victim) &&
            (
               victim->fighting == NULL ||
               caster->fighting == NULL
            ) &&
            victim != caster
         )
         {
            if (is_supplicating)
            {
               sprintf
               (
                  buf,
                  "Help! %s is using foul divinations on me!",
                  PERS(caster, victim)
               );
            }
            else
            {
               sprintf
               (
                  buf,
                  "Help! %s is casting foul magics on me!",
                  PERS(caster, victim)
               );
            }
            do_myell(victim,buf);
            sprintf(log_buf, "[%s] cast magic on [%s] at %d", caster->name, victim->name, caster->in_room->vnum);
            log_string(log_buf);
         }
         damage(victim,caster,dice(caster->level,2),gsn_spellbane,DAM_ENERGY,TRUE);
      }
   }

   return status;

}


/* Monk skills */

void do_throw(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* victim;
   int dam;
   int chance;
   char arg[MAX_INPUT_LENGTH];

   if
   (
      (chance = get_skill(ch, gsn_throw)) <= 0 ||
      /*ch->level < skill_table[gsn_throw].skill_level[ch->class]*/
      !has_skill(ch, gsn_throw)
   )
   {
      send_to_char("Throwing? What's that?\n\r", ch);
      return;
   }
   if (get_eq_char(ch, WEAR_DUAL_WIELD) != NULL)
   {
      send_to_char("Your hands are tied up with your weapons.\n\r", ch);
      return;
   }

   one_argument(argument,arg);
   if (arg[0] == '\0')
   {
      victim = ch->fighting;
   }
   else
   {
      victim = get_char_room(ch, arg);
   }

   if (victim == NULL)
   {
      send_to_char("They aren't here.\n\r", ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("Now that would be a bit stupid.\n\r", ch);
      return;
   }
   if
   (
      (victim->fighting != ch) &&
      (ch->fighting != victim)
   )
   {
      send_to_char("But you aren't engaged in combat with them.\n\r", ch);
      return;
   }
   if
   (
      victim->position < POS_FIGHTING ||
      victim->daze > 0
   )
   {
      act
      (
         "You'll have to let $M get back up first.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   /*
   if (hands_full(ch))
   {
   send_to_char("You can't throw, your hands are filled with items.\n\r",ch);
   return;
   }
   */
   /*
   if (is_affected(ch,gsn_palm))
   {
   send_to_char("You can't throw, you're fighting with open hand palms.\n\r",ch);
   return;
   }
   */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);
   chance -= get_curr_stat(victim, STAT_DEX);
   chance += get_curr_stat(ch, STAT_DEX)/2;
   chance *= 9;
   chance /= 10;
   chance = URANGE(5, chance, 90);

   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   if (number_percent() > chance)
   {
      dam = 0;
      check_improve
      (
         ch,
         gsn_throw,
         FALSE,
         3
      );
   }
   else
   {
      if
      (
         is_affected(victim, gsn_phasing) &&
         (number_percent() < (75+((victim->level-ch->level)*2)))
      )
      {
         act
         (
            "$n phases out and $N's throw doesn't seem to affect $m.",
            victim,
            NULL,
            ch,
            TO_NOTVICT
         );
         act
         (
            "$n phases out and your throw doesn't seem to affect $m.",
            victim,
            NULL,
            ch,
            TO_VICT
         );
         act
         (
            "You phase out and $N's throw doesn't affect you.",
            victim,
            NULL,
            ch,
            TO_CHAR
         );
         WAIT_STATE(ch, 2 * PULSE_VIOLENCE);
         return;
      }

      if (check_roll(ch, victim, gsn_throw))
      {
         check_improve
         (
            ch,
            gsn_throw,
            TRUE,
            2
         );
         switch(number_range(1,4))
         {
            case(1):
            {
               act
               (
                  "$N rolls free of $n's throw.",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You roll out of $n's throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$N rolls free of your throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               break;
            }
            case(2):
            {
               act
               (
                  "$N twists and rolls free of $n's throw.",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You twist and roll out of $n's throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$N twists and rolls free of your throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               break;
            }
            case(3):
            {
               act
               (
                  "$N flips and frees $Mself from $n's throw.",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You flip and free yourself from $n's throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$N flips and frees $Mself from your throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               break;
            }
            case(4):
            {
               act
               (
                  "$N drops and rolls out of $n's throw.",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You drop and roll out of $n's throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               act
               (
                  "$N drops and rolls out of your throw attempt.",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               break;
            }
         }
         WAIT_STATE(ch, 2*PULSE_VIOLENCE);
         return;
      }

      if ((ch->drain_level + ch->level) <= 18)
      {
         dam = 30;
      }
      else if ((ch->drain_level + ch->level) <= 22)
      {
         dam = 35;
      }
      else if ((ch->drain_level + ch->level) <= 25)
      {
         dam = 40;
      }
      else if ((ch->drain_level + ch->level) <= 28)
      {
         dam = 45;
      }
      else if ((ch->drain_level + ch->level) <= 32)
      {
         dam = 48;
      }
      else if ((ch->drain_level + ch->level) <= 35)
      {
         dam = 52;
      }
      else if ((ch->drain_level + ch->level) <= 38)
      {
         dam = 56;
      }
      else if ((ch->drain_level + ch->level) <= 40)
      {
         dam = 60;
      }
      else if ((ch->drain_level + ch->level) <= 43)
      {
         dam = 64;
      }
      else if ((ch->drain_level + ch->level) <= 45)
      {
         dam = 68;
      }
      else if ((ch->drain_level + ch->level) <= 48)
      {
         dam = 70;
      }
      else
      {
         dam = 72;
      }

      switch(number_range(1,8))
      {
         case(1):
         {
            act
            (
               "$n grabs $N and throws $M to the ground with stunning force!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You grab $N and throw $M to the ground with stunning force!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n grabs you and throws you to the ground with stunning force!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            break;
         }
         case(2):
         {
            act
            (
               "$n grabs $N and throws $M over $s shoulder and to the ground!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You grab $N and throw $M over your shoulder and to the ground!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n grabs you and throws you over $s shoulder and to the ground!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            break;
         }
         case(3):
         {
            act
            (
               "$n grabs $N, braces $M with $s leg, and drops backward, throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You grab $N, brace $M with your leg, and drop backward, throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n grabs you, braces you with $s leg, and drops backward, throwing you to the ground!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            break;
         }
         case(4):
         {
            act
            (
               "$n drops and grabs $N with $s legs, twisting and throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You drop and grab $N with your legs, twisting and throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n drops and grabs you with $s legs, twisting and throwing you to the ground!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            break;
         }
         case(5):
         {
            act
            (
               "$n flips overhead above $N, grabbing and throwing $M in midair!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You flip overhead above $N, grabbing and throwing $M in midair!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n flips overhead above you, grabbing and throwing you in midair!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            break;
         }
         case(6):
         {
            act
            (
               "$n leaps onto $N's shoulders and arches forward, throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You leap onto $N's shoulders and arch forward, throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n leaps onto your shoulders and arches forward, throwing you to the ground!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            break;
         }
         case(7):
         {
            act
            (
               "$n leaps onto $N's shoulders and arches backward, throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "You leap onto $N's shoulders and arch backward, throwing $M to the ground!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n leaps onto your shoulders and arches backward, throwing you to the ground!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            break;
         }
         case(8):
         {
            if (victim->race == grn_arborian)
            {
               act
               (
                  "$n grabs $N's tendril and flips $M over, throwing $M to the ground!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You grab $N's tendril and flip $M over, throwing $M to the ground!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs your tendril and flips you over, throwing you to the ground!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               break;
            }
            else
            {
               act
               (
                  "$n grabs $N's arm and flips $M over, throwing $M to the ground!",
                  ch,
                  NULL,
                  victim,
                  TO_NOTVICT
               );
               act
               (
                  "You grab $N's arm and flip $M over, throwing $M to the ground!",
                  ch,
                  NULL,
                  victim,
                  TO_CHAR
               );
               act
               (
                  "$n grabs your arm and flips you over, throwing you to the ground!",
                  ch,
                  NULL,
                  victim,
                  TO_VICT
               );
               break;
            }
         }
      }


      dam += str_app[get_curr_stat(ch, STAT_STR)].todam;
      check_improve(ch, gsn_throw,TRUE,3);
      dam *= battlecry_multiplier(ch, victim, gsn_throw);
      DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
   }

   damage
   (
      ch,
      victim,
      dam,
      gsn_throw,
      DAM_BASH,
      TRUE
   );
   WAIT_STATE(ch, 2*PULSE_VIOLENCE);
   if (ch->fighting == victim)
   {
      check_ground_control
      (
         ch,
         victim,
         chance,
         dam
      );
   }

   return;
}

void do_palm(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;
   int chance;

   if ( (chance = get_skill(ch,gsn_palm)) <= 0
   || /*ch->level < skill_table[gsn_palm].skill_level[ch->class]*/
   !has_skill(ch,gsn_palm))
   {
      send_to_char("You don't have the ability to use palm striking martial arts.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_palm))
   {
      send_to_char("You're already fighting with concentrated open hand martial arts.\n\r",ch);
      return;
   }

   /*    if (ch->mana <= 60)
   {
   send_to_char("You don't have the mana.\n\r",ch);
   return;
   }
   */
   if (get_eq_char(ch,WEAR_WIELD) != NULL
   || get_eq_char(ch,WEAR_DUAL_WIELD) != NULL)
   {
      send_to_char("You can't start using open palm striking while using weapons.\n\r",ch);
      return;
   }

   if (number_percent() >= chance)
   {
      send_to_char("You flex your hands but cannot grasp the concentration required.\n\r",ch);
      check_improve(ch,gsn_palm,FALSE,2);
      /*      ch->mana -= 30; */
      return;
   }

   act("$n slowly spreads $s hands and a look of deadly concentration clouds $s eyes.",ch,0,0,TO_ROOM);
   send_to_char("You feel your mind relax and pass power to your opened hands.\n\r",ch);
   af.where = TO_AFFECTS;
   af.type = gsn_palm;
   af.location = 0;
   af.modifier = 0;
   af.duration = ((ch->drain_level + ch->level)/3);
   af.level = ch->drain_level + ch->level;
   af.bitvector = 0;
   affect_to_char(ch,&af);
   check_improve(ch,gsn_palm,TRUE,2);

   return;
}

bool check_palm(CHAR_DATA *ch)
{
   if (!is_affected(ch,gsn_palm))
   return FALSE;
   if (number_percent() > 10)
   return FALSE;
   return TRUE;
}

int check_kung_fu(CHAR_DATA* ch, CHAR_DATA* victim)
{
   int roll;
   int bonus = 0;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   int chance;
   int kung_fu = FALSE;
   int ninjitsu = FALSE;
   int school;

   chance = 0;
   if (get_skill(ch,gsn_kung_fu) > 0)
   {
      chance += get_skill(ch,gsn_kung_fu);
      kung_fu = TRUE;
   }
   if (get_skill(ch,gsn_corrupt("ninjitsu", &gsn_ninjitsu)) > 0)
   {
      chance += get_skill(ch, gsn_corrupt("ninjitsu", &gsn_ninjitsu));
      ninjitsu = TRUE;
   }
   if
   (
      IS_NPC(ch) ||
      ch->id == ID_YANWEI
   )
   {
      school = number_range(SUBCLASS_SCHOOL_TIGER, SUBCLASS_SCHOOL_CRANE);
      /* tiger is lowest, crane is highest, all in a row */
   }
   else
   {
      school = ch->pcdata->special;
   }
   if
   (
      (
         roll = number_percent()
      ) <
      (
         chance * 3 / 8
      )
   )
   {
      switch (number_range(1, 10))
      {
         case (1):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You trigger a small blade in your footwear and use it to"
                  " kick at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n seems to shift $s footing before kicking at you with a"
                  " small blade!"
               );
               strcpy
               (
                  buf3,
                  "$n twists $s foot, releasing a small blade and kicking at $N"
                  " with it!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You swing at $N with a brutal overhand claw strike!"
               );
               strcpy
               (
                  buf2,
                  "$n swings at you with a brutal overhand claw strike!"
               );
               strcpy
               (
                  buf3,
                  "$n swings at $N with a brutal overhand claw strike!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You latch onto $N while simultaneously kicking at $M!"
               );
               strcpy
               (
                  buf2,
                  "$n latches onto you while simultaneously kicking at you!"
               );
               strcpy
               (
                  buf3,
                  "$n latches onto $N while simultaneously kicking at $M!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You step sideways while attacking $N with a barrage "
                  "of stabbing hand strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n steps sideways while attacking you with a barrage "
                  "of stabbing hand strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n steps sideways while attacking $N with a barrage "
                  "of stabbing hand strikes!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You explode in a frenzy of turning kicks targetting $N!"
               );
               strcpy
               (
                  buf2,
                  "You find yourself mercilessly assailed by a hail of $n's "
                  "turning kicks!"
               );
               strcpy
               (
                  buf3,
                  "$n unleashes a hail of turning kicks at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You unleash a torrent of palm strikes at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n unleashes a torrent of palm strikes at you!"
               );
               strcpy
               (
                  buf3,
                  "$n unleashes a torrent of palm strikes at $N!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You deliver a vicious chop to $N's neck!"
               );
               strcpy
               (
                  buf2,
                  "$n delivers a vicious chop to your neck!"
               );
               strcpy
               (
                  buf3,
                  "$n delivers a vicious chop to $N's neck!"
               );
            }
            bonus = 6;
            break;
         }
         case (2):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You spin evasively, tossing a shuriken at $N midway through"
                  " your spin!"
               );
               strcpy
               (
                  buf2,
                  "A small metal disc flies towards you as $n spins away from"
                  " you!"
               );
               strcpy
               (
                  buf3,
                  "$n turns away from $N, tossing a small disc at $N as $e spins!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You switch stance as you lash out at $N with a deadly "
                  "tiger's tail kick!"
               );
               strcpy
               (
                  buf2,
                  "$n switches stance as $e lashes out at you with a deadly "
                  "tiger's tail kick!"
               );
               strcpy
               (
                  buf3,
                  "$n switches stance as $e lashes out at $N with a deadly "
                  "tiger's tail kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You lash out at $N with fast double hooking strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n lashes out at you with two fast hooking strikes "
                  "in rapid succession!"
               );
               strcpy
               (
                  buf3,
                  "$n lashes out at $N with fast double hooking strikes!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You duck and roll past $N before turning and striking"
                  " at $S pressure points!"
               );
               strcpy
               (
                  buf2,
                  "$n ducks and rolls past you before turning and striking"
                  " at your pressure points!"
               );
               strcpy
               (
                  buf3,
                  "$n ducks and rolls past $N before turning and striking"
                  " at $N's pressure points!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You spread your arms and spin downward into a crouch, "
                  "striking $N with multiple light palm strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n spreads $s arms and spins downward into a crouch, "
                  "striking you with multiple light palm strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n spreads $s arms and spins downward into a crouch, "
                  "striking $N with multiple light palm strikes!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You charge at $N and attack with a flying dragon kick!"
               );
               strcpy
               (
                  buf2,
                  "$n charges at you and attacks with a flying dragon kick!"
               );
               strcpy
               (
                  buf3,
                  "$n charges at $N and attacks with a flying dragon kick!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You drive a powerful knee into $N's ribs!"
               );
               strcpy
               (
                  buf2,
                  "$n drives a powerful knee into your ribs!"
               );
               strcpy
               (
                  buf3,
                  "$n drives a powerful knee into $N's ribs!"
               );
            }
            bonus = 6;
            break;
         }
         case (3):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You vanish into a cloud of thrown dust and reappear behind $N,"
                  " striking at $M!"
               );
               strcpy
               (
                  buf2,
                  "$n vanishes in a cloud of dust, reappearing behind you and"
                  " striking at you!"
               );
               strcpy
               (
                  buf3,
                  "$n vanishes in a cloud of dust, appearing behind $N and"
                  " striking!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You lunge at $N with a crushing claw attack!"
               );
               strcpy
               (
                  buf2,
                  "$n lunges, grabbing at you with a crushing claw-like hand!"
               );
               strcpy
               (
                  buf3,
                  "$n lunges at $N, grabbing at $M with a crushing claw-like hand!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You launch a spinning uppercut attack at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n springs at you with a graceful spinning uppercut!"
               );
               strcpy
               (
                  buf3,
                  "$n springs at $N with a spinning uppercut!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You flip over $N and deliver a punishing heel kick during mid "
                  "flip at $S back!"
               );
               strcpy
               (
                  buf2,
                  "$n flips over you and delivers a punishing heel kick during mid "
                  "flip at your back!"
               );
               strcpy
               (
                  buf3,
                  "$n flips over $N and delivers a punishing heel kick during mid "
                  "flip at $N's back!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You crouch low and spread your arms before springing at $N and "
                  "attacking with high and low punches!"
               );
               strcpy
               (
                  buf2,
                  "$n crouches low and spreads $s arms before springing at you and "
                  "attacking with high and low punches!"
               );
               strcpy
               (
                  buf3,
                  "$n crouches low and spreads $s arms before springing at $N and "
                  "attacking with high and low punches!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with dual palm strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with dual palm strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with dual palm strikes!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You sink a swift elbow into $N's abdomen!"
               );
               strcpy
               (
                  buf2,
                  "$n sinks a swift elbow into your abdomen!"
               );
               strcpy
               (
                  buf3,
                  "$n sinks a swift elbow into $N's abdomen!"
               );
            }
            bonus = 5;
            break;
         }
         case (4):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You fall to the ground, feigning a crippled leg, then lunge"
                  " at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n falls to the ground holding $s leg, then suddenly lunges"
                  " at you!"
               );
               strcpy
               (
                  buf3,
                  "$n crumples to the ground holding $s leg, then suddenly"
                  " lunges at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You swing at $N with a powerful forearm smash!"
               );
               strcpy
               (
                  buf2,
                  "$n swings at you with $s forearm!"
               );
               strcpy
               (
                  buf3,
                  "$n swings at $N with $s forearm!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You grab $N, pulling $M towards you while thrusting at "
                  "$M with your knee!"
               );
               strcpy
               (
                  buf2,
                  "$n grabs you, pulling you towards $s thrusting knee attack!"
               );
               strcpy
               (
                  buf3,
                  "$n grabs $N, pulling $N into $s thrusting knee attack!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You spin and strike at $N with hardened knife hands and "
                  "finish with a tornado kick!"
               );
               strcpy
               (
                  buf2,
                  "$n spins and strikes at you with hardened knife hands and "
                  "finishes with a tornado kick!"
               );
               strcpy
               (
                  buf3,
                  "$n spins and strikes at $N with hardened knife hands and "
                  "finishes with a tornado kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You perform an aerial cartwheel and strike $N with a "
                  "pair of brutal kicks!"
               );
               strcpy
               (
                  buf2,
                  "$n performs an aerial cartwheel and strikes you with a "
                  "pair of brutal kicks!"
               );
               strcpy
               (
                  buf3,
                  "$n performs an aerial cartwheel and strikes $N with a "
                  "pair of brutal kicks!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with the dragon's fangs technique!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with the dragon's fangs technique!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with the dragon's fangs technique!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You strike $N in the head with a backhand fist!"
               );
               strcpy
               (
                  buf2,
                  "$n strikes you in the head with a backhand fist!"
               );
               strcpy
               (
                  buf3,
                  "$n strikes $N in the head with a backhand fist!"
               );
            }
            bonus = 10;
            break;
         }
         case (5):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You toss a small handful of dust at $N as a distraction"
                  " and lash out with a low kick!"
               );
               strcpy
               (
                  buf2,
                  "$n throws a handful of dust at you and suddenly a kick comes"
                  " low and hard out of nowhere!"
               );
               strcpy
               (
                  buf3,
                  "$n throws a handful of dust at $N as a distraction and kicks low"
                  " at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You strike at $N with a tiger iron palm!"
               );
               strcpy
               (
                  buf2,
                  "$n strikes at you with a powerful spread palm!"
               );
               strcpy
               (
                  buf3,
                  "$n strikes at $N with a powerful spread palm!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with two low shin kicks in rapid succession!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with two low shin kicks in rapid succession!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with two low shin kicks in rapid succession!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You dive between $N's legs and roll over, delivering a kick"
                  " at $S stomach before rolling out."
               );
               strcpy
               (
                  buf2,
                  "$n dives between your legs and rolls over, delivering a kick"
                  " at your stomach before rolling out."
               );
               strcpy
               (
                  buf3,
                  "$n dives between $N's legs and rolls over, delivering a kick"
                  " at $S stomach before rolling out."
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You stab at $N's head with crane's beak hands!"
               );
               strcpy
               (
                  buf2,
                  "$n folds $s fingers tight against each other and stabs at"
                  " your head!"
               );
               strcpy
               (
                  buf3,
                  "$n folds $s fingers tight against each other and stabs at"
                  " $N's head!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You leap into the air and strike $N in the head with a"
                  " deadly dragon claw attack!"
               );
               strcpy
               (
                  buf2,
                  "$n leaps into the air and strikes you in the head with a"
                  " deadly dragon claw attack!"
               );
               strcpy
               (
                  buf3,
                  "$n leaps into the air and strikes $N in the head with a"
                  " deadly dragon claw attack!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You punch $N in the flank!"
               );
               strcpy
               (
                  buf2,
                  "$n punches you in the flank!"
               );
               strcpy
               (
                  buf3,
                  "$n punches $N in the flank!"
               );
            }
            bonus = 6;
            break;
         }
         case (6):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You backflip away from $N and kick out with a small blade springing out"
                  " from your footwear!"
               );
               strcpy
               (
                  buf2,
                  "$n backflips away from you and kicks out with a small blade springing out"
                  " from $s footwear!"
               );
               strcpy
               (
                  buf3,
                  "$n backflips away from $N and kicks out with a small blade springing out"
                  " from $s footwear!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You lash out at $N with a mighty backhand attack followed by"
                  " a centerline punch!"
               );
               strcpy
               (
                  buf2,
                  "$n lashes out at you with a mighty backhand attack followed by"
                  " a centerline punch!"
               );
               strcpy
               (
                  buf3,
                  "$n lashes out at $N with a mighty backhand attack followed by"
                  " a centerline punch!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You stand on one hand and kick at $N with both legs!"
               );
               strcpy
               (
                  buf2,
                  "$n stands on one hand and kicks at you with both legs!"
               );
               strcpy
               (
                  buf3,
                  "$n stands on one hand and kicks at $N with both legs!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You jump and attack $N with a reverse tornado kick!"
               );
               strcpy
               (
                  buf2,
                  "$n jumps and attacks you with a reverse tornado kick!"
               );
               strcpy
               (
                  buf3,
                  "$n jumps and attacks $N with a reverse tornado kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You crouch down and spread your arms before striking $N"
                  " with dual crane's wings strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n crouches down and spreads $s arms beforing striking"
                  " you with dual crane's wings strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n crouches down and spreads $s arms beforing striking"
                  " $N with dual crane's wings strikes!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You drive an open palm into $N's forehead!"
               );
               strcpy
               (
                  buf2,
                  "$n drives an open palm into your forehead!"
               );
               strcpy
               (
                  buf3,
                  "$n drives an open palm into $N's forehead!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You jump and kick $N in the head!"
               );
               strcpy
               (
                  buf2,
                  "$n jumps and kicks you in the head!"
               );
               strcpy
               (
                  buf3,
                  "$n jumps and kicks $N in the head!"
               );
            }
            bonus = 6;
            break;
         }
         case (7):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You do a jumping back tuck and in midair hurl"
                  " a pair of needles at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n does a jumping back tuck and in midair hurls"
                  " a pair of needles at you!"
               );
               strcpy
               (
                  buf3,
                  "$n does a jumping back tuck and in midair hurls"
                  " a pair of needles at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with the striking the tiger technique"
                  " followed by a powerful side kick!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with the striking the tiger technique"
                  " followed by a powerful side kick!"

               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with the striking the tiger technique"
                  " followed by a powerful side kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with a lunging mantis strike!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with a lunging mantis strike!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with a lunging mantis strike!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You jump and flip forward, striking $N in the head"
                  " with both your feet in a double axe kick!"
               );
               strcpy
               (
                  buf2,
                  "$n jumps and flips forward, striking you in the head"
                  " with both $s feet in a double axe kick!"
               );
               strcpy
               (
                  buf3,
                  "$n jumps and flips forward, striking $N in the head"
                  " with both $s feet in a double axe kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with a scissor chop to the neck!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with a scissor chop to the neck!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with a scissor chop to the neck!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with a crushing overhand palm strike!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with a crushing overhand palm strike!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with a crushing overhand palm strike!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You drive your fist into the side of $N's neck!"
               );
               strcpy
               (
                  buf2,
                  "$n drives $s fist into the side of your neck!"
               );
               strcpy
               (
                  buf3,
                  "$n drives $s fist into the side of $N's neck!"
               );
            }
            bonus = 6;
            break;
         }
         case (8):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You rapid fire hurl a trio of kunai blades at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n rapid fire hurls a trio of kunai blades at you!"
               );
               strcpy
               (
                  buf3,
                  "$n rapid fire hurls a trio of kunai blades at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with a fierce tiger's claw attack!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with a fierce tiger's claw attack!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with a fierce tiger's claw attack!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You leap into the air and kick at the side of $N's head!"
               );
               strcpy
               (
                  buf2,
                  "$n leaps into the air and kicks at the side of your head!"
               );
               strcpy
               (
                  buf3,
                  "$n leaps into the air and kicks at the side of $N's head!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You spin and attack $N with a turning kick followed"
                  " by an axe kick!"
               );
               strcpy
               (
                  buf2,
                  "$n spins and attacks you with a turning kick followed"
                  " by an axe kick!"
               );
               strcpy
               (
                  buf3,
                  "$n spins and attacks $N with a turning kick followed"
                  " by an axe kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You raise your arms and jump up, kicking at $N while in midair!"
               );
               strcpy
               (
                  buf2,
                  "$n raisees $s arms and jumps up, kicking at you while in midair!"
               );
               strcpy
               (
                  buf3,
                  "$n raisees $s arms and jumps up, kicking at $N while in midair!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You go into a scissor stance and strike at $N with a sideways"
                  " palm strike!"
               );
               strcpy
               (
                  buf2,
                  "$n goes into a scissor stance and strikes at you with a sideways"
                  " palm strike!"
               );
               strcpy
               (
                  buf3,
                  "$n goes into a scissor stance and strikes at $N with a sideways"
                  " palm strike!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You drive a hammer fist into $N's torso!"
               );
               strcpy
               (
                  buf2,
                  "$n drives a hammer fist into your torso!"
               );
               strcpy
               (
                  buf3,
                  "$n drives a hammer fist into $N's torso!"
               );
            }
            bonus = 6;
            break;
         }
         case (9):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You spin around and hurl a pair of throwing spikes at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n spins around and hurls a pair of throwing spikes at you!"
               );
               strcpy
               (
                  buf3,
                  "$n spins around and hurls a pair of throwing spikes at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You drop and do the splits, punching at $N's groin and legs!"
               );
               strcpy
               (
                  buf2,
                  "$n drops and does the splits, punching at your groin and legs!"
               );
               strcpy
               (
                  buf3,
                  "$n drops and does the splits, punching at $N's groin and legs!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You lash out at $N with a series of pummelling mantis strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n lashes out at you with a series of pummelling mantis strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n lashes out at $N with a series of pummelling mantis strikes!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You lean forward and bring your leg up and over behind yourself"
                  " to attack $N!"
               );
               strcpy
               (
                  buf2,
                  "$n leans forward and brings $s leg up and over behind $mself"
                  " to attack you!"
               );
               strcpy
               (
                  buf3,
                  "$n leans forward and brings $s leg up and over behind $mself"
                  " to attack $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You spin and attack $N with a beautiful and deadly butterfly kick!"
               );
               strcpy
               (
                  buf2,
                  "$n spins and attacks you with a beautiful and deadly butterfly kick!"
               );
               strcpy
               (
                  buf3,
                  "$n spins and attacks $N with a beautiful and deadly butterfly kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You leap and spin sideways, attacking $N with dragon claws and"
                  " kicks!"
               );
               strcpy
               (
                  buf2,
                  "$n leaps and spins sideways, attacking you with dragon claws and"
                  " kicks!"
               );
               strcpy
               (
                  buf3,
                  "$n leaps and spins sideways, attacking $N with dragon claws and"
                  " kicks!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You deliver a crushing kick to $N's leg!"
               );
               strcpy
               (
                  buf2,
                  "$n delivers a crushing kick to your leg!"
               );
               strcpy
               (
                  buf3,
                  "$n delivers a crushing kick to $N's leg!"
               );
            }
            bonus = 6;
            break;
         }
         case (10):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You stagger backwards while putting a needle in your mouth"
                  " then spit it at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n staggers away, then suddenly spits a needle at you!"
               );
               strcpy
               (
                  buf3,
                  "$n staggers while putting $s hand to $s mouth, then spits a"
                  " needle at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You grab at $N and attack with a powerful dual claw strike!"
               );
               strcpy
               (
                  buf2,
                  "$n grabs at $N and attacks with a powerful dual claw strike!"
               );
               strcpy
               (
                  buf3,
                  "$n grabs at $N and attacks with a powerful dual claw strike!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You lunge forward and strike $N with twin mantis fists!"
               );
               strcpy
               (
                  buf2,
                  "$n lunges forward and strikes you with twin mantis fists!"
               );
               strcpy
               (
                  buf3,
                  "$n lunge forward and strikes $N with twin mantis fists!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You roll forward and unleash a dual stabbing hand strike at $N's vitals!"
               );
               strcpy
               (
                  buf2,
                  "$n rolls forward and unleashes a dual stabbing hand strike at your vitals!"
               );
               strcpy
               (
                  buf3,
                  "$n rolls forward and unleashs a dual stabbing hand strike at $N's vitals!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You strike $N with a brutal crescent kick!"
               );
               strcpy
               (
                  buf2,
                  "$n strikes at you with a brutal crescent kick!"
               );
               strcpy
               (
                  buf3,
                  "$n strikes at $N with a brutal crescent kick!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You attack $N with a crushing axe kick!"
               );
               strcpy
               (
                  buf2,
                  "$n attacks you with a crushing axe kick!"
               );
               strcpy
               (
                  buf3,
                  "$n attacks $N with a crushing axe kick!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You brutally headbutt $N!"
               );
               strcpy
               (
                  buf2,
                  "$n brutally headbutts you!"
               );
               strcpy
               (
                  buf3,
                  "$n brutally headbutts $N!"
               );
            }
            bonus = 5;
            break;
         }
         case (11):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You hurl a pair of sharp edged pyramids at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n hurls a pair of sharp edged pyramids at you!"
               );
               strcpy
               (
                  buf3,
                  "$n hurls a pair of sharp edged pyramids at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You drive a brutal claw into $N's face!"
               );
               strcpy
               (
                  buf2,
                  "$n drives a brutal claw into your face!"
               );
               strcpy
               (
                  buf3,
                  "$n drives a brutal claw into $N's face!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You leap at $N and lunge at $N's face with a mantis fist!"
               );
               strcpy
               (
                  buf2,
                  "$n leaps at you and lunges at your face with a mantis fist!"
               );
               strcpy
               (
                  buf3,
                  "$n leaps at $N and lunges at $N's face with a mantis fist!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You elbow $N in the face as you spin around and unleash a barrage of kicks!"
               );
               strcpy
               (
                  buf2,
                  "$n elbows $N in the face as $e spins around and unleashes a barrage of kicks!"
               );
               strcpy
               (
                  buf3,
                  "$n elbows $N in the face as $e spins around and unleashes a barrage of kicks!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You form your hands into the crane's beak fists and strike $N in the neck!"
               );
               strcpy
               (
                  buf2,
                  "$n forms $s hands into the crane's beak fists and strikes you in the neck!"
               );
               strcpy
               (
                  buf3,
                  "$n forms $s hands into the crane's beak fists and strikes $N in the neck!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You fly at $N, striking out with multiple palm strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n flies at you, striking out with multiple palm strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n flies at $N, striking out with multiple palm strikes!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You jump into the air and punch $N in the head!"
               );
               strcpy
               (
                  buf2,
                  "$n jumps into the air and punches you in the head!"
               );
               strcpy
               (
                  buf3,
                  "$n jumps into the air and punches $N in the head!"
               );
            }
            bonus = 6;
            break;
         }
         case (12):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You hurl a pair of triangular shuriken at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n hurls a pair of triangular shuriken at you!"
               );
               strcpy
               (
                  buf3,
                  "$n hurls a pair of triangular shuriken at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You jump over $N and slam a powerful claw into the back of $S head!"
               );
               strcpy
               (
                  buf2,
                  "$n jumps over you and slams a powerful claw into the back of your head!"
               );
               strcpy
               (
                  buf3,
                  "$n jumps over $N and slam a powerful claw into the back of $S head!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You focus your chi and fly at $N, kicking and punching rapidly!"
               );
               strcpy
               (
                  buf2,
                  "$n focuses $s chi and flies at you, kicking and punching rapidly!"
               );
               strcpy
               (
                  buf3,
                  "$n focuses $s chi and flies at $N, kicking and punching rapidly!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You slip behind $N and strike at $S pressure points from behind!"
               );
               strcpy
               (
                  buf2,
                  "$n slips behind you and strikes at your pressure points from behind!"
               );
               strcpy
               (
                  buf3,
                  "$n slips behind $N and strikes at $S pressure points from behind!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You crouch down low and rise up, striking $N with rapid crane's wings strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n crouches down low and rises up, striking you with rapid crane's wings strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n crouches down low and rises up, striking $N with rapid crane's wings strikes!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You duck down low and drive a mighty palm diagonally upward at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n ducks down low and drives a mighty palm diagonally upward at you!"
               );
               strcpy
               (
                  buf3,
                  "$n ducks down low and drives a mighty palm diagonally upward at $N!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You spin and strike $N with a roundhouse kick!"
               );
               strcpy
               (
                  buf2,
                  "$n spins and strikes you with a roundhouse kick!"
               );
               strcpy
               (
                  buf3,
                  "$n spins and strikes $N with a roundhouse kick!"
               );
            }
            bonus = 6;
            break;
         }
         case (13):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You hurl a pair of square shuriken at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n hurls a pair of square shuriken at you!"
               );
               strcpy
               (
                  buf3,
                  "$n hurls a pair of square shuriken at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You arch sideways and strike $N in the face and torso simultaneously!"
               );
               strcpy
               (
                  buf2,
                  "$n arches sideways and strikes you in the face and torso simultaneously!"
               );
               strcpy
               (
                  buf3,
                  "$n arches sideways and strikes $N in the face and torso simultaneously!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You focus your chi and fly at $N, kicking and punching rapidly!"
               );
               strcpy
               (
                  buf2,
                  "$n focuses $s chi and flies at you, kicking and punching rapidly!"
               );
               strcpy
               (
                  buf3,
                  "$n focuses $s chi and flies at $N, kicking and punching rapidly!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You crouch and launch a quick series of kicks at $N's legs!"
               );
               strcpy
               (
                  buf2,
                  "$n crouches and launches a quick series of kicks at your legs!"
               );
               strcpy
               (
                  buf3,
                  "$n crouches and launches a quick series of kicks at $N's legs!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You cartwheel toward $N and attacks $M with a series of crane's beak fists!"
               );
               strcpy
               (
                  buf2,
                  "$n cartwheels toward you and attacks you with a series of crane's beak fists!"
               );
               strcpy
               (
                  buf3,
                  "$n cartwheels toward $N and attacks $M with a series of crane's beak fists!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You spin and strike $N with a trio of palm strikes!"
               );
               strcpy
               (
                  buf2,
                  "$n spins and strikes you with a trio of palm strikes!"
               );
               strcpy
               (
                  buf3,
                  "$n spins and strikes $N with a trio of palm strikes!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You spin and strike $N with a low roundhouse kick!"
               );
               strcpy
               (
                  buf2,
                  "$n spins and strikes you with a low roundhouse kick!"
               );
               strcpy
               (
                  buf3,
                  "$n spins and strikes $N with a low roundhouse kick!"
               );
            }
            bonus = 6;
            break;
         }
         case (14):
         {
            if (ninjitsu)
            {
               strcpy
               (
                  buf1,
                  "You leap and fling a dart at $N!"
               );
               strcpy
               (
                  buf2,
                  "$n leaps and flings a dart at you!"
               );
               strcpy
               (
                  buf3,
                  "$n leaps and flings a dart at $N!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_TIGER)
            {
               strcpy
               (
                  buf1,
                  "You punch $N in the torso and strike $S face with a frontal claw strike!"
               );
               strcpy
               (
                  buf2,
                  "$n punches you in the torso and strikes your face with a frontal claw strike!"
               );
               strcpy
               (
                  buf3,
                  "$n punches $N in the torso and strikes $S head with a frontal claw strike!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_MANTIS)
            {
               strcpy
               (
                  buf1,
                  "You lunge and bring both mantis fists down on $N's face!"
               );
               strcpy
               (
                  buf2,
                  "$n lunges and brings both mantis fists down on your face!"
               );
               strcpy
               (
                  buf3,
                  "$n lunges and brings both mantis fists down on your face!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_SNAKE)
            {
               strcpy
               (
                  buf1,
                  "You spring back and then launch yourself at $N with a powerful snake fist combination!"
               );
               strcpy
               (
                  buf2,
                  "$n springs back and then launches $mself at you with a powerful snake fist combination!"
               );
               strcpy
               (
                  buf3,
                  "$n springs back and then launch $mself at $N with a powerful snake fist combination!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_CRANE)
            {
               strcpy
               (
                  buf1,
                  "You jump over $N and stab downward with multiple crane's beak fists!"
               );
               strcpy
               (
                  buf2,
                  "$n jumps over you and stabs downward with multiple crane's beak fists!"
               );
               strcpy
               (
                  buf3,
                  "$n jumps over $N and stabs downward with multiple crane's beak fists!"
               );
            }
            else if (school == SUBCLASS_SCHOOL_DRAGON)
            {
               strcpy
               (
                  buf1,
                  "You rapidly palm $N in the face and torso, alternating with each strike!"
               );
               strcpy
               (
                  buf2,
                  "$n rapidly palms you in the face and torso, alternating with each strike!"
               );
               strcpy
               (
                  buf3,
                  "$n rapidly palms $N in the face and torso, alternating with each strike!"
               );
            }
            else
            {
               strcpy
               (
                  buf1,
                  "You roll and punch $N in the torso!"
               );
               strcpy
               (
                  buf2,
                  "$n rolls and punches you in the torso!"
               );
               strcpy
               (
                  buf3,
                  "$n rolls and punches $N in the torso!"
               );
            }
            bonus = 6;
            break;
         }
      }
      act
      (
         buf1,
         ch,
         0,
         victim,
         TO_CHAR
      );
      act
      (
         buf2,
         ch,
         0,
         victim,
         TO_VICT
      );
      act
      (
         buf3,
         ch,
         0,
         victim,
         TO_NOTVICT
      );
      if (kung_fu)
      {
         check_improve
         (
            ch,
            gsn_kung_fu,
            TRUE,
            6
         );
      }
      if (ninjitsu)
      {
         check_improve
         (
            ch,
            gsn_corrupt("ninjitsu", &gsn_ninjitsu),
            TRUE,
            6
         );
      }
   }
   else
   {
      bonus = 0;
      if (kung_fu)
      {
         check_improve
         (
            ch,
            gsn_kung_fu,
            FALSE,
            6
         );
      }
      if (ninjitsu)
      {
         check_improve
         (
            ch,
            gsn_corrupt("ninjitsu", &gsn_ninjitsu),
            FALSE,
            6
         );
      }
   }
   if (bonus == 0)
   {
      return 0;
   }
   bonus = ch->level/2+dice(ch->level/5, bonus);
   return bonus;
}

void do_nerve(CHAR_DATA *ch,char *argument)
{
   char buf[MAX_STRING_LENGTH];
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA af;
   int chance;

   if ( (chance = get_skill(ch,gsn_nerve)) <= 0
   || /*ch->level < skill_table[gsn_nerve].skill_level[ch->class]*/
   !has_skill(ch,gsn_nerve))
   {
      send_to_char("You don't know how to use nerve pressure tactics.\n\r",ch);
      return;
   }

   one_argument(argument,arg);
   if (arg[0] == '\0')
   victim = ch->fighting;
   else
   victim = get_char_room(ch,arg);

   if (victim == NULL)
   {
      send_to_char("Attempt to put pressure on who's nerves?\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't do that.\n\r",ch);
      return;
   }
   if (check_peace(ch)) return;

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if (is_affected(victim,gsn_nerve))
   {
      send_to_char("They have already been weakened using nerve pressure.\n\r",ch);
      return;
   }


   chance += (ch->drain_level + ch->level - victim->level  - victim->drain_level)*3;
   chance -= get_curr_stat(victim,STAT_DEX)/3;
   chance += get_curr_stat(ch,STAT_DEX)/2;
   chance -= get_curr_stat(victim,STAT_CON)/3;

   if (number_percent() > chance)
   {
      act("$n grasps $N's arm but fails to apply the right pressure point.",ch,0,victim,TO_NOTVICT);
      act("You grasp $N's arm but fail to apply the right pressure point.",ch,0,victim,TO_CHAR);
      act("$n grasps your arm but fails to apply the right pressure point.",ch,0,victim,TO_VICT);
      check_improve(ch,gsn_nerve,FALSE,3);
      WAIT_STATE(ch,PULSE_VIOLENCE);
      /*        return;*/
   }
   else
   {
      if (oblivion_blink(ch, victim))
      {
         return;
      }
      act("$n grasps $N's arm and weakens $M with pressure points.",ch,0,victim,TO_NOTVICT);
      act("You grasp $N's arm and weaken $M with pressure points.",ch,0,victim,TO_CHAR);
      act("$n grasps your arm and weakens you with pressure point.",ch,0,victim,TO_VICT);
      check_improve(ch,gsn_nerve,TRUE,3);
      af.where = TO_AFFECTS;
      af.type = gsn_nerve;
      af.location = APPLY_STR;
      af.duration = ((ch->drain_level + ch->level)/5);
      af.bitvector = 0;
      af.modifier = -3;
      af.level = ch->drain_level + ch->level;
      affect_to_char(victim,&af);
      WAIT_STATE(ch,PULSE_VIOLENCE);
   }

   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (ch->fighting == NULL
   || victim->fighting == NULL) )
   {
      /* get_longname changed to PERS - Cirdan */
      sprintf(buf,"Help, %s is attacking me!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] nerved [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }
   if (victim->fighting == NULL)
   {
      multi_hit(victim,ch,TYPE_UNDEFINED);
   }

   return;
}

void do_endure(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;

   if ( (get_skill(ch,gsn_endure) <= 0)
   || /*ch->level < skill_table[gsn_endure].skill_level[ch->class]*/
   !has_skill(ch,gsn_endure))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_endure))
   {
      send_to_char("You already have the mental resolve to resist magic.\n\r",ch);
      return;
   }
   if (ch->mana < 35)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }


   if (number_percent() > get_skill(ch,gsn_endure))
   {
      send_to_char("You try to strengthen your mental resolve but fail.\n\r",ch);
      check_improve(ch,gsn_endure,FALSE,1);
      ch->mana -= 15;
      return;
   }

   send_to_char("You build up the mental resolve to better resist magic.\n\r",ch);
   check_improve(ch,gsn_endure,TRUE,1);
   af.where = TO_AFFECTS;
   af.type = gsn_endure;
   af.location = APPLY_SAVES;
   af.modifier = -2 - ch->level/8;
   af.level = ch->drain_level + ch->level;
   af.duration = (ch->drain_level + ch->level);
   af.bitvector = 0;
   affect_to_char(ch,&af);
   af.location = APPLY_SAVING_SPELL;
   af.modifier = -2 - ch->level/8;
   affect_to_char(ch,&af);
   af.location = APPLY_SAVING_TRANSPORT;
   af.modifier = -2 - ch->level/8;
   affect_to_char(ch,&af);
   af.location = APPLY_SAVING_MALEDICT;
   af.modifier = -2 - ch->level/8;
   affect_to_char(ch,&af);

   ch->mana -= 35;
   return;
}

void do_dragon_spirit(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;

   if ( (get_skill(ch,gsn_dragon_spirit) <= 0)
   || /*ch->level < skill_table[gsn_dragon_spirit].skill_level[ch->class]*/
   !has_skill(ch,gsn_dragon_spirit))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (ch->pcdata->learned[gsn_corrupt("subrank", &gsn_subrank)] < 9)
   {
      send_to_char("You are too inexperienced to use this technique.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_dragon_spirit))
   {
      send_to_char("Yours is already the spirit of a dragon.\n\r",ch);
      return;
   }
   if (ch->mana < 50)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }


   if (number_percent() > get_skill(ch,gsn_dragon_spirit))
   {
      send_to_char("You try to attain the spirit of a dragon, but fail.\n\r",ch);
      check_improve(ch,gsn_dragon_spirit,FALSE,1);
      ch->mana -= 20;
      return;
   }

   send_to_char("You will your spirit to be that of a dragon.\n\r",ch);
   check_improve(ch,gsn_dragon_spirit,TRUE,1);
   af.where = TO_AFFECTS;
   af.type = gsn_dragon_spirit;
   af.location = APPLY_HIT;
   af.modifier = (ch->level + ch->drain_level) * 2;
   af.level = ch->drain_level + ch->level;
   af.duration = (ch->drain_level + ch->level);
   af.bitvector = AFF_FLYING;
   affect_to_char(ch,&af);

   ch->mana -= 50;
   return;
}

void check_follow_through(CHAR_DATA* ch, CHAR_DATA* victim, int dam)
{
   int chance;

   chance = get_skill(ch, gsn_follow_through);

   if (/*ch->level <skill_table[gsn_follow_through].skill_level[ch->class]*/
   !has_skill(ch, gsn_follow_through))
   {
      return;
   }

   chance /= 2;
   chance -= number_range(0,15);

   if (chance <= 0)
   {
      return;
   }

   if (number_percent() < chance)
   {
      switch(number_range(1,5))
      {
         case(1):
         {
            act
            (
               "$n spins around strikes you with a follow through side kick!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You spin around strike $N with a follow through side kick!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n spins around strikes $N with a follow through side kick!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(2):
         {
            act
            (
               "$n spins around strikes you with a follow through roundhouse kick!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You spin around strike $N with a follow through roundhouse kick!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n spins around strikes $N with a follow through roundhouse kick!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(3):
         {
            act
            (
               "$n spins around strikes you with a low follow through turning kick!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You spin around strike $N with a low follow through turning kick!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n spins around strikes $N with a low follow through turning kick!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(4):
         {
            act
            (
               "$n spins around strikes you with a follow through tornado kick!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You spin around strike $N with a follow through tornado kick!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n spins around strikes $N with a follow through tornado kick!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(5):
         {
            act
            (
               "$n spins around strikes you with a follow through outside crescent kick!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You spin around strike $N with a follow through outside crescenct kick!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n spins around strikes $N with a follow through outside crescent kick!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
      }
      damage
      (
         ch,
         victim,
         4*dam/5,
         gsn_follow_through,
         DAM_BASH,
         TRUE
      );
      check_improve
      (
         ch,
         gsn_follow_through,
         TRUE,
         2
      );
   }
   else
   {
      check_improve
      (
         ch,
         gsn_follow_through,
         FALSE,
         3
      );
   }
   return;
}



void do_blindness_dust(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *vch;
   CHAR_DATA *vch_next;
   AFFECT_DATA af;
   int chance;
   bool fighting = FALSE;
   char buf[MAX_STRING_LENGTH];

   if ( (chance = get_skill(ch,gsn_blindness_dust)) <= 0
   || /*ch->level < skill_table[gsn_blindness_dust].skill_level[ch->class]*/
   !has_skill(ch,gsn_blindness_dust))
   {
      send_to_char("You don't know how to make blindness dust to throw.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (ch->mana < 18)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }
   if (number_percent() > chance)
   {
      act("$n hurls some dust into the air but it is blown away.",ch,0,0,TO_ROOM);
      send_to_char("You throw out some dust but it is blown away.\n\r",ch);
      ch->mana -= 9;
      check_improve(ch,gsn_blindness_dust,FALSE,2);
      WAIT_STATE(ch,12);
      return;
   }
   act("$n hurls a handful of dust into the room!",ch,0,0,TO_ROOM);
   send_to_char("You throw a handful of blindness dust into the room!\n\r",ch);
   check_improve(ch,gsn_blindness_dust,TRUE,2);
   if (ch->fighting != NULL)
   fighting = TRUE;

   af.where = TO_AFFECTS;
   af.type = gsn_blindness_dust;
   af.level = ch->drain_level + ch->level;
   af.duration = (ch->drain_level + ch->level)/5;
   af.bitvector = AFF_BLIND;
   af.location = APPLY_HIT;
   af.modifier = -3;
   ch->mana -= 18;
   WAIT_STATE(ch,12);
   for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
   {
      vch_next = vch->next_in_room;
      if (is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK))
      {
         continue;
      }
      if (is_same_group(ch,vch))
      continue;

      if (!IS_AFFECTED(vch,AFF_BLIND)
      && !saves_spell(ch,ch->drain_level + ch->level,vch,DAM_OTHER,SAVE_SPELL))
      {
         act("$n appears blinded.",vch,0,0,TO_ROOM);
         send_to_char("You get dust in your eyes.\n\r",vch);
         affect_to_char(vch,&af);
      }
      if (!IS_NPC(vch) && !IS_NPC(ch)
      && (vch->fighting == NULL || (!fighting)))
      {
         sprintf(buf,"Help! %s just threw dust in my eyes!",PERS(ch,vch));
         do_myell(vch,buf);
         sprintf(log_buf, "[%s] blindness dusted [%s] at %d", ch->name, vch->name, ch->in_room->vnum);
         log_string(log_buf);
      }

      if (vch->fighting == NULL)
      multi_hit(vch,ch,TYPE_UNDEFINED);

   }

   return;
}

void do_poison_dust(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   AFFECT_DATA af;
   int chance;
   bool fighting = FALSE;
   char buf[MAX_STRING_LENGTH];

   if
   (
      (
         chance = get_skill(ch, gsn_poison_dust)
      ) <= 0 ||
      !has_skill(ch, gsn_poison_dust)
   )
   {
      send_to_char("You do not know how to make poison dust to throw.\n\r", ch);
      return;
   }

   if (check_peace(ch))
   {
      return;
   }
   if (number_percent() > chance)
   {
      act
      (
         "$n hurls some dust into the air but it is blown away.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      send_to_char("You throw out some dust but it is blown away.\n\r", ch);
      WAIT_STATE(ch, 12);
      check_improve(ch, gsn_poison_dust, FALSE, 2);
      return;
   }
   act
   (
      "$n hurls a handful of dust into the room!",
      ch,
      NULL,
      NULL,
      TO_ROOM
   );
   send_to_char("You throw a handful of poison dust into the room!\n\r", ch);
   check_improve(ch, gsn_poison_dust, TRUE, 2);
   if (ch->fighting != NULL)
   {
      fighting = TRUE;
   }

   af.where     = TO_AFFECTS;
   af.type      = gsn_poison_dust;
   af.level     = ch->drain_level + ch->level;
   af.duration  = (ch->drain_level + ch->level) / 5;
   af.bitvector = AFF_POISON;
   af.location  = APPLY_STR;
   af.modifier  = -3;
   WAIT_STATE(ch, 12);
   for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
   {
      vch_next = vch->next_in_room;
      if
      (
         is_same_group(ch, vch) ||  /* Checks ch == vch */
         is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK) ||
         oblivion_blink(ch, vch)
      )
      {
         continue;
      }
      if
      (
         !saves_spell
         (
            ch,
            ch->drain_level + ch->level,
            vch,
            DAM_POISON,
            SAVE_SPELL
         )
      )
      {
         if (!IS_AFFECTED(vch, AFF_POISON))
         {
            act
            (
               "$n turns green and looks sick.",
               vch,
               NULL,
               NULL,
               TO_ROOM
            );
            send_to_char("You suddenly feel very sick.\n\r", vch);
            affect_to_char(vch, &af);
         }
         if
         (
            !IS_AFFECTED(vch, AFF_BLIND) &&
            number_percent() < 60
         )
         {
            af.bitvector = AFF_BLIND;
            af.location  = APPLY_HITROLL;
            af.duration  = 3;
            act
            (
               "$n appears blinded.",
               vch,
               NULL,
               NULL,
               TO_ROOM
            );
            send_to_char("You get dust in your eyes.\n\r", vch);
            affect_to_char(vch, &af);
            af.bitvector = AFF_POISON;
            af.location  = APPLY_STR;
            af.duration  = (ch->drain_level + ch->level) / 5;
         }
      }
      if
      (
         !IS_NPC(vch) &&
         !IS_NPC(ch) &&
         (
            vch->fighting == NULL ||
            !fighting
         )
      )
      {
         sprintf
         (
            buf,
            "Help! %s just threw dust in my eyes!",
            PERS(ch, vch)
         );
         do_myell(vch, buf);
         sprintf
         (
            log_buf,
            "[%s] poison dusted [%s] at %d",
            ch->name,
            vch->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
      }
      if (vch->fighting == NULL)
      {
         multi_hit(vch, ch, TYPE_UNDEFINED);
      }
   }
   return;
}

bool check_roll(CHAR_DATA *ch, CHAR_DATA *victim, int dt)
{
   int chance;

   if
   (
      (
         chance = get_skill(victim, gsn_roll)
      ) <= 0 ||
      !has_skill(victim, gsn_roll)
   )
   {
      return FALSE;
   }

   chance *= 4;
   chance /= 5;
   chance += get_curr_stat(victim,STAT_DEX);
   chance -= victim->carry_weight/100;
   if (number_percent() > chance)
   {
      check_improve(victim,gsn_roll,FALSE,2);
      return FALSE;
   }

   check_improve(victim,gsn_roll,TRUE,2);
   return TRUE;
}

void do_focus(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;
   if (get_skill(ch,gsn_focus)<=0)
   {
      send_to_char(" Huh?\n\r",ch);
      return;
   }

   if (ch->mana < 30)
   {
      send_to_char("You lack the mental energy.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_focus))
   {
      send_to_char("You are already empowered with killing ability.\n\r",ch);
      return;
   }

   if (number_percent() > get_skill(ch,gsn_focus))
   {
      send_to_char("Your find it difficult to focus your energies.\n\r",ch);
      ch->mana-=30;
      check_improve(ch,gsn_focus,FALSE,3);
      WAIT_STATE(ch,24);
      return;
   }
   af.where = TO_AFFECTS;
   af.type = gsn_focus;
   af.modifier = (ch->hitroll)+(ch->damroll);
   af.location = APPLY_HIT;
   af.duration = (ch->level)/5;
   af.bitvector = 0;
   af.level = ch->level;
   affect_to_char(ch,&af);
   af.location = APPLY_HITROLL;
   af.modifier = (ch->level)/6;
   affect_to_char(ch,&af);
   af.location = APPLY_DAMROLL;
   affect_to_char(ch,&af);
   af.location = APPLY_MOVE;
   af.modifier = (ch->level)*3;
   affect_to_char(ch,&af);
   send_to_char("You concentrate your mind into a perfect killing state.\n\r",ch);
   ch->mana-=60;
   check_improve(ch,gsn_focus,TRUE,4);
   return;
}

void do_darkfocus(CHAR_DATA* ch, char* argument)
{
   AFFECT_DATA af;

   if
   (
      !has_skill(ch, gsn_darkfocus) ||
      get_skill(ch, gsn_darkfocus) < 1
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   if (house_down(ch, HOUSE_ANCIENT))
   return;

   if (is_affected(ch, gsn_darkfocus))
   {
      send_to_char("You are already focused.\n\r", ch);
      return;
   }

   if (ch->mana < 35)
   {
      send_to_char("You are too tired to call on the focus of darkness.\n\r",ch);
      return;
   }

   ch->mana -= 35;

   WAIT_STATE(ch, 12);

   if (number_range(1, 100) > get_skill(ch, gsn_darkfocus))
   {
      send_to_char("You fail to focus.\n\r",ch);
      check_improve(ch, gsn_darkfocus, FALSE, 1);
      return;
   }

   check_improve(ch, gsn_darkfocus, TRUE, 1);

   send_to_char("You call on the darkness to focus on the hunts to come!\n\r",ch);

   af.where = TO_AFFECTS;
   af.type = gsn_darkfocus;
   af.modifier = 5;
   af.location = APPLY_HITROLL;
   af.duration = ch->drain_level + ch->level;
   af.bitvector = 0;
   af.level = ch->drain_level + ch->level;
   affect_to_char(ch,&af);
   af.location = APPLY_DAMROLL;
   affect_to_char(ch, &af);
   af.modifier = ch->level;
   af.location = APPLY_HIT;
   affect_to_char(ch, &af);
   ch->hit += 50;
   if (ch->hit > ch->max_hit) ch->hit = ch->max_hit;
   return;
}

void do_warcry(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;
   int chance;
   if ( (chance = get_skill(ch,gsn_warcry)) <= 0
   || /*ch->level < skill_table[gsn_warcry].skill_level[ch->class]*/
   !has_skill(ch,gsn_warcry))
   {
      send_to_char("You don't know how to warcry properly.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_warcry))
   {
      send_to_char("You are already affected by a warcry.\n\r",ch);
      return;
   }
   if (ch->mana < 20)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }

   if (number_percent() > chance)
   {
      act("$n makes some soft grunting noises.",ch,0,0,TO_ROOM);
      send_to_char("You make soft grunting sounds but nothing happens.\n\r",ch);
      check_improve(ch,gsn_warcry,FALSE,1);
      ch->mana -= 10;
      WAIT_STATE(ch,12);
      return;
   }

   act("$n lets out a blood freezing warcry!",ch,0,0,TO_ROOM);
   send_to_char("You let out a fierce warcry!\n\r",ch);
   check_improve(ch,gsn_warcry,TRUE,1);
   af.where = TO_AFFECTS;
   af.type = gsn_warcry;
   af.modifier = (ch->drain_level + ch->level)/10;
   af.location = APPLY_HITROLL;
   af.duration = ch->drain_level + ch->level;
   af.bitvector = 0;
   af.level = ch->drain_level + ch->level;
   affect_to_char(ch,&af);
   af.location = APPLY_SAVES;
   af.modifier = -3;
   affect_to_char(ch,&af);
   ch->mana -= 20;
   WAIT_STATE(ch,12);
   return;
}

void do_strangle(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   int chance;
   AFFECT_DATA af;

   one_argument(argument,arg);

   if ((chance = get_skill(ch,gsn_strangle)) <= 0
   || /*( ch->level < skill_table[gsn_strangle].skill_level[ch->class])*/
   !has_skill(ch,gsn_strangle) )
   {
      send_to_char("You don't know how to strangle properly.\n\r",ch);
      return;
   }

   if ( arg[0] == '\0' )
   {
      send_to_char( "Attempt to strangle who?\n\r", ch );
      return;
   }

   if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (victim == ch)
   {
      send_to_char("Try using a piece of rope and a high tree branch maybe?\n\r",ch);
      return;
   }
   if (is_affected(victim,gsn_strangle) && !IS_AWAKE(victim))
   {
      send_to_char("They are already lying on the ground unconcious.\n\r",ch);
      return;
   }
   if (victim->position == POS_FIGHTING)
   {
      send_to_char("They are moving around too much to strangle.\n\r",ch);
      return;
   }
   if (victim->race == grn_arborian)
   {
      send_to_char("You can't strangle them.\n\r",ch);
      return;
   }

   if (is_affected(victim,gsn_halo_of_eyes) && can_see(victim,ch) &&
   number_percent() < 30)
   {
      send_to_char("You notice one of the eyes surrounding them looking straight at you!\n\r",ch);
      chance = 0;
   }

   if (is_safe(ch,victim, 0))
   {
      return;
   }

   if (is_affected(victim,gsn_strangle) || is_affected(victim,gsn_corrupt("strangle timer", &gsn_strangle_timer)) )
   {
      send_to_char("They are guarding their necks too well right now.\n\r",ch);
      return;
   }

   af.where = TO_AFFECTS;
   af.level = victim->drain_level + ch->level;
   af.modifier = 0;
   af.location = 0;

   chance /= 2;
   chance += ( 2*(ch->drain_level + ch->level) - 2*(victim->drain_level + victim->level));
   chance -= get_curr_stat(victim,STAT_DEX)/2;
   chance += 10;
   if(is_affected(victim,gsn_cloak_form))
   chance+=20;
   if (chance > 65)
   chance = 65;
   if (IS_IMMORTAL(ch) && !IS_IMMORTAL(victim)) chance = 110;

   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   if (number_percent() < chance)
   {

      if (oblivion_blink(ch, victim))
      {
         return;
      }
      check_perception(ch, victim, "strangling someone");
      af.type = gsn_strangle;
      af.duration = 2;
      af.bitvector = 0; /* AFF_SLEEP;*/
      affect_to_char(victim,&af);

      af.type = gsn_corrupt("strangle timer", &gsn_strangle_timer);
      af.duration = 4;
      af.bitvector = 0;
      affect_to_char(victim,&af);

      act("$n grabs hold of $N's neck and puts them to sleep.",ch,0,victim,TO_NOTVICT);
      act("You grab hold of $N's neck and put them to sleep.",ch,0,victim,TO_CHAR);
      send_to_char("Someone grabs hold of your neck and puts you to sleep.\n\r",victim);
      victim->position = POS_SLEEPING;
      check_improve(ch,gsn_strangle,TRUE,2);
      if (!IS_NPC(ch) && !IS_IMMORTAL(ch) && !IS_IMMORTAL(victim))
      {
         if (!IS_NPC(victim) || IS_AFFECTED(victim,AFF_CHARM))
         {
            QUIT_STATE(ch, 20);
            QUIT_STATE(victim, 20);
         }
      }
      WAIT_STATE(ch,12);
      if (!IS_NPC(victim))
      {
         sprintf(log_buf, "[%s] strangled [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      return;
   }


   af.type = gsn_corrupt("strangle timer", &gsn_strangle_timer);
   af.bitvector = 0;
   af.duration = 2;
   affect_to_char(victim,&af);

   damage(ch,victim,0,gsn_strangle,DAM_BASH,TRUE);
   check_improve(ch,gsn_strangle,FALSE,2);
   WAIT_STATE(ch,12);
   if (!IS_NPC(ch) && !IS_NPC(victim))
   {
      if (number_percent() < 50)
      sprintf(buf,"Help! %s is trying to strangle me!",PERS(ch,victim));
      else
      sprintf(buf,"Help! %s just tried to strangle me!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] strangled [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }
   multi_hit(victim,ch,TYPE_UNDEFINED);
   return;
}

void do_stunning_strike(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   int chance;
   AFFECT_DATA af;

   one_argument(argument,arg);

   if ((chance = get_skill(ch,gsn_stunning_strike)) <= 0
   || /*( ch->level <skill_table[gsn_stunning_strike].skill_level[ch->class])*/
   !has_skill(ch,gsn_stunning_strike) )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (arg[0] == '\0'){
      send_to_char("Strike who?\n\r",ch);
      return;
   }
   if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (victim == ch)
   {
      send_to_char("You can't strike your own nerves.\n\r",ch);
      return;
   }
   if (IS_AFFECTED(victim, AFF_SLEEP) && !IS_AWAKE(victim))
   {
      send_to_char("They are already lying on the ground unconcious.\n\r",ch);
      return;
   }
   if (victim->position == POS_FIGHTING)
   {
      send_to_char("They are moving around too much.\n\r",ch);
      return;
   }
   if (victim->race == grn_arborian)
   {
      send_to_char("You can't stun them.\n\r",ch);
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if (is_affected(victim,gsn_stunning_strike_timer) )
   {
      send_to_char("They are guarding their necks too well right now.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   af.where = TO_AFFECTS;
   af.level = ch->drain_level + ch->level;
   af.modifier = 0;
   af.location = 0;

   chance /= 2;
   chance += ( 2*(ch->drain_level + ch->level) - 2*(victim->drain_level + victim->level));
   chance -= get_curr_stat(victim,STAT_DEX)/2;
   chance += 10;
   if(is_affected(victim,gsn_cloak_form))
   chance+=20;
   if (chance > 65)
   chance = 65;

   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   if (number_percent() < chance)
   {
      check_perception(ch, victim, "striking at someone's nerves");
      af.type = gsn_stunning_strike;
      af.duration = 2;
      af.bitvector = AFF_SLEEP;
      affect_to_char(victim,&af);

      af.duration = 4;
      af.type = gsn_stunning_strike_timer;
      af.bitvector = 0;
      affect_to_char(victim,&af);

      act("$n strikes at $N's nerves with deadly force! $N is knocked unconscious.",ch,0,victim,TO_NOTVICT);
      act("You strike at $N's nerves with deadly force, and put them to sleep.",ch,0,victim,TO_CHAR);
      send_to_char("Someone strikes at your nerves with deadly force, and knocks you unconscious.\n\r",victim);
      victim->position = POS_SLEEPING;
      check_improve(ch,gsn_stunning_strike,TRUE,2);
      if (!IS_NPC(ch) && !IS_IMMORTAL(ch) && !IS_IMMORTAL(victim))
      {
         if (!IS_NPC(victim) || IS_AFFECTED(victim,AFF_CHARM))
         {
            QUIT_STATE(ch, 20);
            QUIT_STATE(victim, 20);
         }
      }
      WAIT_STATE(ch,24);
      if (!IS_NPC(victim))
      {
         sprintf(log_buf, "[%s] stunning striked [%s] at %d", ch->name,
         victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      return;
   }


   af.type = gsn_stunning_strike_timer;
   af.bitvector = 0;
   af.duration = 2;
   affect_to_char(victim,&af);

   damage(ch,victim,0,gsn_stunning_strike,DAM_BASH,TRUE);
   check_improve(ch,gsn_stunning_strike,FALSE,2);
   WAIT_STATE(ch,24);
   if (!IS_NPC(ch) && !IS_NPC(victim))
   {
      if (number_percent() < 50)
      sprintf(buf,"Help! %s is trying to hit my nerves!",PERS(ch,victim));
      else
      sprintf(buf,"Help! %s just tried to strike my nerves!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] stunning striked [%s] at %d", ch->name,victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }
   multi_hit(victim,ch,TYPE_UNDEFINED);
   return;
}


void check_downstrike(CHAR_DATA* ch, CHAR_DATA* victim)
{
   OBJ_DATA* wield;
   int dam;
   int chance;

   if
   (
      (
         chance = get_skill(ch,gsn_downstrike)
      ) < 1 ||
      !has_skill(ch, gsn_downstrike)
   )
   {
      return;
   }

   chance /= 3;
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);
   chance -= get_curr_stat(victim, STAT_DEX)/3;
   chance += get_curr_stat(ch, STAT_DEX)/3;

   chance = URANGE(2, chance, 35);

   if (number_percent() > chance)
   {
      check_improve(ch, gsn_downstrike,FALSE,1);
      return;
   }


   wield = get_eq_char(ch,WEAR_WIELD);
   if (wield == NULL || wield->value[0]!=2)
   {
      wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   }
   if (wield == NULL || wield->value[0]!=2)
   {
      return;
   }

   dam = dice(wield->value[1], wield->value[2]);
   dam += ch->damroll;
   switch(number_range(1,5))
   {
      case(1):
      {
         act
         (
            "You strike at $N with a downward thrust of your dagger!",
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            "$n strikes at you with a downward thrust of $s dagger!",
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            "$n strikes at $N with a downward thrust of $s dagger!",
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(2):
      {
         act
         (
            "You drop and plunge a dagger into $N while $E is on the ground!",
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            "$n drops and plunges a dagger into you while you're on the ground!",
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            "$n drops and plunges a dagger into $N while $E is on the ground!",
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(3):
      {
         act
         (
            "You stab $N with a downward thrust of your dagger while $E is down!",
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            "$n stabs you with a downward thrust of $s dagger while you are down!",
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            "$n stabs $N with a downward thrust of $s dagger while $E is down!",
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(4):
      {
         act
         (
            "You ram your dagger into $N in a brutal downstrike!",
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            "$n rams $s dagger into you in a brutal downstrike!",
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            "$n rams $s dagger into $N in a brutal downstrike!",
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(5):
      {
         act
         (
            "You pin $N down with your foot and stab $M with your dagger!",
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            "$n pins you down with $s foot and stabs you with $s dagger!",
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            "$n pins $N down with $s foot and stabs $M with $s dagger!",
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
   }
   check_improve
   (
      ch,
      gsn_downstrike,
      TRUE,
      1
   );
   damage
   (
      ch,
      victim,
      dam,
      gsn_downstrike,
      attack_table[wield->value[3]].damage,
      TRUE
   );
   return;
}




void do_enlist(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   int level;
   char buf[MAX_STRING_LENGTH];
   AFFECT_DATA af;
   int chance;
   CHAR_DATA *check;

   chance = get_skill(ch,gsn_enlist);
   if (chance <= 10
   || /* ch->level < skill_table[gsn_enlist].skill_level[ch->class] */
   !has_skill(ch,gsn_enlist))
   {
      send_to_char("You do not have the skills required to enlist mercenary aid.\n\r",ch);
      return;
   }
   one_argument(argument,arg);
   if (is_affected(ch,gsn_enlist))
   {
      send_to_char("You haven't built up the nerve to recruit anyone else yet.\n\r",ch);
      return;
   }
   if (check_peace(ch)) return;

   if (arg[0] == '\0')
   {
      send_to_char("Who do you wish to enlist as a follower?\n\r",ch);
      return;
   }
   if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't recruit yourself.\n\r",ch);
      return;
   }
   if (!IS_NPC(victim))
   {
      send_to_char("Why not just ask them to join you?\n\r",ch);
      return;
   }
   for (check = char_list; check != NULL; check = check->next)
   {
      if (is_affected(check,gsn_enlist) && check->master == ch)
      {
         send_to_char("You already have a devoted recruit following you.\n\r",ch);
         return;
      }
   }

   if (!IS_SET(victim->act,ACT_WARRIOR))
   {
      send_to_char("You may only enlist the aid of those trained as warriors.\n\r",ch);
      return;
   }

   if (IS_SET(victim->act,ACT_PRACTICE) || IS_SET(victim->act,ACT_TRAIN))
   {
      send_to_char("Guildmasters and trainers have other business.\n\r",ch);
      return;
   }

   if( IS_SET(victim->imm_flags,IMM_CHARM) )
   {
      send_to_char("They refuse to follow you.\n\r",ch);
      return;
   }

   level = ch->drain_level + ch->level;

   if ((IS_GOOD(ch) && IS_EVIL(victim))
   || (IS_EVIL(ch) && IS_GOOD(victim)))
   level = 0;

   if ((IS_NEUTRAL(victim) && !IS_NEUTRAL(ch)) || (IS_NEUTRAL(ch) && !IS_NEUTRAL(victim)))
   level -= 2;

   if (IS_AFFECTED(victim,AFF_CHARM))
   level = 0;
   if ( (victim->level + 6) > level)
   level = 0;

   /* Aggressive mobs can no longer be enlisted - Wicket */
   if (IS_SET(victim->act,ACT_AGGRESSIVE))
   level = 0;

   if (saves_spell(victim,level,victim,DAM_OTHER,SAVE_SPELL) || level == 0 || number_percent() > chance)
   {
      if (IS_SET(victim->act,ACT_AGGRESSIVE))
      do_say(victim,"How dare you!");
      else
      if (number_percent() < 50)
      do_say(victim,"I don't follow scum such as you!");
      else
      do_say(victim,"You couldn't recruit a mangy dog to your company!");
      sprintf(buf,"Help! I'm being attacked by %s!",PERS(victim,ch));
      do_myell(ch,buf);
      check_improve(ch,gsn_enlist,FALSE,1);
      multi_hit(victim,ch,TYPE_UNDEFINED);
      return;
   }
   af.where = TO_AFFECTS;
   af.type = gsn_enlist;
   af.modifier = 0;
   af.level = ch->drain_level + ch->level;
   af.bitvector = AFF_CHARM;
   af.duration = ch->drain_level + ch->level;
   af.location = 0;
   affect_to_char(victim,&af);
   af.bitvector = 0;
   af.duration = 15;
   affect_to_char(ch, &af);
   add_follower(victim, ch);
   victim->leader = ch;
   act("$N salutes you and prepares to follow into combat.",ch,0,victim,TO_CHAR);
   act("$N salutes $n and falls into line with $m.",ch,0,victim,TO_NOTVICT);
   check_improve(ch,gsn_enlist,TRUE,1);
   return;
}



void do_tame(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   int chance;

   if ( (chance = get_skill(ch,gsn_tame)) <= 0
   ||   (!IS_NPC(ch)
   && /*ch->level < skill_table[gsn_tame].skill_level[ch->class]*/
   !has_skill(ch,gsn_tame)))
   {
      send_to_char("Your wilderness skills are not sufficient.\n\r",ch);
      return;
   }

   chance = get_skill(ch,gsn_tame);
   one_argument(argument,arg);
   if (arg[0] == '\0')
   victim = ch->fighting;
   else
   victim = get_char_room(ch,arg);
   if (victim == NULL)
   {
      send_to_char("They aren't here to tame though.\n\r",ch);
      return;
   }
   if (!IS_NPC(victim))
   {
      send_to_char("Why not just talk to them about your problems?\n\r",ch);
      return;
   }
   else if (!IS_SET(victim->act,ACT_AGGRESSIVE)
   && !IS_SET(victim->off_flags,SPAM_MURDER))
   {
      send_to_char("They are as tame as they can be.\n\r",ch);
      return;
   }

   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level)*3;
   if (chance > 90)        chance = 90;
   WAIT_STATE(ch,12);
   if (number_percent() > chance)
   {
      act("$n tries to calm down $N but fails.",ch,0,victim,TO_NOTVICT);
      act("$n tries to calm you down but fails.",ch,0,victim,TO_VICT);
      act("You try to calm $N down but fail.",ch,0,victim,TO_CHAR);
      check_improve(ch,gsn_tame,FALSE,2);
      return;
   }
   act("$n calms $N down.",ch,0,victim,TO_NOTVICT);
   act("You calm $N down.",ch,0,victim,TO_CHAR);
   act("$n calms you down.",ch,0,victim,TO_VICT);
   check_improve(ch,gsn_tame,TRUE,2);
   stop_fighting(victim,TRUE);
   victim->last_fought = -1;
   REMOVE_BIT(victim->act,ACT_AGGRESSIVE);
   REMOVE_BIT(victim->off_flags,SPAM_MURDER);
   return;
}

void do_find_water(CHAR_DATA *ch,char *argument)
{
   OBJ_DATA *spring;
   int chance;

   for (spring = ch->in_room->contents; spring != NULL; spring = spring->next_content)
   {
      if (spring->item_type == ITEM_FOUNTAIN)
      {
         send_to_char("A fountain already flows here.\n\r",ch);
         return;
      }
   }
   if (ch->in_room->sector_type == SECT_AIR ||
   ch->in_room->sector_type == SECT_WATER_SWIM ||
   ch->in_room->sector_type == SECT_WATER_NOSWIM ||
   !IS_OUTSIDE(ch))
   {
      send_to_char("You cannot find water here.\n\r",ch);
      return;
   }

   chance = get_skill(ch,gsn_find_water);
   if (chance > 95)        chance = 95;
   if (chance <= 0
   || /*ch->level < skill_table[gsn_find_water].skill_level[ch->class]*/
   !has_skill(ch,gsn_find_water))
   {
      send_to_char("You poke the ground with a stick but find no water that way.\n\r",ch);
      return;
   }
   if (ch->mana < 15)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }
   if (ch->in_room->sector_type == SECT_WATER_SWIM
   || ch->in_room->sector_type == SECT_UNDERWATER
   || ch->in_room->sector_type == SECT_WATER_NOSWIM)
   {
      send_to_char("Water water all around but not a drop to drink..\n\r",ch);
      return;
   }
   if (number_percent() > chance)
   {
      act("$n pokes the ground with a stick then scratches $s head.",ch,0,0,TO_ROOM);
      send_to_char("You poke about on the ground but fail to find any water.\n\r",ch);
      check_improve(ch,gsn_find_water,FALSE,1);
      ch->mana -= 7;
      WAIT_STATE(ch,18);
      return;
   }
   act("$n pokes at the ground and digs up a spring of natural water!",ch,0,0,TO_ROOM);
   send_to_char("You poke about for a bit and eventually dig up a spring of water.\n\r",ch);
   WAIT_STATE(ch,18);
   ch->mana -= 15;
   spring = create_object(get_obj_index(OBJ_VNUM_SPRING),0);
   REMOVE_BIT(spring->extra_flags,ITEM_MAGIC);
   free_string(spring->short_descr);
   free_string(spring->description);
   spring->short_descr = str_dup("a natural spring");
   spring->description = str_dup("A natural spring flows from the ground here.");
   if (immrp_blood) spring->value[2] = 14;
   check_improve(ch,gsn_find_water,TRUE,1);
   obj_to_room(spring,ch->in_room);
   return;
}

void do_track(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char buf[MAX_STRING_LENGTH];

   if (IS_NPC(ch))
   {
      /* hunter hounds */
      if (ch->pIndexData->vnum != animal_table[20].vnum)
      return;
      victim = get_char_world(NULL,argument);
      if (!str_cmp(argument,"none"))
      {
         send_to_char("Your hound stops tracking.\n\r",ch->master);
         ch->mprog_target = NULL;
         return;
      }
      if (victim == NULL || IS_IMMORTAL(victim))
      {
         send_to_char("Your hound doesn't know who you mean to track.\n\r",ch->master);
         return;
      }
      ch->mprog_target = victim;
      send_to_char("Your hound attempts to lock onto the scent.\n\r",ch->master);
      return;
   }
   if (!has_skill(ch,gsn_track) || get_skill(ch,gsn_track) <= 0)
   {
      send_to_char("You peer intently at the ground but discern nothing.\n\r",ch);
      return;
   }
   if (number_percent() > get_skill(ch,gsn_track))
   {
      act("$n peers intently at the ground but doesn't seem to find anything.",ch,0,0,TO_ROOM);
      send_to_char("You peer intently at the ground but uncover nothing new.\n\r",ch);
      check_improve(ch,gsn_track,FALSE,2);
      return;
   }
   check_improve(ch,gsn_track,TRUE,2);
   if (ch->in_room->sector_type == SECT_WATER_SWIM
   || ch->in_room->sector_type == SECT_WATER_NOSWIM
   || ch->in_room->sector_type == SECT_AIR)
   {
      send_to_char("There are no tracks here.\n\r",ch);
      return;
   }
   /* summarize tracks */
   act("$n peers at the ground and seems more enlightened.",ch,0,0,TO_ROOM);
   if (argument[0] == '\0')
   {
      int i;
      int id;
      char dir_name[10];

      send_to_char("You examine all the tracks you see:\n\r",ch);
      for (i=0;i<10;i++)
      {
         id = ch->in_room->track_dir[i][0];
         switch(ch->in_room->track_dir[i][1])
         {
            default:
            case DIR_NORTH+1:  sprintf(dir_name,"north"); break;
            case DIR_EAST+1:  sprintf(dir_name,"east"); break;
            case DIR_SOUTH+1:  sprintf(dir_name,"south"); break;
            case DIR_WEST+1:  sprintf(dir_name,"west"); break;
            case DIR_UP+1:  sprintf(dir_name,"up"); break;
            case DIR_DOWN+1:  sprintf(dir_name,"down"); break;
         }
         victim = id2name(id, FALSE);
         if (victim == NULL || IS_IMMORTAL(victim))
         continue;
         if (is_affected(victim, gsn_cloak_form) ) continue;
         sprintf(buf, "%s's tracks lead %s.\n\r", get_longname(victim,NULL), dir_name);
         send_to_char(buf,ch);
      }
      return;
   }
   victim = get_char_world(NULL,argument);
   if (victim == NULL || IS_IMMORTAL(victim) || is_affected(victim,gsn_cloak_form))
   {
      send_to_char("You are trying to track imaginary friends again?\n\r",ch);
      return;
   }

   if (IS_AFFECTED(ch, AFF_BLIND))
   {
      send_to_char("You cannot see to track.\n\r", ch);
      return;
   }

   switch (get_trackdir(ch,victim->id)-1)
   {
      case DIR_NORTH: send_to_char("The tracks leave north.",ch); break;
      case DIR_EAST:  send_to_char("The tracks leave east.",ch); break;
      case DIR_SOUTH: send_to_char("The tracks leave south.",ch); break;
      case DIR_WEST:  send_to_char("The tracks leave west.",ch); break;
      case DIR_UP:    send_to_char("The tracks leave up.",ch); break;
      case DIR_DOWN:  send_to_char("The tracks leave down.",ch); break;
      default: send_to_char("There is no sign of their tracks here.",ch);
   }
   send_to_char("\n\r", ch);

   return;
}

void do_shield_cleave(CHAR_DATA* ch, char* argument)
{
   char buf[MAX_STRING_LENGTH];
   char arg[MAX_INPUT_LENGTH];
   int chance;
   OBJ_DATA* weapon;
   OBJ_DATA* shield;
   bool using_primary = TRUE;
   CHAR_DATA* victim;

   one_argument(argument, arg);
   if (arg[0] == '\0')
   {
      victim = ch->fighting;
   }
   else
   {
      victim = get_char_room(ch, arg);
   }

   chance = get_skill(ch, gsn_shield_cleave);
   if
   (
      chance <= 0 ||
      !has_skill(ch, gsn_shield_cleave)
   )
   {
      send_to_char
      (
         "You do not know the methods to cleave a shield in two.\n\r",
         ch
      );
      return;
   }
   weapon = get_eq_char(ch, WEAR_WIELD);
   if
   (
      weapon == NULL ||
      (
         weapon->value[0] != WEAPON_SWORD &&
         weapon->value[0] != WEAPON_AXE &&
         weapon->value[0] != WEAPON_POLEARM
      )
   )
   {
      weapon = get_eq_char(ch, WEAR_DUAL_WIELD);
      using_primary = FALSE;
   }
   if
   (
      weapon == NULL ||
      (
         weapon->value[0] != WEAPON_SWORD &&
         weapon->value[0] != WEAPON_AXE &&
         weapon->value[0] != WEAPON_POLEARM
      )
   )
   {
      send_to_char
      (
         "You must be wielding an axe, sword, or pole-arm to shield cleave."
         "\n\r",
         ch
      );
      return;
   }
   if (victim == NULL)
   {
      send_to_char("But they are not here.\n\r", ch);
      return;
   }

   if (check_peace(ch))
   {
      return;
   }

   if (victim == ch)
   {
      send_to_char("That is not possible.\n\r", ch);
      return;
   }
   if ((shield = get_eq_char(victim, WEAR_SHIELD)) == NULL)
   {
      send_to_char("But they are not using a shield.\n\r", ch);
      return;
   }

   /* Shield cleave proof check */
   if (IS_SET(shield->extra_flags2, ITEM_NO_SHIELD_CLEAVE))
   {
      act
      (
         "Your $p harmlessly glances off $S shield!",
         ch,
         weapon,
         victim,
         TO_CHAR
      );
      act
      (
         "$n tries to cleave your shield but $s $p merely glances off!",
         ch,
         weapon,
         victim,
         TO_VICT
      );
      act
      (
         "$n's $p glances off $N's shield in a failed attempt to cleave it!",
         ch,
         weapon,
         victim,
         TO_NOTVICT
      );
      return;
   }
   /* Code addition by Wicket */
   if (is_safe(ch, victim, 0))
   {
      return;
   }
   /* End of addition */

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /* shield of justice -wervdon */
   if (shield->pIndexData->vnum == OBJ_VNUM_PROTECTORATE && shield->weight == 10)
   {
      send_to_char
      (
         "Your shield of justice returns their shield cleave!",
         victim
      );
      send_to_char
      (
         "Their Shield of Justice glows brightly and your shield cleave is returned!",
         ch
      );
      damage(victim, ch, dice(2, 6), gsn_cleave, DAM_SLASH, TRUE);
      if (number_percent() < 50)
      {
         return;
      }
   }
   if (shield->pIndexData->vnum == OBJ_VNUM_TRAITOR_SHIELD)
   {
      send_to_char("Not that easy to lose it.\n\r", victim);
      send_to_char
      (
         "The shield refuses to crack as though forged through divine power."
         "\n\r",
         ch
      );
      return;
   }
   chance *= 55;
   chance /= 100;
   chance += 2 * (ch->level - victim->level);
   chance -= (shield->level / 2);
   if (!using_primary)
   {
      chance -= 15;
   }
   chance += get_curr_stat(ch, STAT_STR);

   if
   (
      !IS_NPC(victim) &&
      ch->fighting != victim
   )
   {
      sprintf
      (
         buf,
         "Help! %s just shield cleaved me!",
         PERS(ch, victim)
      );
      do_myell(victim, buf);
   }
   if (number_percent() > chance)
   {
      act
      (
         "$n makes a mighty blow at $N's shield but fails to cleave it.",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      act
      (
         "$n lands a mighty blow to your shield but fails to cleave it.",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "You strike a mighty blow to $N's shield but fail to cleave it.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      check_improve(ch, gsn_shield_cleave, FALSE, 1);
      WAIT_STATE(ch, 12);
      multi_hit(victim, ch, -1);
      return;
   }
   act
   (
      "$n's mighty blow cleaves $N's shield in half!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   act
   (
      "Your mighty blow cleaves $N's shield in half!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n strikes your shield with powerful force, cleaving it in two!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   extract_obj(shield, FALSE);
   WAIT_STATE(ch, 12);
   check_improve(ch, gsn_shield_cleave, TRUE, 1);
   multi_hit(victim, ch, -1);

   return;
}

/* more race skills...Ceran */

void do_breath_fire(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;
   CHAR_DATA *victim;
   CHAR_DATA *vch;
   CHAR_DATA *vch_next;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   char buf_room[MAX_STRING_LENGTH];
   char buf_you[MAX_STRING_LENGTH];
   int dam, chance;
   int level;
   int dam_type = DAM_FIRE;
   int breath_sn = gsn_breath_fire;
   int area_effect = FALSE;

   level = ch->drain_level + ch->level;
   chance = get_skill(ch,gsn_breath_fire);
   if (chance <= 0
   || !has_skill(ch,gsn_breath_fire))
   {
      send_to_char("You aren't able to use dragon breaths.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   switch (ch->subrace)
   {
      default:
      area_effect = TRUE;
      dam_type = DAM_FIRE;
      breath_sn = gsn_breath_fire;
      sprintf(buf_room,"$n breathes forth a cone of searing flames!");
      sprintf(buf_you,"You breath forth a cone of searing flames!\n\r");
      break;
      case SCALE_GREEN:
      case SCALE_GOLD:
      area_effect = TRUE;
      dam_type = DAM_POISON;
      breath_sn = gsn_gas_breath;
      sprintf(buf_room,"$n breathes forth a cloud of green gas!");
      sprintf(buf_you,"You breath forth a cloud of green gas!\n\r");
      break;
      case SCALE_RED:
      case SCALE_BRASS:
      area_effect = TRUE;
      dam_type = DAM_FIRE;
      breath_sn = gsn_fire_breath;
      sprintf(buf_room,"$n breathes forth a cone of searing flames!");
      sprintf(buf_you,"You breath forth a cone of searing flames!\n\r");
      break;
      case SCALE_BLACK:
      case SCALE_COPPER:
      area_effect = TRUE;
      dam_type = DAM_ACID;
      breath_sn = gsn_acid_breath;
      sprintf(buf_room,"$n spits boiling acid!");
      sprintf(buf_you,"You spit boiling acid!\n\r");
      break;
      case SCALE_WHITE:
      case SCALE_SILVER:
      area_effect = TRUE;
      dam_type = DAM_COLD;
      breath_sn = gsn_frost_breath;
      sprintf(buf_room,"$n breathes forth a cone of frigid air!");
      sprintf(buf_you,"You breath forth a cone of frigid air!\n\r");
      break;
      case SCALE_BLUE:
      case SCALE_BRONZE:
      area_effect = TRUE;
      dam_type = DAM_LIGHTNING;
      breath_sn = gsn_lightning_breath;
      sprintf(buf_room,"$n breathes forth a stream of lightning!");
      sprintf(buf_you,"You breath forth a stream of lightning!\n\r");
      break;
   }
   if (is_affected(ch,gsn_breath_fire))
   {
      send_to_char("You haven't yet regained the ability to attack with breath.\n\r",ch);
      return;
   }

   one_argument(argument,arg);
   if (arg[0] == '\0')
   victim = ch->fighting;
   else
   victim = get_char_room(ch,arg);

   if (victim == NULL && !area_effect)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (ch->mana < 20)
   {
      send_to_char("You don't have the mana.\n\r",ch);
      return;
   }

   /*    if (number_percent() > chance)
   {
   send_to_char("You try to breath forth fire but only smokes comes out.\n\r",ch);
   act("$n opens $s mouth but only a thick plume of black smoke comes forth.",ch,0,0,TO_ROOM);
   ch->mana -= 10;
   check_improve(ch,gsn_breath_fire,FALSE,1);
   WAIT_STATE(ch, 12);
   return;
   } */

   af.where = TO_AFFECTS;
   af.type = gsn_breath_fire;
   af.location = 0;
   af.modifier = 0;
   af.duration = 4;
   af.bitvector = 0;
   af.level = ch->drain_level + ch->level;
   affect_to_char(ch,&af);
   dam = dice(level,6);

   act(buf_room,ch,0,0,TO_ROOM);
   send_to_char(buf_you,ch);

   if (area_effect)
   {
      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         vch_next = vch->next_in_room;
         if (is_same_group(vch,ch) )
         continue;
         if (is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK)) continue;
         if (oblivion_blink(ch, vch))
         {
            continue;
         }
         if (!IS_NPC(ch) && !IS_NPC(vch)
         && (ch->fighting == NULL || vch->fighting == NULL))
         {
            switch(ch->subrace)
            {
               default:
               case SCALE_RED:
               case SCALE_BRASS:
               sprintf(buf,"Help! %s is incinerating me with dragonfire!",PERS(ch,victim));
               break;
               case SCALE_BLUE:
               case SCALE_BRONZE:
               sprintf(buf,"Help! %s is breathing lightning on me!",PERS(ch,victim));
               break;
               case SCALE_COPPER:
               case SCALE_BLACK:
               sprintf(buf,"Help! %s is spraying boiling acid on me!",PERS(ch,victim));
               break;
               case SCALE_GOLD:
               case SCALE_GREEN:
               sprintf(buf,"Help! %s is breathing noxious gas!",PERS(ch,victim));
               break;
               case SCALE_WHITE:
               case SCALE_SILVER:
               sprintf(buf,"Help! %s is breathing frigid air on me!",PERS(ch,victim));
               break;
            }
            if (vch != ch)
            {
               do_myell(vch,buf);
               sprintf(log_buf, "[%s] breathed on [%s] at %d", ch->name, vch->name, ch->in_room->vnum);
               log_string(log_buf);
            }
         }
         dam = dice(level,6);
         if ( saves_spell( ch, level, vch, dam_type, SAVE_BREATH) )
         dam /= 2;
         damage( ch, vch, dam, breath_sn, dam_type ,TRUE);
         if (vch == NULL) continue;
         if (!saves_spell(ch,level-2,vch,dam_type,SAVE_BREATH))
         {
            switch(dam_type)
            {
               default:  break;
               case DAM_POISON:
               poison_effect(vch,level,dam,TARGET_CHAR);
               break;
               case DAM_FIRE:
               fire_effect(vch,level,dam,TARGET_CHAR);
               break;
               case DAM_COLD:
               cold_effect(vch,level,dam,TARGET_CHAR);
               break;
            }
         }
      }
   }
   else
   {
      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (victim->fighting == NULL || ch->fighting == NULL))
      {
         if (breath_sn == gsn_acid_breath)
         sprintf(buf,"Help! %s is blasting me with acidic breath!",PERS(ch,victim));
         else if (breath_sn == gsn_lightning_breath)
         sprintf(buf,"Help! %s is breathing lightning bolts on me!",PERS(ch,victim));
         else
         sprintf(buf,"Help! %s is incinerating me with dragonfire!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] breathed on [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      if ( saves_spell( ch,level, victim, dam_type, SAVE_BREATH ) )
      dam /= 2;
      if (is_safe(ch, victim, 0)) return;
      damage( ch, victim, dam, breath_sn, dam_type,TRUE);
      /* special for acid & lightning here */
      if (victim != NULL && !saves_spell(ch,level-2,victim,dam_type,SAVE_BREATH))
      {
         if (dam_type == DAM_LIGHTNING)
         shock_effect(victim,level,dam,TARGET_CHAR);
         else if (dam_type == DAM_ACID)
         acid_effect(victim,level,dam,TARGET_CHAR);
      }
   }
   check_improve(ch,gsn_breath_fire,TRUE,1);
   WAIT_STATE(ch, 12);
   return;
}

void do_psionic_blast(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   int dam;
   int sn;
   AFFECT_DATA af;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];

   if
   (
      ch->race != grn_illithid &&
      ch->race != grn_demon
   )
   {
      send_to_char("Only illithids have the ability to project a psionic blast.\n\r",ch);
      return;
   }

   if ( !IS_NPC(ch)
   &&  /* ch->level < skill_table[gsn_psionic_blast].skill_level[ch->class]*/
   !has_skill(ch,gsn_psionic_blast))
   {
      send_to_char(
      "You do not have that ability yet.\n\r", ch );
      return;
   }
   if (check_peace(ch)) return;

   one_argument(argument,arg);
   if (arg[0] == '\0')
   {
      if ((victim = ch->fighting) == NULL)
      {
         send_to_char("Direct your blast at whom?\n\r",ch);
         return;
      }
   }
   else
   victim = get_char_room(ch,arg);

   if (victim == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if ( ch->mana < 100 )
   {
      send_to_char("You don't have enough mental energy to project a blast.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_psionic_blast))
   {
      send_to_char("You cannot project another psionic blast yet.\n\r",ch);
      return;
   }
   if (is_safe(ch, victim, 0))
   {
      return;
   }
   ch->mana -= 100;
   dam = dice(ch->level,5);

   if (check_shadowstrike(ch, FALSE, TRUE))
   {
      return;
   }
   af.where = TO_AFFECTS;
   af.type = gsn_psionic_blast;
   af.location = 0;
   af.modifier = 0;
   af.duration = 4;
   af.bitvector = 0;
   af.level = ch->level;
   affect_to_char(ch,&af);


   if (oblivion_blink(ch, victim))
   {
      return;
   }
   if ( saves_spell(ch, ch->level+(ch->level-victim->level),victim,DAM_MENTAL, SAVE_OTHER)
   || saves_armor_of_god(ch, ch->level, victim) )
   {
      dam = dam/2;
      if (!IS_NPC(victim)
      && (victim->fighting == NULL || ch->fighting == NULL))
      {
         sprintf(buf,"Get out of my mind, %s!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] psionic blasted [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }

      act("$n reels as $s mind is assaulted with psionic energy!",victim,0,0,TO_ROOM);
      send_to_char("You reel as waves of psionic energy assault your mind!\n\r",victim);
      damage( ch, victim, dam, gsn_psionic_blast,DAM_MENTAL, TRUE );
      check_improve(ch,gsn_psionic_blast,FALSE,1);
      WAIT_STATE(ch, (2 * PULSE_VIOLENCE));
      return;
   }

   if (!IS_NPC(victim)
   && (victim->fighting == NULL || ch->fighting == NULL))
   {
      sprintf(buf,"Get out of my mind, %s!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] psionic blasted [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }

   act("$n reels as $s mind succumbs to a vicious psionic assault!",victim,0,0,TO_ROOM);
   send_to_char("Waves of psionic energy pummel your brain mercilessly!\n\r",victim);
   if (victim->daze == 0)
   {
      DAZE_STATE(victim, (3 * PULSE_VIOLENCE));
   }
   sn = gsn_weaken;
   magic_spell_vict(ch, victim, CAST_BITS_PLR_SKILL, ch->level, sn);
   sn = gsn_blindness;
   magic_spell_vict(ch, victim, CAST_BITS_PLR_SKILL, ch->level, sn);
   WAIT_STATE(ch, (2 * PULSE_VIOLENCE));
   damage( ch, victim, dam, gsn_psionic_blast,DAM_MENTAL, TRUE );
   check_improve(ch,gsn_psionic_blast,TRUE,3);

   return;
}

void do_rear_kick(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   int dam;
   int chance;
   OBJ_DATA* obj;
   int part;
   static const char* body[3] =
   {
      "face",
      "head",
      "torso"
   };

   if (ch->race != grn_centaur)
   {
      send_to_char("You do not have a centaur's rear legs to kick like that.\n\r", ch);
      return;
   }

   if
   (
      !IS_NPC(ch) &&
      !has_skill(ch, gsn_rear_kick)
   )
   {
      send_to_char("You do not have the ability to rear kick yet.\n\r", ch);
      return;
   }

   if
   (
      IS_NPC(ch) &&
      !IS_SET(ch->off_flags, OFF_KICK)
   )
   {
      return;
   }

   one_argument(argument, arg);

   victim = get_char_room(ch, arg);
   if (arg[0] == '\0')
   {
      victim = ch->fighting;
   }
   if (victim == NULL)
   {
      send_to_char("You are not fighting anyone.\n\r", ch);
      return;
   }
   if
   (
      is_safe(ch, victim, 0) ||
      check_peace(ch)
   )
   {
      return;
   }
   if (victim == ch)
   {
      send_to_char("And how are you going to manage to do that?\n\r", ch);
      return;
   }
   if
   (
      victim->position < POS_FIGHTING ||
      victim->daze > 0
   )
   {
      act
      (
         "You will have to let $M get back up first.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }
   WAIT_STATE(ch, 24);
   act
   (
      "$n whips about and kicks out with $s hind legs!",
      ch,
      NULL,
      NULL,
      TO_ROOM
   );
   act
   (
      "You whip about and kick out with your hind legs!",
      ch,
      NULL,
      NULL,
      TO_CHAR
   );
   if (oblivion_blink(ch, victim))
   {
      return;
   }
   part = number_range(0, sizeof(body) / sizeof(body[0]) - 1);
   if
   (
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      ) &&
      !IS_NPC(victim) &&
      !IS_NPC(ch)
   )
   {
      sprintf
      (
         log_buf,
         "Help! %s is rear kicking my %s!",
         PERS(ch, victim),
         body[part]
      );
      do_myell(victim, log_buf);
      sprintf
      (
         log_buf,
         "%s rear kicked %s at Room [%d].",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   chance = (ch->level - victim->level) * 2 + 50;
   if ((obj = get_eq_char(ch, WEAR_FOURHOOVES)))
   {
      chance += (obj->level) / 2;
   }
   chance += get_curr_stat(ch, STAT_DEX) / 3;
   chance -= get_curr_stat(victim, STAT_DEX) / 2;


   if (number_percent() > chance)
   {
      damage(ch, victim, 0, gsn_rear_kick, DAM_BASH, TRUE);
      return;
   }
   act
   (
      "$n is sent sprawling from a kick to the $t!",
      victim,
      body[part],
      NULL,
      TO_ROOM
   );
   act
   (
      "$n kicks you in the $t and sends you flying backwards!",
      ch,
      body[part],
      victim,
      TO_VICT
   );
   DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
   dam = number_range(ch->level/2,ch->level);
   dam += get_curr_stat(ch,STAT_STR);
   dam += number_range(1,ch->drain_level + ch->level);
   dam += number_range((ch->drain_level + ch->level)/4, (ch->drain_level + ch->level)/2);

   if (dam < 1)
   dam = 1;
   if (dam > 140)
   dam = 140;

   damage( ch, victim, dam, gsn_rear_kick,DAM_BASH, TRUE );
   return;
}

void do_multistrike(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *vch;
   CHAR_DATA *vch_next;
   int chance;

   if((chance=get_skill(ch,gsn_multistrike)) <= 0 ||
   (!IS_NPC(ch)&&
   /*ch->level<skill_table[gsn_multistrike].skill_level[ch->class]*/
   !has_skill(ch,gsn_multistrike))) {
      send_to_char("You have not mastered that technique.\n\r", ch);
      return;
   }

   if(!IS_SET(ch->act,PLR_HONORBOUND) && !IS_IMMORTAL(ch)) {
      send_to_char("Only the honorbound have the discipline.\n\r", ch);
      return;
   }

   if (check_peace(ch)) return;

   if (house_down(ch,HOUSE_CRUSADER))
   return;

   if(ch->position!=POS_FIGHTING) {
      send_to_char("You must be fighting to strike at your foes.\n\r", ch);
      return;
   }

   if(number_percent() < chance) {
      send_to_char("Your battle prowess allows you to strike at all of your foes!\n\r",ch);
      for(vch=ch->in_room->people; vch!=NULL;vch=vch_next) {
         vch_next=vch->next_in_room;
         if(vch->fighting==ch) {
            if(number_percent()<25) {
               send_to_char("You deliver a stunning blow!\n\r",ch);
               send_to_char("You stagger under the force of the blow!\n\r",vch);
               WAIT_STATE(vch,24);
            }
            one_hit(ch,vch,TYPE_UNDEFINED);
         }
      }
      check_improve(ch,gsn_multistrike,TRUE,1);
      WAIT_STATE(ch,skill_table[gsn_multistrike].beats);
   }
   else
   {
      send_to_char("You stumble while attempting to strike out at your foes.\n\r",ch);
      check_improve(ch,gsn_multistrike,FALSE,1);
      WAIT_STATE(ch,(skill_table[gsn_multistrike].beats)/2);
   }
   return;
}






/* Wings of fallen angel..put in multi_hit, right after 1st and 2nd attacks
*/
void wing_beating(CHAR_DATA *ch)
{
   OBJ_DATA *wings;
   CHAR_DATA *vch;
   int sn_windwall;
   int dam;

   if (IS_NPC(ch))
   return;

   if ( (wings = get_eq_char(ch,WEAR_ABOUT) ) == NULL)
   return;
   if (wings->pIndexData->vnum != OBJ_VNUM_WINGS)
   return;

   if (number_percent() > 6)
   return;
   act("The shredded wings on $n's back unfold and beat with savage force!",ch,0,0,TO_ROOM);
   send_to_char("The shredded wings on your back unfold and beat with savage force!\n\r",ch);
   sn_windwall = gsn_windwall;
   if (sn_windwall == -1)
   return;

   for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
   {
      if (vch->fighting == ch && number_percent() < 40)
      break;
   }

   if (vch == NULL)
   vch = ch->fighting;
   if (vch == NULL)
   return;
   dam = dice(45,4);
   if (saves_spell(ch, 45,vch, DAM_BASH, SAVE_OTHER))
   dam /= 2;
   damage(ch,vch,dam, sn_windwall, DAM_BASH,TRUE);
   return;
}


bool check_crown_blood(CHAR_DATA* ch, CHAR_DATA* victim, int dt, int dam, int dam_type)
{
   OBJ_DATA* obj;
   int mod;
   char* attack;
   mod = 0;

   if
   (
      (
         dam_type != DAM_COLD &&
         dam_type != DAM_NEGATIVE
      ) ||
      (
         obj = get_eq_char(victim, WEAR_HEAD)
      ) == NULL ||
      obj->pIndexData->vnum != OBJ_VNUM_CROWN_BLOOD ||
      !saves_spell(ch, ch->level,victim,DAM_COLD, SAVE_OTHER)
   )
   {
      return FALSE;
   }

   if
   (
      dt > 0 &&
      dt < MAX_SKILL
   )
   {
      attack      = skill_table[dt].noun_damage;
   }
   else if
   (
      dt >= TYPE_HIT &&
      dt < TYPE_HIT + MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[dt - TYPE_HIT].noun;
   }
   else
   {
      bug("Dam_message: bad dt %d.", dt);
      dt = TYPE_HIT;
      attack = attack_table[0].name;
   }

   act
   (
      "$N's crown glows and $E is unaffected by $n's $t!",
      ch,
      attack,
      victim,
      TO_NOTVICT
   );
   act
   (
      "Your crown glows and you are unaffected by $n's $t!",
      ch,
      attack,
      victim,
      TO_VICT
   );
   act
   (
      "$N's crown glows blue and $E is unaffected by your $t!",
      ch,
      attack,
      victim,
      TO_CHAR
   );

   if (IS_NPC(victim))
   {
      return TRUE;
   }

   if (dam < 30)
   {
      mod = -5;
   }
   else if (dam < 50)
   {
      mod = -4;
   }
   else if (dam < 80)
   {
      mod = -2;
   }
   else if (dam < 120)
   {
      mod = -1;
   }
   else if (dam < 180)
   {
      mod = 0;
   }
   else if (dam < 350)
   {
      mod = 1;
   }
   else if (dam < 450)
   {
      mod = 2;
   }
   else if (dam < 600)
   {
      mod = 3;
   }
   else if (dam < 750)
   {
      mod = 4;
   }
   else
   {
      mod += 6;
   }

   /*
   Two chances to save.
   If save either time,
   keep the crown, else destroy it.
   */
   if
   (
      saves_spell
      (
         victim,
         51 + mod,
         victim,
         DAM_OTHER,
         SAVE_OTHER
      ) ||
      saves_spell
      (
         victim,
         51 + mod,
         victim,
         DAM_OTHER,
         SAVE_OTHER
      )
   )
   {
      return TRUE;
   }
   act
   (
      "$N's crown of frozen blood shudders and explodes!",
      victim,
      NULL,
      NULL,
      TO_ROOM
   );
   send_to_char
   (
      "Your crown of frozen blood shudders and explodes!\n\r",
      victim
   );
   extract_obj(obj, FALSE);
   return TRUE;
}

void check_bracelets(CHAR_DATA *ch)
{
   OBJ_DATA *obj1;
   OBJ_DATA *obj2;
   CHAR_DATA *vch;
   int sn_dispel;
   bool hair_1 = FALSE, hair_2 = FALSE, blood_1 = FALSE, blood_2 = FALSE;

   if (IS_NPC(ch))
   return;

   obj1 = get_eq_char(ch,WEAR_WRIST_L);
   if (obj1 != NULL)
   {
      if (obj1->pIndexData->vnum == OBJ_VNUM_HAIR_BRACELET)
      hair_1 = TRUE;
      else if (obj1->pIndexData->vnum == OBJ_VNUM_BLOOD_BRACELET)
      blood_1 = TRUE;
   }

   obj2 = get_eq_char(ch,WEAR_WRIST_R);
   if (obj2 != NULL)
   {
      if (obj2->pIndexData->vnum == OBJ_VNUM_HAIR_BRACELET)
      hair_2 = TRUE;
      else if (obj2->pIndexData->vnum == OBJ_VNUM_BLOOD_BRACELET)
      blood_2 = TRUE;
   }
   if (!hair_1 && !hair_2 && !blood_1 && !blood_2)
   return;


   if ( (vch = ch->fighting) == NULL)
   return;
   if (!IS_EVIL(vch) && ((hair_1) || (hair_2)) )
   return;
   if (!IS_GOOD(vch) && ((blood_1) || (blood_2)) )
   return;

   if ((blood_1) || (blood_2))
   sn_dispel = gsn_dispel_good;
   else
   sn_dispel = gsn_dispel_evil;

   if (blood_1 && number_percent() < 12)
   {
      act("The blood on $n's bracelet hisses and steams.",ch,0,0,TO_ROOM);
      act("The blood on your bracelet hisses and steams.",ch,0,0,TO_CHAR);
      magic_spell_vict(ch, vch, CAST_BITS_PLR_SKILL, 55, sn_dispel);
   }
   if (vch->in_room != ch->in_room
   || vch->ghost > 0)
   return;

   if (blood_2 && number_percent() < 10)
   {
      act("The blood on $n's bracelet hisses and steams.",ch,0,0,TO_ROOM);
      act("The blood on your bracelet hisses and steams.",ch,0,0,TO_CHAR);
      magic_spell_vict(ch, vch, CAST_BITS_PLR_SKILL, 55, sn_dispel);
      return;
   }
   if (hair_1 && number_percent() < 12)
   {
      act("The hair on $n's bracelet shimmers softly.",ch,0,0,TO_ROOM);
      act("The hair on your bracelet shimmers softly.",ch,0,0,TO_CHAR);
      magic_spell_vict(ch, vch, CAST_BITS_PLR_SKILL, 55, sn_dispel);
   }

   if (vch->in_room != ch->in_room
   || vch->ghost > 0)
   return;

   if (hair_2 && number_percent() < 10)
   {
      act("The hair on $n's bracelet shimmers softly.",ch,0,0,TO_ROOM);
      act("The hair on your bracelet shimmers softly.",ch,0,0,TO_CHAR);
      magic_spell_vict(ch, vch, CAST_BITS_PLR_SKILL, 55, sn_dispel);
   }
   return;
}


void check_runge_brand(CHAR_DATA *ch, CHAR_DATA *victim)
{
   int sn;
   int dam;
   int level;
   AFFECT_DATA af;
   OBJ_DATA *obj;

   obj = get_eq_char(ch,WEAR_BRAND);
   if ((!is_name("level2", obj->name)) && (!is_name("level3",obj->name)))
   return;

   if (number_percent() <9)
   {
      send_to_char("Your waning crescent brand flares a bright amber!\n\r",ch);
      act("$n's waning crescent brand flares a bright amber!",ch,NULL,NULL,TO_ROOM);
      sn = gsn_worm_brand;
      level = ch->level;
      dam = dice((victim->perm_stat[STAT_CON]),9);
      damage(ch,victim,dam,gsn_worm_brand,DAM_OTHER,TRUE);
      ch->hit += dam/3;
      ch->mana += dam/3;
      if (!is_affected(victim,gsn_worm_brand))
      {
         af.where        = TO_AFFECTS;
         af.type         = gsn_worm_brand;
         af.level        = level;
         af.duration     = (victim->perm_stat[STAT_CON])/2;
         af.location     = APPLY_STR;
         af.modifier     = 0-(ch->level)/8;
         af.bitvector    = 0;
         affect_to_char(victim,&af);
         af.location    = APPLY_WIS;
         affect_to_char(victim, &af);
      }
      return;
   }
   return;
}

void check_honor_bracer(CHAR_DATA *ch)
{
   if (number_percent() > 3) return;
   send_to_char("..................................................\n\r",ch);
   send_to_char("Your bracer seems to glow, and you hear its words:\n\r",ch);
   switch (number_range(1,5))
   {
      case 1:
      send_to_char("Glory is the lifeblood. Acting with cowardice or without an\n\reye to Glory is unbecoming.\n\r",ch);
      break;
      case 2:
      send_to_char("To dishonor yourself is to bring shame to all your brethren. To maintain honor\n\ris to bring glory to yourself and your brethren.\n\r",ch);
      break;
      case 3:
      send_to_char("To return at least half a man's possessions is honorable,\n\rand will cause your enemies to respect you.\n\r",ch);
      break;
      case 4:
      send_to_char("Never fight at uneven odds against your enemy, if you will maintain\n\rpersonal honor and bring glory to yourself and your brethren.\n\r",ch);
      break;
      case 5:
      send_to_char("He who fights against greater numbers or a more powerful foe and\n\rwins is victorious indeed, for not only does he win a battle,\n\rbut he is remembered in times to come for his bravery.\n\r",ch);
   }
   send_to_char("..................................................\n\r",ch);
   return;
}

void check_blue_talon(CHAR_DATA *ch, CHAR_DATA *victim)
{
   if (number_percent() < 10)
   {
      send_to_char("Electricity from the blue talon jolts you violently!\n\r",victim);
      act("Electricity from the blue talon jolts $n!",victim,NULL,NULL,TO_ROOM);
      magic_spell_vict(ch, victim, CAST_BITS_PLR_SKILL, ch->level, gsn_shocking_grasp);
      return;
   }
   return;
}


/* Flesh-cutter code */
/* In check_palm strike:
if ((is_affected(ch,gsn_mutilated_left_hand)
|| is_affected(ch,gsn_mutilated_right_hand)
&& number_percent() > ch->level )
{
send_to_char("The nerves in your hand spasm and you fail the palm strike.\n\r",ch);
}
*/


int check_cutter(CHAR_DATA *ch,CHAR_DATA *victim)
{
   int cut;
   int part;
   AFFECT_DATA af;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char *part_name;

   if (number_percent() > 4
   || saves_spell(ch, ch->level - 5,victim,DAM_SLASH, SAVE_OTHER))
   return 1;

   if (IS_SET(ch->form,FORM_INTANGIBLE)
   || IS_SET(ch->form,FORM_MIST)
   || IS_SET(ch->form,FORM_SNAKE)
   || IS_SET(ch->form,FORM_INSECT)
   || IS_SET(ch->form,FORM_WORM)
   || IS_SET(ch->form,FORM_BLOB)
   || IS_SET(ch->form,FORM_FISH)
   || IS_SET(ch->form,FORM_BIRD))
   return 1;

   part = number_range(0,11);
   cut = 1;
   part_name = "left hand";
   af.where = TO_AFFECTS;
   af.duration = 3;
   af.bitvector = 0;
   af.level = ch->level;

   switch(part)
   {
      case (0): case (1): case (2):       /* left arm */
      if (is_affected(victim,gsn_mutilated_left_arm)
      || !IS_SET(victim->parts,PART_ARMS))
      return 1;
      part_name = "left arm";
      af.type = gsn_mutilated_left_arm;
      af.modifier = -3;
      af.location = APPLY_HITROLL;
      affect_to_char(victim,&af);
      af.modifier = -3;
      af.location = APPLY_DAMROLL;
      affect_to_char(victim,&af);
      cut = 2;
      break;
      case (3): case (4): case (5): /* right arm */
      if (is_affected(victim,gsn_mutilated_right_arm)
      || !IS_SET(victim->parts,PART_ARMS))
      return 1;
      part_name = "right arm";
      af.type = gsn_mutilated_right_arm;
      af.modifier = -3;
      af.location = APPLY_HITROLL;
      affect_to_char(victim,&af);
      af.modifier = -3;
      af.location = APPLY_DAMROLL;
      affect_to_char(victim,&af);
      cut = 2;
      break;
      case (6): case (7):       /* left leg */
      if (is_affected(victim,gsn_mutilated_left_leg)
      || !IS_SET(victim->parts,PART_LEGS))
      return 1;
      part_name = "left leg";
      af.type = gsn_mutilated_left_leg;
      af.modifier = -2;
      af.location = APPLY_DEX;
      affect_to_char(victim,&af);
      af.modifier = -(number_range(20,50));
      af.location = APPLY_MOVE;
      affect_to_char(victim,&af);
      cut = 2;
      break;
      case (8):  case (9):      /* right leg */
      if (is_affected(victim,gsn_mutilated_right_leg)
      || !IS_SET(victim->parts,PART_LEGS))
      return 1;
      part_name = "right leg";
      af.type = gsn_mutilated_right_leg;
      af.modifier = -2;
      af.location = APPLY_DEX;
      affect_to_char(victim,&af);
      af.modifier = -(number_range(20,50));
      af.location = APPLY_MOVE;
      affect_to_char(victim,&af);
      cut = 2;
      break;
      case (10):       /* left hand */
      if (is_affected(victim,gsn_mutilated_left_hand)
      || !IS_SET(victim->parts,PART_HANDS))
      return 1;
      part_name = "left hand";
      af.type = gsn_mutilated_left_hand;
      af.modifier = -2;
      af.location = APPLY_HITROLL;
      affect_to_char(victim,&af);
      af.modifier = -2;
      af.location = APPLY_DAMROLL;
      affect_to_char(victim,&af);
      cut = 2;
      break;
      case (11):       /* right hand */
      if (is_affected(victim,gsn_mutilated_right_hand)
      || !IS_SET(victim->parts,PART_HANDS))
      return 1;
      part_name = "right hand";
      af.type = gsn_mutilated_right_hand;
      af.modifier = -2;
      af.location = APPLY_HITROLL;
      affect_to_char(victim,&af);
      af.modifier = -2;
      af.location = APPLY_DAMROLL;
      affect_to_char(victim,&af);
      cut = 2;
      break;
      default:       /* right hand */
      if (is_affected(victim,gsn_mutilated_right_hand)
      || !IS_SET(victim->parts,PART_HANDS))
      return 1;
      part_name = "right hand";
      af.type = gsn_mutilated_right_hand;
      af.modifier = -2;
      af.location = APPLY_HITROLL;
      affect_to_char(victim,&af);
      af.modifier = -2;
      af.location = APPLY_DAMROLL;
      affect_to_char(victim,&af);
      cut = 2;
      break;
   }

   sprintf(buf1,"$n's flesh-cutter cruelly mangles $N's %s!",part_name);
   sprintf(buf2,"Your flesh-cutter cruelly mangles $N's %s!",part_name);
   sprintf(buf3,"$n's flesh-cutter cruelly mangles your %s!",part_name);
   act(buf1,ch,0,victim,TO_NOTVICT);
   act(buf2,ch,0,victim,TO_CHAR);
   act(buf3,ch,0,victim,TO_VICT);
   return cut;
}

bool eye_of_beholder_absorb(CHAR_DATA *ch,CHAR_DATA *victim,int dt,int dam,int dam_type)
{
   int chance;
   OBJ_DATA *eye;

   eye = get_eq_char(victim,WEAR_LIGHT);
   if (eye == NULL)
   return FALSE;
   if (eye->pIndexData->vnum != 14003)
   return FALSE;

   if (dt > TYPE_HIT && dt < TYPE_HIT + MAX_DAMAGE_MESSAGE)
   return FALSE;
   if (dam_type == DAM_SLASH  || dam_type == DAM_BASH || dam_type == DAM_PIERCE)
   return FALSE;

   chance = 50 + (victim->level - ch->level) * 5;
   if (dam <= 20)
   chance += 15;
   else if (dam <= 40)
   chance += 10;
   else if (dam <= 60)
   chance += 0;
   else if (dam <= 80)
   chance -= 5;
   else if (dam <= 100)
   chance -= 10;
   else if (dam <= 120)
   chance -= 15;
   else if (dam <= 140)
   chance -= 20;
   else if (dam <= 160)
   chance -= 25;
   else if (dam <= 180)
   chance -= 30;
   else if ( dam <= 200)
   chance -= 35;
   else
   chance -= 40;

   /* Better saves mean better chance */
   chance -= victim->saving_throw / 4;

   if (number_percent() < chance)
   {
      if (is_supplicating)
      {
         act
         (
            "$n's eye of a beholder nullifies the prayers around $m.",
            victim,
            NULL,
            NULL,
            TO_ROOM
         );
         act
         (
            "Your eye of a beholder nullifies the prayers around you.",
            victim,
            NULL,
            NULL,
            TO_CHAR
         );
      }
      else
      {
         act
         (
            "$n's eye of a beholder nullifies the magic around $m.",
            victim,
            NULL,
            NULL,
            TO_ROOM
         );
         act
         (
            "Your eye of a beholder nullifies the magic around you.",
            victim,
            NULL,
            NULL,
            TO_CHAR
         );
      }
      return TRUE;
   }

   return FALSE;
}


/* dying of old age */

void age_death(CHAR_DATA *ch)
{
   ROOM_INDEX_DATA *pRoomIndex;
   OBJ_DATA *obj;
   OBJ_DATA *obj_next;
   int temp_quit;

   if (IS_NPC(ch))
   return;
   if (IS_GOOD(ch))
   pRoomIndex = get_room_index(ROOM_VNUM_DEATH_GOOD);
   else if (IS_EVIL(ch))
   pRoomIndex = get_room_index(ROOM_VNUM_DEATH_EVIL);
   else
   pRoomIndex = get_room_index(ROOM_VNUM_DEATH_NEUTRAL);
   if (pRoomIndex == NULL)
   pRoomIndex = get_room_index(1212);
   if (pRoomIndex == NULL)
   pRoomIndex = get_room_index(ch->temple);
   if (pRoomIndex == NULL)
   return;

   /* For now default to the players recall, or midgaard */
   pRoomIndex = get_room_index(ch->temple);
   if (pRoomIndex == NULL)
   pRoomIndex = get_room_index(3001);

   for (obj = ch->carrying; obj != NULL; obj = obj_next)
   {
      obj_next = obj->next_content;
      extract_obj(obj, FALSE);
   }
   /* All items are poofed at age death */
   stop_fighting(ch,TRUE);
   /*
      -10 quittime means you do not drop weapons
      from strength loss (IMPORTANT)
      Otherwise we drop the weapon, and then put it in the corpse
      Definate memory corruption.
   */
   temp_quit = ch->quittime;
   ch->quittime = -10;
   make_corpse(ch, ch);
   ch->quittime = temp_quit;
   char_from_room(ch);
   char_to_room(ch,pRoomIndex);
   do_observe(ch, "", LOOK_AUTO);
   remove_from_rosters(ch);
   send_to_char("You have died and become a permanent ghost, awaiting your final departure.\n\r",ch);
   return;
}



void check_basilica_weapon_decay(CHAR_DATA *victim)
{
   OBJ_DATA *weapon;
   OBJ_DATA *weapon_next;
   int decay_weapon;

   if (!IS_NPC(victim))
   return;
   decay_weapon = 0;
   if (victim->pIndexData->vnum == 27024)
   decay_weapon = 27037;
   else if (victim->pIndexData->vnum == 27025)
   decay_weapon = 27038;
   else if (victim->pIndexData->vnum == 27026)
   decay_weapon = 27039;
   else if (victim->pIndexData->vnum == 27027)
   decay_weapon = 27040;
   else if (victim->pIndexData->vnum == 27028)
   decay_weapon = 27041;
   else if (victim->pIndexData->vnum == 27029)
   decay_weapon = 27042;
   else if (victim->pIndexData->vnum == 27010)
   decay_weapon = 27036;

   if (decay_weapon == 0)
   return;

   for (weapon = object_list; weapon != NULL; weapon = weapon_next)
   {
      weapon_next = weapon->next;
      if (weapon->pIndexData->vnum != decay_weapon)
      continue;
      weapon->timer = 40;
   }
   return;
}


/* soul devourer..this one after parry and dodge stuff */
void obj_fight_27035(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn, dam;
   if (number_percent() > 8)
   return;
   sn = gsn_energy_drain;
   if (sn <= 0)
   return;
   act("$n's Soul Devourer burns red!",ch,0,0,TO_ROOM);
   act("Your Soul Devourer burns red!",ch,0,0,TO_CHAR);

   dam = dice(obj->level,3);
   if (saves_spell(ch, ch->level,victim,DAM_NEGATIVE, SAVE_OTHER))
   dam /= 2;
   damage(ch,victim,dam,sn,DAM_NEGATIVE,TRUE);
   send_to_char("You feel invigorated by the draining.\n\r",ch);
   ch->hit = URANGE(0,ch->hit+dam/2,ch->max_hit);

   return;
}

/* shadowbane dagger..this one after parry and dodge stuff */
void obj_fight_27036(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn, dam;
   AFFECT_DATA af;

   if (number_percent() > 9)
   return;
   sn = gsn_mind_sear;
   if (sn <= 0)
   return;

   if ( saves_armor_of_god(ch, obj->level, victim) )
   return;

   act("$n's dagger sears $N's mind!",ch,0,victim,TO_NOTVICT);
   act("$n's dagger sears your mind!",ch,0,victim,TO_VICT);
   act("Your dagger sears $N's mind!",ch,0,victim,TO_CHAR);

   if (!is_affected(victim,sn))
   {
      af.type = sn;
      af.where = TO_AFFECTS;
      af.level = obj->level;
      af.duration = 3;
      af.bitvector = 0;
      af.location = APPLY_INT;
      af.modifier = -2;
      affect_to_char(victim,&af);
      af.location = APPLY_WIS;
      af.modifier = -2;
      affect_to_char(victim,&af);
      dam = dice(40,4);
   }
   else
   dam = dice(30,4);

   if (saves_spell(ch, ch->level,victim,DAM_OTHER, SAVE_OTHER))
   dam /= 2;
   damage(ch,victim,dam,sn,DAM_MENTAL,TRUE);

   return;
}

/* shadowbane sword */
void obj_fight_27037(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn;
   if (number_percent() > 10)
   return;
   sn = gsn_lightning_bolt;
   if (sn <= 0)
   return;
   act("$n's sword flares and crackling blue lightning streaks from it!",ch,0,0,TO_ROOM);
   act("Your sword flares and crackling blue lighting streaks from it!",ch,0,0,TO_CHAR);

   magic_spell_vict(ch, victim, CAST_BITS_PLR_SKILL, ch->level, sn);
   return;
}

/* shadowbane mace...this one after parry and dodge stuff */
void obj_fight_27038(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn;
   return;
   if (number_percent() > 10)
   return;
   sn = gsn_poison;
   if (sn <= 0)
   return;
   magic_spell_vict(ch, victim, CAST_BITS_PLR_SKILL, ch->level, sn);
   return;
}

/* demonbane whip...this one after parry and dodge stuff */
void obj_fight_27039(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn;
   if (number_percent() > 6)
   return;
   sn = gsn_acid_blast;
   if (sn <= 0)
   return;
   act("$n's whip sizzles as acid explodes along its length!",ch,0,0,TO_ROOM);
   send_to_char("Your whip sizzles as acid explodes along its length!\n\r",ch);
   magic_spell_vict(ch, victim, CAST_BITS_PLR_SKILL, ch->level, sn);
   return;
}

/* Demonbane spear */
void obj_fight_27040(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn, dam;
   if (number_percent() > 6)
   return;
   sn = gsn_frost_breath;
   if (sn <= 0)
   return;
   act("A blast of freezing air erupts from $n's spear!",ch,0,0,TO_ROOM);
   send_to_char("A blast of freezing air erupts from your spear!\n\r",ch);

   dam = dice(obj->level,4);
   if (saves_spell(ch, ch->level,victim,DAM_COLD, SAVE_OTHER))
   dam /= 2;
   damage(ch,victim,dam,sn,DAM_COLD,TRUE);

   return;
}

/* demonbane axe */
void obj_fight_27041(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn,dam;
   if (number_percent() > 6)
   return;
   sn = gsn_firestream;
   if (sn <= 0)
   return;
   act("A stream of flames erupt from $n's axe",ch,0,0,TO_ROOM);
   send_to_char("A stream of flames erupt from your axe!\n\r",ch);

   dam = dice(obj->level,4);
   if (saves_spell(ch, ch->level,victim,DAM_FIRE, SAVE_OTHER))
   dam /= 2;
   damage(ch,victim,dam,sn,DAM_FIRE,TRUE);

   return;
}

/* demonbane scythe...after parry and dodge stuff */
void obj_fight_27042(CHAR_DATA *ch,CHAR_DATA *victim,OBJ_DATA *obj)
{
   int sn,dam;
   if (number_percent() > 5)
   return;
   sn = gsn_energy_drain;
   if (sn <= 0)
   return;
   act("$n's scythe draws life from $N!",ch,0,victim,TO_NOTVICT);
   act("Your scythe draws life from $N!",ch,0,victim,TO_CHAR);
   act("$n's scythe draws life from you!",ch,0,victim,TO_VICT);

   dam = dice(obj->level,3);
   if (saves_spell(ch, ch->level,victim,DAM_NEGATIVE, SAVE_OTHER))
   dam /= 2;
   damage(ch,victim,dam,sn,DAM_NEGATIVE,TRUE);
   send_to_char("You feel invigorated by the draining.\n\r",ch);
   ch->hit = URANGE(0,ch->hit+dam/2,ch->max_hit);

   return;
}


void do_forage(CHAR_DATA *ch,char *argument)
{
   OBJ_DATA *obj;
   int chance;
   int type;
   char arg[MAX_STRING_LENGTH];
   int which;
   int fn, fn2;

   if ( (chance = get_skill(ch,gsn_forage)) <= 0
   || !has_skill(ch,gsn_forage) )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (ch->in_room->sector_type != SECT_FOREST &&
   ch->in_room->sector_type != SECT_HILLS  &&
   ch->in_room->sector_type != SECT_MOUNTAIN)
   {
      send_to_char("You aren't in a suitable forest region to forage.\n\r",ch);
      return;
   }

   /* find our forest # */
   fn = 0; fn2 = 0;
   while (forest_table[fn].name != NULL)
   {
      if (forest_table[fn].vnum_min <= ch->in_room->vnum &&
      forest_table[fn].vnum_max >= ch->in_room->vnum)
      fn2 = fn;
      fn++;
   }
   fn = fn2;

   if (argument[0] == '\0')
   {
      send_to_char("Forage for what: food, wood, or herbs\n\r",ch);
      send_to_char("Forage common, to survey the area and learn what is common.\n\r",ch);
      return;
   }

   argument = one_argument(argument,arg);
   type = -1;
   if (!str_prefix(arg,"food")) type = 0;
   if (!str_prefix(arg,"wood")) type = 1;
   if (!str_prefix(arg,"herbs")) type = 2;
   if (!str_prefix(arg,"common")) type = 3;
   if (type == -1)
   {
      send_to_char("Forage what?\n\r",ch);
      return;
   }
   if (type == 3)
   {
      for (which = 0; which <= 7; which++)
      {
         switch(which)
         {
            case 0: send_to_char("Wild berries ",ch); break;
            case 1: send_to_char("Nuts ",ch); break;
            case 2: send_to_char("Roots ",ch); break;
            case 3: send_to_char("Tropical fruit ",ch); break;
            case 4: send_to_char("Edible insects ",ch); break;
            case 5: send_to_char("Soft tree bark ",ch); break;
            case 6: send_to_char("Leafy greens ",ch); break;
            case 7: send_to_char("Wild mushrooms ",ch); break;
         }
         if (forest_table[fn].foods[which] < 0)
         fn = 0;
         if (forest_table[fn].foods[which] > 70)
         send_to_char("are extremely prevalent here.\n\r",ch);
         else if (forest_table[fn].foods[which] > 30)
         send_to_char("are common here.\n\r",ch);
         else if (forest_table[fn].foods[which] > 15)
         send_to_char("are rare here.\n\r",ch);
         else if (forest_table[fn].foods[which] > 0)
         send_to_char("are very rare here.\n\r",ch);
         else send_to_char("are non-existant here.\n\r",ch);
         fn = fn2;
      }
      for (which = 0; which <= 7; which++)
      {
         switch(which)
         {
            case 0: send_to_char("Bamboo trees ",ch); break;
            case 1: send_to_char("Pine trees ",ch); break;
            case 2: send_to_char("Redwood trees ",ch); break;
            case 3: send_to_char("Oak trees ",ch); break;
            case 4: send_to_char("Maple trees ",ch); break;
            case 5: send_to_char("Cherry trees ",ch); break;
            case 6: send_to_char("Cypress trees ",ch); break;
            case 7: send_to_char("Magic trees ",ch); break;
         }
         if (forest_table[fn].woods[which] < 0)
         fn = 0;
         if (forest_table[fn].woods[which] > 70)
         send_to_char("are extremely prevalent here.\n\r",ch);
         else if (forest_table[fn].woods[which] > 30)
         send_to_char("are common here.\n\r",ch);
         else if (forest_table[fn].woods[which] > 15)
         send_to_char("are rare here.\n\r",ch);
         else if (forest_table[fn].woods[which] > 0)
         send_to_char("are very rare here.\n\r",ch);
         else send_to_char("are non-existant here.\n\r",ch);
         fn = fn2;
      }
      for (which = 0; which <= 6; which++)
      {
         switch(which)
         {
            case 0: send_to_char("Orange moss ",ch); break;
            case 1: send_to_char("Scab weed ",ch); break;
            case 2: send_to_char("Black vein herb ",ch); break;
            case 3: send_to_char("Tackle berry ",ch); break;
            case 4: send_to_char("Nolbrush ",ch); break;
            case 5: send_to_char("Krull leaf ",ch); break;
            case 6: send_to_char("Monera leaf ",ch); break;
         }
         if (forest_table[fn].herbs[which] < 0)
         fn = 0;
         if (forest_table[fn].herbs[which] > 70)
         send_to_char("is extremely prevalent here.\n\r",ch);
         else if (forest_table[fn].herbs[which] > 30)
         send_to_char("is common here.\n\r",ch);
         else if (forest_table[fn].herbs[which] > 15)
         send_to_char("is rare here.\n\r",ch);
         else if (forest_table[fn].herbs[which] > 0)
         send_to_char("is very rare here.\n\r",ch);
         else send_to_char("is non-existant here.\n\r",ch);
         fn = fn2;
      }
      return;
   }

   if (chance > 90)
   chance = 90;

   if (number_percent() > chance)
   {
      act("$n messes about in the undergrowth but comes up looking perplexed.",ch,0,0,TO_ROOM);
      send_to_char("You search around but find nothing you can recognize as useful.\n\r",ch);
      check_improve(ch,gsn_forage,FALSE,2);
      WAIT_STATE(ch,12);
      return;
   }

   if (argument[0] == '\0')
   {
      switch(type)
      {
         case 0:  send_to_char("What type of food: berries, nuts, roots, fruit, insects, bark, greens, or mushrooms?\n\r",ch);
         break;
         case 1:  send_to_char("What type of wood: bamboo, pine, redwood, oak, maple, cherry, cypress, or magic?\n\r",ch);
         break;
         case 2:  send_to_char("What type of herbs: orange, scab, black, tackle, nolbrush, krull, or monera?\n\r",ch);
         break;
      }
      return;
   }
   which = -1;
   switch(type)
   {
      case 0:
      if (!str_prefix(argument,"berries")) which = 0;
      if (!str_prefix(argument,"nuts")) which = 1;
      if (!str_prefix(argument,"roots")) which = 2;
      if (!str_prefix(argument,"fruit")) which = 3;
      if (!str_prefix(argument,"insects")) which = 4;
      if (!str_prefix(argument,"bark")) which = 5;
      if (!str_prefix(argument,"greens")) which = 6;
      if (!str_prefix(argument,"mushrooms")) which = 7;
      break;
      case 1:
      if (!str_prefix(argument,"bamboo")) which = 0;
      if (!str_prefix(argument,"pine")) which = 1;
      if (!str_prefix(argument,"redwood")) which = 2;
      if (!str_prefix(argument,"oak")) which = 3;
      if (!str_prefix(argument,"maple")) which = 4;
      if (!str_prefix(argument,"cherry")) which = 5;
      if (!str_prefix(argument,"cypress")) which = 6;
      if (!str_prefix(argument,"magic")) which = 7;
      break;
      case 2:
      if (!str_prefix(argument,"orange")) which = 0;
      if (!str_prefix(argument,"scab")) which = 1;
      if (!str_prefix(argument,"black")) which = 2;
      if (!str_prefix(argument,"tackle")) which = 3;
      if (!str_prefix(argument,"nolbrush")) which = 4;
      if (!str_prefix(argument,"krull")) which = 5;
      if (!str_prefix(argument,"monera")) which = 6;
      break;
   }
   if (type == -1 || which == -1)
   {
      send_to_char("Forage what?\n\r",ch);
      return;
   }

   switch(type)
   {
      case 0:  chance = forest_table[fn].foods[which];
      if (chance == -1) chance = forest_table[0].foods[which];
      break;
      case 1:  chance = forest_table[fn].woods[which];
      if (chance == -1) chance = forest_table[0].woods[which];
      break;
      case 2:  chance = forest_table[fn].herbs[which];
      if (chance == -1) chance = forest_table[0].herbs[which];
      break;
   }
   if (number_percent() > chance)
   {
      act("$n messes about in the undergrowth but comes up looking perplexed.",ch,0,0,TO_ROOM);
      send_to_char("You search around but find nothing you can recognize as useful.\n\r",ch);
      check_improve(ch,gsn_forage,FALSE,2);
      WAIT_STATE(ch,12);
      return;
   }
   check_improve(ch,gsn_forage,TRUE,2);


   act("$n messes about in the nearby bushes and comes out with something.",ch,0,0,TO_ROOM);
   send_to_char("You search around and find what you're looking for.\n\r",ch);


   obj = create_object(get_obj_index(OBJ_VNUM_BERRY),1);
   if (obj == NULL)
   return;
   obj->level = ch->level;
   switch(type)
   {
      case 0:
      switch(which)
      {
         case 0: break;
         case 1:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some nuts" );
         free_string( obj->description );
         obj->description  = str_dup( "Some nuts lie here." );
         free_string (obj->name);
         obj->name = str_dup( "nuts" );
         break;
         case 2:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some roots" );
         free_string( obj->description );
         obj->description  = str_dup( "Some roots lie here." );
         free_string (obj->name);
         obj->name = str_dup( "roots" );
         break;
         case 3:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some tasty tropical fruit" );
         free_string( obj->description );
         obj->description  = str_dup( "Some tropical fruit lies here." );
         free_string (obj->name);
         obj->name = str_dup( "fruit" );
         break;
         case 4:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some small edible insects" );
         free_string( obj->description );
         obj->description  = str_dup( "Some small edible insects are here." );
         free_string (obj->name);
         obj->name = str_dup( "insects" );
         break;
         case 5:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some soft chewy bark" );
         free_string( obj->description );
         obj->description  = str_dup( "Some soft chewy bark lies here." );
         free_string (obj->name);
         obj->name = str_dup( "soft bark" );
         break;
         case 6:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some leafy greens" );
         free_string( obj->description );
         obj->description  = str_dup( "Some leafy greens lie here." );
         free_string (obj->name);
         obj->name = str_dup( "greens" );
         break;
         case 7:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a mushroom" );
         free_string( obj->description );
         obj->description  = str_dup( "A mushroom lies here." );
         free_string (obj->name);
         obj->name = str_dup( "mushroom" );
         break;
      }
      break;
      case 1:
      obj->item_type = ITEM_TRASH;
      obj->extra_flags = 0;
      obj->level = 1;
      switch(which)
      {
         case 0:
         obj->weight = 20;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a long shaft of bamboo" );
         free_string( obj->description );
         obj->description  = str_dup( "A long bamboo shaft lies here." );
         free_string (obj->name);
         obj->name = str_dup( "bamboo wood" );
         free_string (obj->material);
         obj->material = str_dup( "bamboo" );
         break;
         case 1:
         obj->weight = 60;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a heavy piece of pine wood" );
         free_string( obj->description );
         obj->description  = str_dup( "A log of pine wood lies here." );
         free_string (obj->name);
         obj->name = str_dup( "pine wood" );
         free_string (obj->material);
         obj->material = str_dup( "pine" );
         break;
         case 2:
         obj->weight = 190;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a long piece of redwood" );
         free_string( obj->description );
         obj->description  = str_dup( "A long piece of redwood lies here." );
         free_string (obj->name);
         obj->name = str_dup( "redwood wood" );
         free_string (obj->material);
         obj->material = str_dup( "redwood" );
         break;
         case 3:
         obj->weight = 160;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a large log of oak" );
         free_string( obj->description );
         obj->description  = str_dup( "A large log of oak lies here." );
         free_string (obj->name);
         obj->name = str_dup( "oak wood" );
         free_string (obj->material);
         obj->material = str_dup( "oak" );
         break;
         case 4:
         obj->weight = 80;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a piece of maple wood" );
         free_string( obj->description );
         obj->description  = str_dup( "A piece of maple wood lies here." );                 free_string (obj->name);
         obj->name = str_dup( "maple wood" );
         free_string (obj->material);
         obj->material = str_dup( "maple" );
         break;
         case 5:
         obj->weight = 110;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a piece of a cherry tree" );
         free_string( obj->description );
         obj->description  = str_dup( "A stick of cherry wood lies here." );
         free_string (obj->name);
         obj->name = str_dup( "cherry wood" );
         free_string (obj->material);
         obj->material = str_dup( "cherry" );
         break;
         case 6:
         obj->weight = 40;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some cypress wood" );
         free_string( obj->description );
         obj->description  = str_dup( "Some cypress wood lies here." );
         free_string (obj->name);
         obj->name = str_dup( "cypress wood" );
         free_string (obj->material);
         obj->material = str_dup( "cypress" );
         break;
         case 7:
         obj->weight = 41;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a magic root" );
         free_string( obj->description );
         obj->description  = str_dup( "A piece of magic root wood lies here." );
         free_string (obj->name);
         obj->name = str_dup( "magic root wood" );
         free_string (obj->material);
         obj->material = str_dup( "magic root wood" );
         SET_BIT(obj->extra_flags,ITEM_MAGIC);
         break;
      }
      break;
      case 2:
      free_string( obj->description );
      obj->description  = str_dup( "An herb lies here discarded." );
      obj->item_type = ITEM_HERB;
      obj->extra_flags = 0;
      obj->weight = 10;
      obj->timer = 120;
      switch(which)
      {
         case 0:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some bright orange moss with a strong scent of cinnamon" );
         free_string (obj->name);
         obj->name = str_dup( "orange moss herb herbs" );
         obj->value[0] = 35;
         obj->value[1] = gsn_heal;
         obj->value[2] = -1;
         obj->value[3] = -1;
         obj->value[4] = -1;
         break;
         case 1:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some strange weeds that seem to glow as they rustle in the breeze" );
         free_string (obj->name);
         obj->name = str_dup( "herb scab weed herbs" );
         obj->value[0] = ch->level+10;
         obj->value[1] = gsn_cure_blindness;
         obj->value[2] = -1;
         obj->value[3] = -1;
         obj->value[4] = -1;
         SET_BIT(obj->extra_flags,ITEM_GLOW);
         break;
         case 2:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a small bunch of leafy herbs with large black veins" );
         free_string (obj->name);
         obj->name = str_dup( "herb black vein herbs" );
         obj->value[0] = 60;
         obj->value[1] = gsn_cure_disease;
         obj->value[2] = -1;
         obj->value[3] = -1;
         obj->value[4] = -1;
         break;
         case 3:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a strange root covered with dirt and many knots" );
         free_string (obj->name);
         obj->name = str_dup( "herb root tackle herbs" );
         obj->value[0] = 60;
         obj->value[1] = gsn_cure_poison;
         obj->value[2] = -1;
         obj->value[3] = -1;
         obj->value[4] = -1;
         break;
         case 4:
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "some strange seeds with yellow stripes running down the green bean like body" );
         free_string (obj->name);
         obj->name = str_dup( "herb nolbrush seed herbs" );
         obj->value[0] = ch->level;
         obj->value[1] = gsn_imbue_regeneration;
         obj->value[2] = gsn_giant_strength;
         obj->value[3] = gsn_remove_curse;
         obj->value[4] = -1;
         break;
         case 5:
         obj->level = ch->level + 10;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a dark brown leaf giving off a sweet fleshy scent" );
         free_string (obj->name);
         obj->name = str_dup( "krull leaf herb herbs" );
         obj->value[0] = 0;
         obj->value[1] = gsn_herb;
         obj->value[2] = -1;
         obj->value[3] = -1;
         obj->value[4] = -1;
         break;
         case 6:
         obj->level = ch->level + 10;
         free_string( obj->short_descr );
         obj->short_descr = str_dup( "a bluish-green sea-weedy leaf fragrant as the sea" );
         free_string (obj->name);
         obj->name = str_dup( "monera leaf herb herbs" );
         obj->value[0] = UMIN(ch->level + 10, 60);
         obj->value[1] = gsn_waterbreathing;
         obj->value[2] = -1;
         obj->value[3] = -1;
         obj->value[4] = -1;
         break;

      }
   }
   obj_to_char(obj,ch);


   return;
}

void do_defend(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_STRING_LENGTH];
   char buf[MAX_STRING_LENGTH];

   one_argument(argument,arg);
   if ( (get_skill(ch,gsn_corrupt("defend", &gsn_defend)) <= 0)
   || /*(ch->level < skill_table[gsn_corrupt("defend", &gsn_defend)].skill_level[ch->class])*/
   !has_skill(ch,gsn_corrupt("defend", &gsn_defend)) )
   {
      send_to_char("You aren't able to defend other people.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   {
      if (ch->defending == NULL)
      sprintf(buf,"You aren't defending anyone right now.\n\r");
      else
      sprintf(buf,"You are defending %s.\n\r",get_name(ch->defending,ch));
      send_to_char(buf,ch);
      return;
   }
   victim = get_char_room(ch,arg);
   if (victim == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You no longer defend anyone.\n\r",ch);
      sprintf(buf,"%s stops defending you.\n\r",get_name(ch,ch->defending));
      if (ch->defending != NULL) send_to_char(buf,ch->defending);
      ch->defending = NULL;
      return;
   }
   if (IS_NPC(victim))
   {
      send_to_char("They don't need to be defended.\n\r",ch);
      return;
   }
   if (ch->defending != NULL)
   {
      act("You stop defending $N.",ch,0,ch->defending,TO_CHAR);
      act("$n stops defending you.",ch,0,ch->defending,TO_VICT);
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   sprintf(buf,"You start defending %s.\n\r",get_name(victim,ch));

   ch->defending = victim;
   act("$n is now defending you.",ch,0,victim,TO_VICT);
   act("You are now defending $N.",ch,0,victim,TO_CHAR);
   return;
}

void do_intimidate(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   int chance;
   AFFECT_DATA af;

   if ( (chance = get_skill(ch,gsn_intimidate)) <= 0
   ||   (!IS_NPC(ch)
   && /*ch->level < skill_table[gsn_intimidate].skill_level[ch->class]*/
   !has_skill(ch,gsn_intimidate)))
   {
      send_to_char("Your intimidation tactics need serious work.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   /*        chance = get_skill(ch,gsn_intimidate);*/
   chance *= 8;
   chance /= 10;

   one_argument(argument,arg);
   if (arg[0] == '\0')
   victim = ch->fighting;
   else
   victim = get_char_room(ch,arg);
   if (victim == NULL)
   {
      send_to_char("Trying to intimidate those imaginary friends again?\n\r",ch);
      return;
   }
   if (!IS_NPC(victim))
   {
      send_to_char("Why not just threaten them yourself?\n\r",ch);
      return;
   }
   else if (!IS_SET(victim->act,ACT_AGGRESSIVE)
   && !IS_SET(victim->off_flags,SPAM_MURDER))
   {
      send_to_char("They are pretty passive as it is, why anger them further?\n\r",ch);
      return;
   }
   else if (is_affected(victim,gsn_intimidate))
   {
      send_to_char("They will not be intimidated any further by anyone.\n\r",ch);
      return;
   }

   chance += (ch->level*3 - victim->level*3);
   if (IS_GOOD(victim))
   chance -= 20;

   if (chance > 70)        chance = 70;
   WAIT_STATE(ch,12);
   if (number_percent() > chance)
   {
      act("$n tries to intimidate $N into submission but just makes a fool of $mself.",ch,0,victim,TO_NOTVICT);
      act("You try to intimidate $N into submission but just make a fool of yourself.",ch,0,victim,TO_CHAR);
      check_improve(ch,gsn_intimidate,FALSE,1);
      return;
   }
   act("$n stares down $N with $s overwhelming presence.",ch,0,victim,TO_NOTVICT);
   act("You stare down $N with your overwhelming presence.",ch,0,victim,TO_CHAR);

   check_improve(ch,gsn_intimidate,TRUE,1);
   stop_fighting(victim,TRUE);
   victim->last_fought = -1;
   af.where = TO_AFFECTS;
   af.type = gsn_intimidate;
   af.duration = 24;
   af.location = 0;
   af.bitvector = 0;
   af.modifier = 0;
   af.level=victim->level;
   affect_to_char(victim,&af);

   return;
}


void do_flee( CHAR_DATA *ch, char *argument )
{
   ROOM_INDEX_DATA *was_in, *mount_was_in;
   ROOM_INDEX_DATA *now_in;
   CHAR_DATA *victim, *mount;
   OBJ_DATA *obj;
   char arg[MAX_INPUT_LENGTH];
   int attempt, chance, dir, flag=0;
   CHAR_DATA *check;
   int door_count;
   EXIT_DATA *pexit;
   int door;
   bool in_house = FALSE;
   bool tank_block = FALSE;
   int move_flags = MOVE_CHAR_FLEE;
   bool phantom = FALSE;

   if ( is_affected(ch,gsn_trapstun) )
   {
      send_to_char("You can't flee you're in a snare.\n\r",ch);
      return;
   }

   if ( ( victim = ch->fighting ) == NULL )
   {
      if ( ch->position == POS_FIGHTING )
      {
         ch->position = POS_STANDING;
         ch->on = NULL;
      }
      send_to_char( "You aren't fighting anyone.\n\r", ch );
      return;
   }

   if ( is_affected(ch,gsn_cloak_brave) )
   {
      if ( ch->hit > (ch->max_hit/10) )
      {
         send_to_char("You're much too loyal to the faith to be running!\n\r",ch);
         return;
      }
   }

   if
   (
      is_affected(ch, gsn_corrupt("stoney grasp", &gsn_stoney_grasp)) &&
      ch->in_room->sector_type != SECT_WATER_SWIM &&
      ch->in_room->sector_type != SECT_WATER_NOSWIM &&
      ch->in_room->sector_type != SECT_UNDERWATER &&
      ch->in_room->sector_type != SECT_AIR &&
      number_bits(1)
   )
   {
      send_to_char("The hands grasp you and prevent you from fleeing!\n\r", ch);
      act
      (
         "The stoney hands grasping $n's feet prevent $m from fleeing!",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      WAIT_STATE(ch, 24);
      return;
   }

   if (number_percent() < 20)
   {
      obj = get_eq_char(ch,WEAR_FEET);
      if (obj == NULL)
      {
         obj = get_eq_char(ch,WEAR_HOOVES);
      }
      if (obj == NULL)
      {
         obj = get_eq_char(ch,WEAR_FOURHOOVES);
      }
      if (obj != NULL)
      if (obj->pIndexData->vnum == OBJ_VNUM_SHACKLES)
      {
         send_to_char("You trip over your shackles!\n\r", ch);
         return;
      }
   }

   for (victim = ch->in_room->people; victim; victim = victim->next_in_room)
   {
      if
      (
         IS_NPC(victim) &&
         victim->pIndexData->vnum == MOB_VNUM_PHANTOM &&
         victim->mprog_target == ch &&
         is_affected(victim, gsn_phantasmal_force)
      )
      {
         phantom = TRUE;
         SET_BIT(move_flags, MOVE_CHAR_SILENT);
      }
   }
   door_count = 0;
   /*
   Count exits you can go out of.
   (take into account closed doors you can pass through/
   closed doors you cannot pass through)
   */
   for (door = 0; door < 6; door++)
   {
      pexit = ch->in_room->exit[door];
      if
      (
         !can_exit
         (
            ch,
            pexit
         )
      )
      {
         continue;
      }
      door_count++;
   }
   if (ch->in_room->house != 0)
   {
      for (check = ch->in_room->people; check != NULL; check = check->next_in_room)
      {
         if
         (
            IS_NPC(check) &&
            (
               check->house &&
               check->pIndexData->vnum == house_table[check->house].vnum_guardian
            )
         )
         {
            in_house = TRUE;
            break;
         }
      }
   }
   /* block retreat from a warrior */
   if
   (
      ch->fighting != NULL &&
      is_affected(ch->fighting, gsn_block_retreat) &&
      ch->fighting->position == POS_FIGHTING &&
      number_percent() <= get_skill(ch->fighting, gsn_block_retreat)
   )
   {
      tank_block = TRUE;
   }

   for (check = ch->in_room->people; check != NULL; check = check->next_in_room)
   {
      int chance;
      bool deaf;
      int size_diff;

      chance = 0;
      deaf = FALSE;
      if
      (
         check->fighting != ch ||
         !is_affected(check, gsn_block_retreat) ||
         number_percent() > get_skill(check, gsn_block_retreat) ||
         door_count == 0 ||
         check->position != POS_FIGHTING
      )
      {
         continue;
      }
      if (is_affected(check, gsn_shock_sphere))
      {
         deaf = TRUE;
         /* Deaf has 10% chance to fail outright */
         if (number_percent() <= 10)
         {
            continue;
         }
      }
      if
      (
         IS_AFFECTED(check, AFF_BLIND) &&
         (
            deaf ||
            number_percent() <= 75
         )
      )
      {
         /*
         Blindness gives 75% failure,
         blindness + deafness gives 100% failure
         */
         continue;
      }
      switch (door_count)
      {
         case (1):
         {
            chance = 75;
            break;
         }
         case (2):
         {
            chance = 55;
            break;
         }
         case (3):
         {
            chance = 35;
            break;
         }
         case (4):
         {
            chance = 10;
            break;
         }
         case (5):
         {
            chance = 5;
            break;
         }
         case (6):
         {
            chance = 3;
            break;
         }
         default:
         {
            bug("Too many doors in block retreat: %d", door_count);
            continue;
            break;
         }
      }
      if
      (
         ch->fighting != check &&
         !tank_block
      )
      {
         /*
         If the warrior is not tanking,
         it is harder to block them, (UNLESS)
         the person who IS tanking, is also blocking
         */
         chance -= 10;
      }
      if
      (
         in_house &&
         chance > 25
      )
      {
         sh_int temp = 25 + number_range(0, 5);

         /*
         25-30% chance (max)
         of working in a guardian room
         */
         chance = UMIN(chance, temp);
      }
      size_diff = check->size - ch->size;
      if (size_diff == 1)
      {
         chance += 5;
         /* Perfect size to block, just a bit bigger */
      }
      else if (size_diff >= 2)
      {
         if (number_percent() <= 10)
         {
            continue;
         }
         /* Too big to block, can run through your legs */
      }
      else if (size_diff < 0)
      {
         if (number_percent() <= 5 * size_diff)
         {
            continue;
         }
         /* Small races have a hard time blocking big ones */
      }
      if (number_percent() > chance)
      {
         /* Moment of truth */
         continue;
      }
      check_improve(check, gsn_block_retreat, TRUE, 1);
      act("Your retreat is blocked by $N.", ch, NULL, check, TO_CHAR);
      act
      (
         "$N quickly moves to block $n's retreat.",
         ch,
         NULL,
         check,
         TO_NOTVICT
      );
      act("You move to block $N from retreating.", check, NULL, ch, TO_CHAR);
      DAZE_STATE(ch, 12);
      return;
   }
   one_argument(argument,arg);
   chance = get_skill(ch,gsn_escape);
   if (chance > 90)
   chance = 90;

   dir = 10;

   if (arg[0] == '\0')
   dir = 10;
   else if (!str_cmp(arg,"north") || !str_cmp(arg,"n"))
   dir = 0;
   else if (!str_cmp(arg,"east") || !str_cmp(arg,"e"))
   dir = 1;
   else if (!str_cmp(arg,"south") || !str_cmp(arg,"s"))
   dir = 2;
   else if (!str_cmp(arg,"west") || !str_cmp(arg,"w"))
   dir = 3;
   else if (!str_cmp(arg,"up") || !str_cmp(arg,"u"))
   dir = 4;
   else if (!str_cmp(arg,"down") || !str_cmp(arg,"d"))
   dir = 5;
   else
   dir = 10;

   if ( !IS_NPC(ch) && !has_skill(ch,gsn_escape) )
   {
      dir = 10;
   }

   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   was_in = ch->in_room;
   for ( attempt = 0; attempt < 6; attempt++ )
   {
      int orig_door;
      int mount_check;

      if (dir == 10 || number_percent() > chance)
      {
         door = number_door( );
         if (dir != 10) check_improve(ch,gsn_escape,FALSE,1);
      }
      else
      {
         door = dir;
         check_improve(ch,gsn_escape,TRUE,1);
      }

      orig_door = door;
      if (is_affected_room(ch->in_room,gsn_corrupt("hall of mirrors", &gsn_hall_mirrors)))
      {
         if (!IS_NPC(ch) && !IS_IMMORTAL(ch) && ch->pcdata->special != SUBCLASS_ILLUSIONIST)
         {
            door = door + ch->in_room->vnum%6;
            while (door > 5)
            door -= 5;
            if (door < 0) door = 0;
         }
      }

      if
      (
         !can_exit
         (
            ch,
            (pexit = was_in->exit[door])
         ) ||
         number_range(0, ch->daze) != 0 ||
         (
            IS_NPC(ch) &&
            IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB)
         )
      )
      {
         continue;
      }

      door = orig_door;
      send_to_char("You choose a direction at random and begin to run...\n\r",ch);

      mount_check = FALSE;
      if (ch->is_riding)
      {
         mount = ((CHAR_DATA *)ch->is_riding->mount);
         if (mount->in_room == ch->in_room)
         mount_check = TRUE;
         else
         do_dismount(ch,NULL);
      }
      /* If the player is mounted upon a mob, check to see if the mount can flee -- Wicket */
      if ( ch->is_riding && ch->is_riding->mount_type == MOUNT_MOBILE && mount_check)
      {
         mount = ((CHAR_DATA *)ch->is_riding->mount);
         mount_was_in = mount->in_room;
         move_char(mount, door, move_flags);
         if ( ( now_in = mount->in_room ) == mount_was_in )
         {
            act( "$n attempts to flee but ends up back in the fight.",ch,NULL,NULL,TO_ROOM );
            send_to_char( "You end up right back where you started! Uh oh!\n\r",ch );
            continue;
         }

         /* Tell everyone in the old room that the rider has fled */
         mount->last_fought = -1;
         char_from_room(mount);
         char_to_room_1(mount, was_in, TO_ROOM_AT);
         if (!phantom)
         {
            act( "$n has fled upon $N!", ch, NULL, mount, TO_ROOM );
         }
         char_from_room(mount);
         char_to_room_1(mount, now_in, TO_ROOM_AT);

         /* Put the rider into the same room that the mount fled into */
         char_from_room( ch );
         char_to_room_look(ch, now_in);
         ch->last_fought = -1;
      }
      else
      {
         move_char(ch, door, move_flags);

         if ( ( now_in = ch->in_room ) == was_in )
         {
            act("$n attempts to flee but ends up back in the fight.",ch,NULL,NULL,TO_ROOM);
            send_to_char("You end up right back where you started! Uh oh!\n\r",ch);
            continue;
         }
         ch->last_fought = -1;
         char_from_room(ch);
         char_to_room_1(ch, was_in, TO_ROOM_AT);
         if (!phantom)
         {
            act( "$n has fled!", ch, NULL, NULL, TO_ROOM );
         }
         char_from_room(ch);
         char_to_room_1(ch, now_in, TO_ROOM_AT);
         check_caltrops(ch);
         check_charging_retreat(ch, ch->fighting);
      }

      for(victim=ch->in_room->people;victim!=NULL;victim=victim->next_in_room)
      {
         if(victim->fighting==ch)
         {
            flag=1;
            break;
         }
      }

      if (flag == 0)
      {
         int pos = ch->position;

         /*
         Fleeing into ranger traps,
         mobprogs that put you to sleep
         */
         stop_fighting(ch, TRUE);
         if
         (
            pos == POS_SLEEPING ||
            pos == POS_RESTING
         )
         {
            ch->position = pos;
         }
      }

      for(victim=was_in->people;victim!=NULL;victim=victim->next_in_room)
      {
         if(victim->fighting==ch)
         {
            victim->fighting=NULL;
            victim->position=POS_STANDING;
         }
      }

      for(victim=was_in->people;victim!=NULL;victim=victim->next_in_room)
      {
         if(victim->fighting!=NULL)
         {
            if(victim->fighting->fighting==NULL)
            {
               victim->fighting->fighting = victim;
               /* victim->fighting->position = POS_STANDING; */
               victim->fighting->position = POS_FIGHTING;
               victim->position           = POS_FIGHTING; /* XUR */
            }
         }
      }

      if ( !IS_NPC(ch) )
      {
         if ( ch->is_riding )
         {
            /*
            * Make one final check to make sure the mount has
            * stopped fighting to prevent problems with 'Charge'
            * and moving around in general -- Wicket
            */
            if (((CHAR_DATA *)ch->is_riding->mount)->fighting != NULL)
            stop_fighting((CHAR_DATA *)ch->is_riding->mount,TRUE);

            act( "You flee from combat upon $N!", ch, NULL, (CHAR_DATA *)ch->is_riding->mount, TO_CHAR );
         }
         else
         send_to_char( "You flee from combat!\n\r", ch );

         send_to_char( "You lost 10 exp.\n\r", ch);
         gain_exp( ch, -10 );

         if (dir != 10 && get_skill(ch,gsn_escape) > 2)
         check_improve(ch,gsn_escape,TRUE,2);
      }

      return;
   }

   send_to_char( "PANIC! You couldn't escape!\n\r", ch );
   return;
}

void check_charging_retreat(CHAR_DATA *ch, CHAR_DATA *victim)
{
   ROOM_INDEX_DATA *room = ch->in_room;

   if (ch == NULL || victim == NULL)
   return;

   if (IS_NPC(ch))
   return;

   if (get_skill(ch, gsn_charging_retreat) <= 1 || !has_skill(ch, gsn_charging_retreat))
   return;

   if (number_percent() > get_skill(ch,gsn_charging_retreat)/2)
   {
      check_improve(ch, gsn_charging_retreat, FALSE, 1);
      return;
   }

   check_improve(ch, gsn_charging_retreat, TRUE, 1);
   send_to_char("You make a charging retreat!\n\r",ch);

   char_from_room(ch);
   char_to_room_1(ch, victim->in_room, TO_ROOM_AT);
   act("$n charges you as $e retreats, knocking you to the ground!",ch,NULL,victim,TO_VICT);
   act("$n charges $N as he retreats, knocking $N to the ground!",ch,NULL,victim,TO_NOTVICT);
   DAZE_STATE(victim, 12);
   char_from_room(ch);
   char_to_room_1(ch, room, TO_ROOM_AT);

   return;
}


void check_caltrops(CHAR_DATA* ch)
{
   ROOM_INDEX_DATA* old_room;
   ROOM_INDEX_DATA* new_room;
   CHAR_DATA* victim = ch->fighting;
   int wimpy_save;
   int ghost = ch->ghost;
   long vid;
   long cid;

   if
   (
      ch == NULL ||
      ch->in_room == NULL ||
      victim == NULL ||
      victim->in_room == NULL ||
      ch->in_room == victim->in_room ||
      IS_NPC(ch) ||
      get_skill(ch, gsn_caltrops) <= 1 ||
      !has_skill(ch, gsn_caltrops) ||
      ch->position < POS_FIGHTING
   )
   {
      return;
   }

   if (number_percent() > get_skill(ch, gsn_caltrops))
   {
      check_improve(ch, gsn_caltrops, FALSE, 1);
      return;
   }
   cid = ch->id;
   vid = victim->id;
   wimpy_save = ch->wimpy;
   ch->wimpy = 0;  /* Ninja should not flee from mental feedback */
   old_room = ch->in_room;
   new_room = victim->in_room;

   char_from_room(ch);
   char_to_room_1(ch, new_room, TO_ROOM_AT);

   check_improve(ch, gsn_caltrops, TRUE, 1);
   send_to_char("You throw out a handful of caltrops as you flee!\n\r", ch);
   act
   (
      "$n throws caltrops towards you as $e flees!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n throws out caltrops as $e flees!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   damage
   (
      ch,
      victim,
      number_range(ch->level / 2, ch->level * 3 / 2),
      gsn_caltrops,
      DAM_PIERCE,
      TRUE
   );
   if
   (
      ch->valid &&
      victim->valid &&
      ch->id == cid &&
      victim->id == vid &&
      ch->fighting == victim &&
      !victim->ghost &&
      ch->ghost == ghost &&
      victim->in_room == new_room &&
      ch->in_room == new_room &&
      number_range(1, 2) == 1 &&
      ch->level > 30
   )
   {
      damage
      (
         ch,
         victim,
         number_range(ch->level / 2, ch->level),
         gsn_caltrops,
         DAM_PIERCE,
         TRUE
      );
   }
   if
   (
      ch->valid &&
      victim->valid &&
      ch->id == cid &&
      victim->id == vid &&
      ch->fighting == victim &&
      !victim->ghost &&
      ch->ghost == ghost &&
      victim->in_room == new_room &&
      ch->in_room == new_room &&
      number_range(1, 3) == 1 &&
      ch->level > 40
   )
   {
      damage
      (
         ch,
         victim,
         number_range(ch->level / 2, ch->level),
         gsn_caltrops,
         DAM_PIERCE,
         TRUE
      );
   }
   if
   (
      ch->valid &&
      victim->valid &&
      ch->id == cid &&
      victim->id == vid &&
      ch->fighting == victim &&
      !victim->ghost &&
      ch->ghost == ghost &&
      victim->in_room == new_room &&
      ch->in_room == new_room &&
      number_range(1, 4) == 1 &&
      ch->level > 50
   )
   {
      damage
      (
         ch,
         victim,
         number_range(ch->level / 3, ch->level),
         gsn_caltrops,
         DAM_PIERCE,
         TRUE
      );
   }
   /* If this check fails, ch is DEAD, or fled the room */
   if
   (
      ch->valid &&
      ch->id == cid &&
      ch->ghost == ghost &&
      ch->in_room == new_room
   )
   {
      char_from_room(ch);
      char_to_room_1(ch, old_room, TO_ROOM_AT);
   }
   /*
   Does not matter much that ch is dead,
   as far as restoring wimpy is concerned
   since ch is PC (checked above),
   NPC's cannot throw caltrops
   */
   ch->wimpy = wimpy_save;

   return;
}

void do_assassinate(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   CHAR_DATA *person;
   int chance, dam;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_INPUT_LENGTH];

   one_argument(argument,arg);
   if (IS_NPC(ch))
   return;

   if ((get_skill(ch,gsn_assassinate) <= 0)
   || !has_skill(ch,gsn_assassinate))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (arg[0] == '\0')
   {
      send_to_char("Attempt to assassinate who?\n\r",ch);
      return;
   }
   if ( (victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("Try delete delete.\n\r",ch);
      return;
   }
   if (victim->fighting != NULL || victim->position == POS_FIGHTING)
   {
      send_to_char("They are moving around too much to get in close for the kill.\n\r",ch);
      return;
   }

   if (is_safe(ch,victim, 0))
   return;

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (victim->hit < victim->max_hit)
   {
      send_to_char("They have too much blood on them right now to locate their strike point.\n\r",ch);
      return;
   }
   chance = get_skill(ch,gsn_assassinate)/2;
   chance += ch->level;
   chance -= victim->level;
   if (!can_see(victim,ch))
   chance += 20;
   if (victim->position == POS_SLEEPING)
   chance += 10;

   if (!IS_NPC(victim))
   chance /= 15 + 1;
   chance = URANGE(2,chance,90);
   if (IS_NPC(victim) && IS_SET(victim->act2,ACT_NO_DEATHSTRIKE))
   chance = 0;
   act("$n tries to strike at $N's critical nerves!",ch,0,victim,TO_NOTVICT);
   act("You try to strike $N's critical nerves!",ch,0,victim,TO_CHAR);
   act("$n strikes at your critical nerves!",ch,0,victim,TO_VICT);

   if (IS_SET(victim->imm_flags,IMM_WEAPON))
   chance = 0;
   WAIT_STATE(ch,24);
   if (number_percent() < chance
   && can_instakill(ch, victim))
   {
      if (IS_SET(ch->comm,COMM_ANSI))
      act("You \x01B[1;31m--->>> ASSASSINATE <<<---\x01B[0;37m $N!",ch,0,victim,TO_CHAR);
      else
      act("You --->>> ASSASSINATE <<<--- $N!",ch,0,victim,TO_CHAR);

      if (IS_SET(victim->comm,COMM_ANSI))
      act("$n \x01B[1;31m--->>> ASSASSINATES <<<---\x01B[0;37m you!",ch,0,victim,TO_VICT);
      else
      act("$n --->>> ASSASSINATES <<<--- you!",ch,0,victim,TO_VICT);
      for( person = ch->in_room->people; person != NULL; person = person->next_in_room )
      {
         if( person == ch || person == victim )
         continue;

         if( IS_SET(person->comm,COMM_ANSI) )
         sprintf(buf,"$n \x01B[1;31m--->>> ASSASSINATES <<<---\x01B[0;37m %s!",get_descr_form(victim,person,FALSE));
         else
         sprintf(buf,"$n --->>> ASSASSINATES <<<--- %s!",get_descr_form(victim,person,FALSE));

         act(buf,ch,NULL,person,TO_VICT);
      }
      raw_kill(ch,victim);
      check_improve(ch,gsn_assassinate,TRUE,3);
      return;
   }
   else
   {
      dam = ch->level * 3;
      dam += dice(ch->level, 6);
      damage(ch,victim,dam,gsn_assassinate,DAM_PIERCE,TRUE);
      check_improve(ch,gsn_assassinate,FALSE,3);
      if (!IS_NPC(victim) && !IS_NPC(ch) && (victim->hit > 1))
      {
         sprintf(buf,"Help! %s just tried to assassinate me!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] assassinated [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      multi_hit(victim,ch,TYPE_UNDEFINED);
   }
   return;
}


/* Some more new skills..Ceran */

void do_lash(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   int chance;
   char buf[MAX_STRING_LENGTH];
   OBJ_DATA* weapon;

   one_argument(argument, arg);

   if
   (
      (chance = (get_skill(ch, gsn_lash) * 2)) <= 0 ||
      !has_skill(ch, gsn_lash)
   )
   {
      send_to_char("You don't have the skill to lash people's legs.\n\r", ch);
      return;
   }

   chance /= 3;
   chance += 15;

   if
   (
      IS_NPC(ch) &&
      IS_AFFECTED(ch, AFF_CHARM)
   )
   {
      return;
   }

   if (check_peace(ch))
   {
      return;
   }

   weapon = get_eq_char(ch, WEAR_WIELD);
   if
   (
      weapon == NULL ||
      (
         weapon->value[0] != WEAPON_WHIP &&
         weapon->value[0] != WEAPON_FLAIL
      )
   )
   {
      chance -= 15;
      weapon = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   if (weapon == NULL)
   {
      send_to_char("You aren't wielding any weapon to lash with.\n\r", ch);
      return;
   }
   if
   (
      weapon->value[0] != WEAPON_WHIP &&
      weapon->value[0] != WEAPON_FLAIL
   )
   {
      send_to_char("You need to be wielding a whip or flail to lash.\n\r", ch);
      return;
   }



   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r", ch);
         return;
      }
   }

   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r", ch);
      return;
   }

   if
   (
      victim->position == POS_SLEEPING ||
      victim->position == POS_RESTING ||
      victim->daze > 0
   )
   {
      act
      (
         "$N isn't on $S feet.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if (victim == ch)
   {
      send_to_char("You try to lash your feet and look clumsy doing it.\n\r", ch);
      return;
   }


   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if
   (
      IS_AFFECTED(ch, AFF_CHARM) &&
      ch->master == victim
   )
   {
      act
      (
         "But $N is your friend!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }
   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   if
   (
      is_affected(victim, gsn_phasing) &&
      (number_percent() < (30+((victim->level-ch->level)*2)))
   )
   {
      act
      (
         "You phase out and $N's lash doesn't affect you.",
         victim,
         0,
         ch,
         TO_CHAR
      );
      act
      (
         "$n phases out and $N's lash doesn't seem to affect him.",
         victim,
         0,
         ch,
         TO_NOTVICT
      );
      act
      (
         "$n phases out and your lash doesn't seem to affect him.",
         victim,
         0,
         ch,
         TO_VICT
      );
      WAIT_STATE(ch, 2*PULSE_VIOLENCE);
      return;
   }

   /* speed */
   if
   (
      IS_SET(ch->off_flags, OFF_FAST) ||
      IS_AFFECTED(ch, AFF_HASTE)
   )
   {
      chance += 5;
   }
   if
   (
      IS_SET(victim->off_flags, OFF_FAST) ||
      IS_AFFECTED(victim, AFF_HASTE)
   )
   {
      chance -= 15;
      chance += get_curr_stat(ch,STAT_DEX)/2;
      chance -= get_curr_stat(victim,STAT_DEX)/2;
   }
   if
   (
      !IS_NPC(ch) &&
      (
         ch->class == CLASS_CHANNELER ||
         ch->class == CLASS_NECROMANCER ||
         ch->class == CLASS_ELEMENTALIST
      )
   )
   {
      chance -= 10;
      chance += (UMIN(ch->size - victim->size, victim->size - ch->size) * 10);
   }

   if (victim->race == grn_changeling)
   {
      if
      (
         ch->morph_form[0] == MORPH_WOLF ||
         ch->morph_form[0] == MORPH_BEAR
      )
      {
         chance -= 20;
      }
   }
   else
   {
      if
      (
         victim->race == grn_centaur ||
         victim->race == grn_bear ||
         victim->race == grn_cat ||
         victim->race == grn_dog ||
         victim->race == grn_dragon ||
         victim->race == grn_fido ||
         victim->race == grn_fox ||
         victim->race == grn_lizard ||
         victim->race == grn_pig ||
         victim->race == grn_wolf ||
         victim->race == grn_wyvern ||
         victim->race == grn_modron
      )
      {
         chance -= 20;
      }
   /* level */
   /* I think this next line goes inside the else statement, should logically.
      Cursed bracketless coding *grumble* --Drin */
      chance += (ch->level - victim->level)*3;
   }
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         victim->fighting == NULL ||
         ch->fighting == NULL
      )
   )
   {
      sprintf
      (
         log_buf,
         "[%s] lashed [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
      sprintf
      (
         buf,
         "Help! %s is lashing me!",
         PERS(ch, victim)
      );
      do_myell(victim,buf);
   }

   chance = URANGE(5, chance, 95);

   /* Last chance check for Crusaders with steel nerves */
   if
   (
      is_affected(victim, gsn_steel_nerves) &&
      (number_percent()<20)
   )
   {
      chance = 0;
   }
   if (number_percent() > chance)
   {
      act
      (
         "$n lashes at $N's legs but misses.",
         ch,
         0,
         victim,
         TO_NOTVICT
      );
      act
      (
         "$n lashes at your legs but misses.",
         ch,
         0,
         victim,
         TO_VICT
      );
      act
      (
         "You lash at $N's legs but miss.",
         ch,
         0,
         victim,
         TO_CHAR
      );
      /*
      if( !IS_OBJ_STAT(weapon,ITEM_NOREMOVE)
      && number_percent() < 20
      && number_percent() > ((get_curr_stat(ch,STAT_STR) * 3) + (5 * (ch->size - victim->size))))
      {
      act("Your weapon catches on $N's waist and jerks from your grasp!",ch,0,victim,TO_CHAR);
      act("$n's weapon catches on your waist and jerks from $s grasp!",ch,0,victim,TO_VICT);
      act("$n's weapon catches on $N's waist and jerks from $s grasp!",ch,0,victim,TO_NOTVICT);

      obj_from_char( weapon );
      if ( IS_OBJ_STAT(weapon,ITEM_NODROP) || IS_OBJ_STAT(weapon,ITEM_INVENTORY) )
      obj_to_char( weapon, ch );
      else
      obj_to_room( weapon, ch->in_room );
      }
      */
      check_improve
      (
         ch,
         gsn_lash,
         FALSE,
         1
      );
      WAIT_STATE(ch, skill_table[gsn_lash].beats);
      damage
      (
         ch,
         victim,
         0,
         gsn_lash,
         DAM_BASH,
         TRUE
      );
      return;
   }

   if (victim->race == grn_arborian)
   {
      act
      (
         "$n lashes $N's roots, sending $M crashing to the ground.",
         ch,
         0,
         victim,
         TO_NOTVICT
      );
      act
      (
         "$n lashes your roots, sending you crashing to the ground.",
         ch,
         0,
         victim,
         TO_VICT
      );
      act
      (
         "You lash $N's roots, sending $M crashing to the ground.",
         ch,
         0,
         victim,
         TO_CHAR
      );
   }
   else
   {
      act
      (
         "$n lashes $N's legs, sending $M crashing to the ground.",
         ch,
         0,
         victim,
         TO_NOTVICT
      );
      act
      (
         "$n lashes your legs, sending you crashing to the ground.",
         ch,
         0,
         victim,
         TO_VICT
      );
      act
      (
         "You lash $N's legs, sending $M crashing to the ground.",
         ch,
         0,
         victim,
         TO_CHAR
      );
   }
   check_improve
   (
      ch,
      gsn_lash,
      TRUE,
      1
   );
   DAZE_STATE(victim, 20);
   WAIT_STATE(ch, skill_table[gsn_lash].beats);
   damage
   (
      ch,
      victim,
      dice(2,7),
      gsn_lash,
      DAM_BASH,
      TRUE
   );
   victim->position = POS_RESTING;
   check_downstrike(ch, victim);
   return;
}

void do_pugil(CHAR_DATA *ch,char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   bool attempt_dual = FALSE;
   CHAR_DATA *victim;
   OBJ_DATA *obj;
   int chance;
   int dam;
   int dam_type;

   one_argument(argument,arg);

   if ( (chance = get_skill(ch,gsn_pugil)) <= 0
   ||  IS_NPC(ch)
   ||  (!IS_NPC(ch) && /*ch->level < skill_table[gsn_pugil].skill_level[ch->class]*/
   !has_skill(ch,gsn_pugil) ))
   {
      send_to_char("You're not trained in the art of pugiling.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone.\n\r",ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (ch->fighting == NULL)
   {
      send_to_char("You can't pugil someone like that.\n\r",ch);
      return;
   }

   if (victim == ch)
   {
      send_to_char("That would be a bit stupid.\n\r", ch);
      return;
   }

   obj = get_eq_char(ch,WEAR_WIELD);
   if (obj == NULL || obj->value[0] != WEAPON_STAFF)
   {
      attempt_dual = TRUE;
      obj = get_eq_char(ch,WEAR_DUAL_WIELD);
   }

   if (obj == NULL)
   {
      send_to_char("You must wield a staff to pugil.\n\r",ch);
      return;
   }

   if (obj->value[0] != WEAPON_STAFF)
   {
      send_to_char("You must wield a staff to pugil.\n\r",ch);
      return;
   }
   dam_type = attack_table[obj->value[3]].damage;

   chance += (ch->level - victim->level);
   chance = URANGE(5, chance, 90);

   WAIT_STATE(ch,skill_table[gsn_pugil].beats);

   if (number_percent() < chance)
   {
      act("You smash $N with a bone crushing pugil!",ch,NULL,victim,TO_CHAR);
      act("$n smashes you with a bone crushing pugil!",ch,NULL,victim,TO_VICT);
      act("$n pugils $N with a bone crushing pugil!",ch,NULL,victim,TO_NOTVICT);
      check_improve(ch,gsn_pugil,TRUE,1);
      dam = dice(obj->value[1],obj->value[2]);
      /*        dam += (get_skill(ch,gsn_enhanced_damage) * dam/100);*/
      dam += 30+number_range(0,10);
      /*        if (ch->level <= 20)
      {
      dam *= number_range(10,13);
      dam /= 10;
      }
      else if (ch->level <= 25)
      {
      dam *= number_range(11,14);
      dam /= 10;
      }
      else if (ch->level <= 30)
      {
      dam *= number_range(12,15);
      dam /= 10;
      }
      else if (ch->level <= 35)
      {
      dam *= number_range(12,17);
      dam /= 10;
      }
      else if (ch->level <= 40)
      {
      dam *= number_range(13,18);
      dam /= 10;
      }
      else
      {
      dam *= number_range(14,20);
      dam /= 10;
      }
      */
      if ((ch->drain_level + ch->level) <= 15)
      dam *= 1;
      else if ((ch->drain_level + ch->level) <= 20)
      dam *= 3/2;
      else if ((ch->drain_level + ch->level) < 25)
      dam *= 2;
      else if ((ch->drain_level + ch->level) < 30)
      dam *= 7/3;
      else if ((ch->drain_level + ch->level) < 40)
      dam *= 5/2;
      else if ((ch->drain_level + ch->level) <= 49)
      dam *= 7/2;
      else if ((ch->drain_level + ch->level) <= 55)
      dam *= 10/3;
      else dam *= 10/3;

      dam *= battlecry_multiplier(ch,victim,gsn_pugil);

      damage(ch,victim,dam,gsn_pugil, dam_type, TRUE);
   }
   else
   {
      check_improve(ch,gsn_pugil,FALSE,1);

      damage(ch,victim,0,gsn_pugil,DAM_OTHER,TRUE);
   }

   return;
}

void do_protection_heat_cold(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;
   int chance;
   int sn;

   if
   (
      !IS_NPC(ch) &&
      has_skill(ch, gsn_iron_scales_dragon)
   )
   {
      sn = gsn_iron_scales_dragon;
   }
   else
   {
      sn = gsn_protection_heat_cold;
   }

   if
   (
      (
         chance = get_skill(ch, sn)
      ) < 1 ||
      !has_skill (ch, sn)
   )
   {
      send_to_char("You don't know how to protect yourself from the elements.\n\r",ch);
      return;
   }

   if (is_affected(ch, sn))
   {
      send_to_char("You are already protected from the elements.\n\r", ch);
      return;
   }

   if (number_percent() > chance)
   {
      send_to_char("You try to protect yourself from the elements but fail.\n\r",ch);
      check_improve(ch, sn, FALSE, 1);
      return;
   }

   af.where = TO_AFFECTS;
   af.type = gsn_protection_heat_cold;
   af.level = ch->level;
   af.modifier = 0;
   af.duration = ch->level;
   af.bitvector = 0;
   af.location = 0;
   affect_to_char(ch,&af);
   send_to_char("You are protected from the elements.\n\r", ch);
   if (sn == gsn_iron_scales_dragon)
   {
      af.type = sn;
      affect_to_char(ch, &af);
      send_to_char("You focus on the impenetrability of your mind.\n\r", ch);
   }
   check_improve(ch, sn, TRUE, 1);
   return;
}

void do_undead_drain(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *vch;
   char buf[MAX_INPUT_LENGTH];
   int sn_drain;
   if (ch->level < 40) return;

   for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
   {
      if (vch->fighting == ch
      && number_percent() > 70)
      break;
   }

   if (vch == NULL)
   vch = ch->fighting;
   sn_drain = gsn_undead_drain;
   if (sn_drain == -1)
   return;

   sprintf(buf, "blah %ld", vch->id);
   magic_spell_vict(ch, vch, CAST_BITS_PLR_SKILL, ch->level, sn_drain);
   return;
}



void do_call_to_arms( CHAR_DATA *ch, char *arguement)
{
   CHAR_DATA *target;
   CHAR_DATA *target_next;

   if (IS_NPC(ch))
   return;

   if (check_peace(ch)) return;

   if (ch->mana < 10)
   {
      send_to_char("You are unable to muster the force of will to lead more crusades.\n\r", ch);
      return;
   }

   if ( ch->fighting == NULL )
   {
      send_to_char("You give a stirring call to arms, but alas there is nobody to fight.\n\r", ch);
      act("$n cries out to nobody in particular to fight nobody in particular.", ch, NULL, NULL, TO_ROOM);
      return;
   }

   if (IS_SET(ch->act,PLR_CRIMINAL))
   {
      send_to_char("Do you really think people will rally to a criminal?!\n\r",ch);
      return;
   }

   if ( !IS_GOOD(ch))
   {
      send_to_char("Despite your best attempts nobody will join you.\n\r",ch);
      act("$n gives a pathetic call to arms.",ch, NULL, NULL, TO_ROOM);
      return;
   }

   if (number_percent() > get_skill(ch,gsn_rally))
   {
      send_to_char("You yell some wild rhetoric but fail to inspire anyone.\n\r",ch);
      check_improve(ch,gsn_rally,FALSE,2);
      WAIT_STATE(ch,12);
      return;
   }

   act("$n gives a stirring call to arms!",ch, NULL, NULL, TO_ROOM);
   send_to_char("You give a stirring call to arms!\n\r",ch);

   for (target = ch->in_room->people; target != NULL; target = target_next)
   {
      target_next = target->next_in_room;

      if (!IS_GOOD(target) || !IS_NPC(target) || IS_AFFECTED(target,AFF_CHARM))
      continue;
      if (is_same_group(ch,target) || target->position < POS_RESTING)
      continue;
      if (target->position == POS_FIGHTING)
      continue;
      if (ch->mana < 15)
      continue;
      if (ch->fighting == NULL)
      continue;
      if ( target->level > (ch->level + 12) )
      {
         act("$n tells you, 'Fight your own battles and prove your worth paladin'", target, NULL, ch,
         TO_VICT);
         continue;
      }
      if ( number_percent() > ( ch->level - target->level + 70) )
      {
         act("Your call to arms gets little more than a passing consideration from $N.", ch, NULL, target, TO_CHAR);
         check_improve(ch,gsn_rally, FALSE,2);
         continue;
      }
      ch->mana -= 15;
      act("$N rallys to your call!", ch, NULL, target, TO_CHAR);
      act("$n screams and rushes to attack $N!", target, NULL, ch->fighting, TO_NOTVICT);
      act("$n screams and rushes forwards to attack you!", target, NULL, ch->fighting, TO_VICT);
      multi_hit(target, ch->fighting, TYPE_UNDEFINED);
      continue;
   }
   WAIT_STATE(ch,12);
   return;
}

void do_iron_resolve(CHAR_DATA *ch,char *argument)
{
   AFFECT_DATA af;

   if (is_affected(ch,gsn_iron_resolve))
   {
      send_to_char("Your mind is already firmly set on your inner being.\n\r",ch);
      return;
   }
   if (ch->mana < 100)
   {
      send_to_char("You don't have the mental concentration right now.\n\r",ch);
      return;
   }

   if (number_percent() > get_skill(ch,gsn_iron_resolve))
   {
      send_to_char("You try to concentrate on your inner being but fail to maintain it.\n\r",ch);
      ch->mana -= 50;
      WAIT_STATE(ch,12);
      return;
   }

   send_to_char("You feel yourself come together as mind and body.\n\r",ch);

   af.where = TO_AFFECTS;
   af.type = gsn_iron_resolve;
   af.level = ch->level;
   af.location = 0;
   af.bitvector = 0;
   af.modifier = 0;
   af.duration = ch->level/3;
   ch->mana -= 100;
   WAIT_STATE(ch,12);
}

void do_quiet_movement(CHAR_DATA *ch, char *argument)
{
   AFFECT_DATA af;
   int chance;

   chance = get_skill(ch,gsn_quiet_movement);
   if (chance <= 0
   || /*ch->level < skill_table[gsn_quiet_movement].skill_level[ch->class]*/
   !has_skill(ch,gsn_quiet_movement))
   {
      send_to_char("You don't know how to move with silent stealth through the wilderness.\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_quiet_movement))
   {
      send_to_char("You are already attempting to move silently through the wilderness.\n\r",ch);
      return;
   }
   if (ch->in_room->sector_type == SECT_FOREST)
   {
      send_to_char("You attempt to move quietly through the forest.\n\r",ch);
   }
   else if (ch->in_room->sector_type == SECT_MOUNTAIN)
   {
      send_to_char("You attempt to move quietly through the mountains.\n\r",ch);
   }
   else if (ch->in_room->sector_type == SECT_HILLS)
   {
      send_to_char("You attempt to move quietly through the hills.\n\r",ch);
   }
   else
   {
      send_to_char("You aren't in the right kind of wilderness to mvoe quietly.\n\r",ch);
      return;
   }

   if (number_percent() > chance)
   {
      check_improve(ch,gsn_quiet_movement,FALSE,1);
      return;
   }
   check_improve(ch,gsn_quiet_movement,TRUE,1);

   af.where = TO_AFFECTS;
   af.type = gsn_quiet_movement;
   af.location = 0;
   af.modifier = 0;
   af.duration = ch->level;
   af.level = ch->level;
   af.bitvector = 0;
   affect_to_char(ch,&af);
   return;
}

void do_surround(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *victim = NULL;
   CHAR_DATA *check;
   int chance,found;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];

   if (get_skill(ch,gsn_surround) <= 0){
      send_to_char("Huh?\n\r",ch);
      return;
   }


   if (check_peace(ch)) return;
   one_argument(argument,arg);
   if (arg[0] != '\0'){
      victim = get_char_room(ch,arg);
   }
   else
   {
      if (ch->fighting != NULL)
      victim = ch->fighting;
   }

   if (victim == NULL){
      send_to_char("Attempt to surround who?\n\r",ch);
      return;
   }

   if (victim == ch){
      send_to_char("Why surround yourself?\n\r",ch);
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }

   if (house_down(ch,HOUSE_EMPIRE))
   return;

   found = FALSE;

   sprintf(buf,"Help! %s is trying to surround me!",PERS(ch,victim));
   if (!IS_NPC(victim))
   do_myell(victim,buf);

   if (ch->fighting == NULL){
      sprintf(log_buf, "[%s] surrounded [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
      multi_hit(ch,victim,TYPE_UNDEFINED);
   }

   for(check = ch->in_room->people; check != NULL; check = check->next_in_room){
      if(IS_NPC(check) && (check->pIndexData->vnum == MOB_VNUM_EMPIRE_G)
      && (check->master == ch))
      {
         found = TRUE;
         sprintf(buf,"Help! %s is trying to surround me!",PERS(check,victim));
         if (!IS_NPC(victim))
         do_myell(victim,buf);
         if (!is_safe(check, victim, IS_SAFE_SILENT))
         one_hit(check,victim,gsn_surround);
      }
   }

   if (found == FALSE){
      send_to_char("You can't surround them by yourself.\n\r",ch);
      WAIT_STATE(ch,skill_table[gsn_surround].beats);
      return;
   }


   chance = get_skill(ch,gsn_surround)/2;

   if (number_percent() > chance){
      send_to_char("Your forces fail to surround them.\n\r",ch);
      check_improve(ch,gsn_surround,FALSE,1);
      WAIT_STATE(ch,skill_table[gsn_surround].beats);
      return;
   }

   if (found == TRUE){
      send_to_char("Your forces successfully surround them!\n\r",ch);
      send_to_char("You are surrounded!\n\r",victim);
      DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
   }
   check_improve(ch,gsn_surround,TRUE,1);
   WAIT_STATE(ch,skill_table[gsn_surround].beats);

   return;
}

void do_spike(CHAR_DATA *ch,char *argument)
{
   CHAR_DATA *victim;
   int chance, dam;
   char arg[MAX_INPUT_LENGTH];

   one_argument(argument,arg);
   if (IS_NPC(ch))
   return;

   if ((get_skill(ch,gsn_spike) <= 0)
   || /*ch->level < skill_table[gsn_spike].skill_level[ch->class]*/
   !has_skill(ch,gsn_spike))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (arg[0] == '\0')
   {
      send_to_char("Attempt to spike which undead?\n\r",ch);
      return;
   }
   if ( (victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't do that.\n\r",ch);
      return;
   }
   if (victim->fighting != NULL || victim->position == POS_FIGHTING)
   {
      send_to_char("They are moving around too much to get in close for the kill.\n\r",ch);
      return;
   }
   if (!IS_SET(victim->act,ACT_UNDEAD))
   {
      send_to_char("You can only spike your weapon against undead.\n\r",ch);
      return;
   }

   if (is_safe(ch,victim, 0))
   return;

   if (oblivion_blink(ch, victim))
   {
      return;
   }
   chance = get_skill(ch,gsn_spike)/2;
   chance += ch->level;
   chance -= victim->level * 3/2;
   chance -= number_range(0,15);
   if (!can_see(victim,ch))
   chance += 10;
   if (victim->position == POS_FIGHTING)
   chance -= 25;
   else if (victim->position == POS_SLEEPING)
   chance += 10;
   else chance -= 10;

   chance /= 2;
   chance = URANGE(2,chance,90);

   act("$n strikes out at $N with deadly intensity.",ch,0,victim,TO_NOTVICT);
   act("You strike out at $N with deadly intensity.",ch,0,victim,TO_CHAR);
   act("$n strikes at you with deadly intensity.",ch,0,victim,TO_VICT);

   if (number_percent() < chance
   && can_instakill(ch, victim))
   {
      send_to_char("With agonising pain your skull is smashed by the blow!\n\r",victim);
      act("Your blow shatters $N's skull into bloody fragments!",ch,0,victim,TO_CHAR);
      act("$N's skull is shattered into bits of mangled flesh and bone by $n's strike!",ch,0,victim,TO_NOTVICT);
      raw_kill(ch,victim);
      check_improve(ch,gsn_spike,TRUE,2);
      return;
   }
   else
   {
      send_to_char("You feel a sharp pain searing your skull!\n\r",victim);
      act("Your deathstrike smashes $N's skull but fails to kill.",ch,0,victim,TO_CHAR);
      dam = ch->level * 2;
      dam += dice(ch->level, 4);
      damage(ch,victim,dam,gsn_spike,DAM_PIERCE,TRUE);
      check_improve(ch,gsn_spike,FALSE,1);
   }

   return;
}

void check_doublestrike(CHAR_DATA *ch, CHAR_DATA *victim, int dam_type)
{
   int dam;

   if (ch->fighting != victim)
   {
      return;
   }
   if (is_safe(ch,victim, IS_SAFE_SILENT))
   return;

   /*   power will work with item down, but no messages during fights for
   everyone- wervdon

   if (house_down(ch,HOUSE_VALOR))
   return;
   */
   if (get_skill(ch,gsn_doublestrike) <= 0)
   return;
   if (number_percent() > (10 + ch->level/5))
   return;
   if (number_percent() > get_skill(ch,gsn_doublestrike)){
      check_improve(ch,gsn_doublestrike,FALSE,1);
      return;
   }

   dam = (ch->level)/2 + dice(2,(ch->level/2));

   act("$n rapidly strikes at $N again!",ch,0,victim,TO_NOTVICT);
   act("You rapidly strike at $N again!",ch,0,victim,TO_CHAR);
   act("$n rapidly strikes at you again!",ch,0,victim,TO_VICT);

   damage(ch,victim,dam,gsn_doublestrike,dam_type,TRUE);
   check_improve(ch,gsn_doublestrike,TRUE,1);
   return;
}

void do_cripple( CHAR_DATA *ch, char *argument )
{
   AFFECT_DATA af;
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   int chance, dam;
   char buf[MAX_STRING_LENGTH];

   if ( (chance = get_skill(ch,gsn_cripple)) <= 0
   ||   (!IS_NPC(ch)
   && /* ch->level < skill_table[gsn_cripple].skill_level[ch->class]*/
   !has_skill(ch,gsn_cripple)))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (house_down(ch,HOUSE_ANCIENT))
   return;

   one_argument(argument,arg);


   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }

   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (is_safe(ch,victim, 0))
   return;

   if (is_affected(victim,gsn_cripple))
   {
      send_to_char("They are still suffering from a previous crippling blow.\n\r",ch);
      return;
   }

   if (victim == ch)
   {
      send_to_char("Try ramming your head into the wall.\n\r",ch);
      return;
   }

   if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
   {
      act("$N is your beloved master.",ch,NULL,victim,TO_CHAR);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /* modifiers */

   /* dex */
   chance += get_curr_stat(ch,STAT_DEX);
   chance -= get_curr_stat(victim,STAT_DEX) * 3 / 2;

   /* speed */
   if
   (
      IS_SET(ch->off_flags, OFF_FAST) ||
      IS_AFFECTED(ch,AFF_HASTE)
   )
   chance += 10;
   if
   (
      IS_SET(victim->off_flags, OFF_FAST) ||
      IS_AFFECTED(victim,AFF_HASTE)
   )
   chance -= 20;
   if (is_affected(victim, gsn_cloak_form))
   chance+=10;
   if(IS_SET(victim->act, PLR_HONORBOUND))
   chance-=30;

   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level) * 2;


   /* now the attack */
   if (number_percent() < chance)
   {
      af.where = TO_AFFECTS;
      af.type  = gsn_cripple;
      af.level = ch->level;
      af.bitvector  = 0;
      af.bitvector2 = 0;
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (ch->fighting == NULL ||
         victim->fighting == NULL)
      )
      {
         sprintf(buf, "Help! %s is crippling me!", PERS(ch, victim));
         do_myell(victim, buf);
         sprintf(log_buf, "[%s] crippled [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      switch (number_range(1, 6))
      {
         case (1):  /* Leg Shot */
         {
            act
            (
               "$n strikes you hard in the leg, fracturing it!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N hard in the leg, fracturing it!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N hard in the leg, fracturing it!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            dam = (ch->drain_level + ch->level) / 2;
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(ch->level / 5, ch->level / 4);
            af.duration  = 3;
            af.modifier  = -3;
            victim->move = victim->move / 2 - number_range(0, ch->level);
            if (victim->move < 0)
            {
               victim->move = 0;
            }
            af.location = APPLY_DEX;
            affect_to_char(victim, &af);
            damage
            (
               ch,
               victim,
               dam,
               gsn_cripple,
               DAM_BASH,
               TRUE
            );
            break;
         }
         case (2):  /* Arm Shot */
         {
            act
            (
               "$n strikes you hard in the arm, fracturing it!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N hard in the arm, fracturing it!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N hard in the arm, fracturing it!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            dam = (ch->drain_level + ch->level) / 2;
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(ch->level / 5, ch->level / 4);
            af.duration  = 3;
            af.modifier  = -6;
            af.location  = APPLY_STR;
            affect_to_char(victim, &af);
            if (number_range(1, 2) == 1)
            {
               OBJ_DATA *obj, *secondary;
               if
               (
                  (
                     obj = get_eq_char(victim, WEAR_WIELD)
                  ) != NULL &&
                  !IS_OBJ_STAT(obj, ITEM_NOREMOVE)
               )
               {
                  obj_from_char(obj);
                  act
                  (
                     "Your weapon falls from your grasp!",
                     ch,
                     NULL,
                     victim,
                     TO_VICT
                  );
                  act
                  (
                     "$N's weapon falls from $S grasp!",
                     ch,
                     NULL,
                     victim,
                     TO_NOTVICT
                  );
                  if
                  (
                     IS_OBJ_STAT(obj, ITEM_NODROP) ||
                     IS_OBJ_STAT(obj, ITEM_INVENTORY)
                  )
                  {
                     obj_to_char(obj, victim);
                  }
                  else
                  {
                     obj_to_room(obj, victim->in_room);
                     if
                     (
                        IS_NPC(victim) &&
                        victim->wait == 0 &&
                        can_see_obj(victim, obj)
                     )
                     get_obj(victim, obj, NULL, 0);
                  }
                  reslot_weapon(victim);
                  if
                  (
                     (
                        secondary = get_eq_char(victim, WEAR_DUAL_WIELD)
                     ) != NULL
                  )
                  {
                     unequip_char(victim, secondary);
                     equip_char(victim, secondary, WEAR_WIELD);
                  }
               }
            }
            damage
            (
               ch,
               victim,
               dam,
               gsn_cripple,
               DAM_BASH,
               TRUE
            );
            break;
         }
         case (3):  /* Head Shot */
         {
            act
            (
               "$n strikes you hard in the head, dazing you!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N hard in the head, dazing $M!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N hard in the head, dazing $M!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            dam = (ch->drain_level + ch->level) / 2;
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(ch->level / 5, ch->level / 4);
            af.duration  = 1;
            af.modifier  = -10;
            af.location  = APPLY_INT;
            affect_to_char(victim, &af);
            af.location  = APPLY_WIS;
            affect_to_char(victim, &af);
            victim->mana = victim->mana / 2 - number_range(0, 2 * ch->level);
            if (victim->mana < 0)
            {
               victim->mana = 0;
            }
            DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
            damage
            (
               ch,
               victim,
               dam,
               gsn_cripple,
               DAM_BASH,
               TRUE
            );
            break;
         }
         case (4):  /* Stomach Shot */
         {
            act
            (
               "$n strikes you hard in the stomach and knocks your breath out!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You strike $N hard in the stomach and knock $S breath out!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n strikes $N hard in the stomach and knocks $S breath out!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            dam = (ch->drain_level + ch->level) / 2;
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(ch->level / 5, ch->level / 4);
            DAZE_STATE(victim, 3 * PULSE_VIOLENCE);
            damage
            (
               ch,
               victim,
               dam,
               gsn_cripple,
               DAM_BASH,
               TRUE
            );
            break;
         }
         case 5:  /* Eye Shot */
         {
            act
            (
               "$n pokes you in the eye!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You poke $N in the eye!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n pokes $N in the eye!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            dam = (ch->drain_level + ch->level) / 2;
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(ch->level / 5, ch->level / 4);
            af.duration     = 3;
            af.location     = APPLY_HITROLL;
            af.modifier     = -5;
            af.bitvector    = AFF_BLIND;
            affect_to_char(victim, &af);
            damage
            (
               ch,
               victim,
               dam,
               gsn_cripple,
               DAM_BASH,
               TRUE
            );
            break;
         }
         case (6):  /* Throat Shot */
         {
            act
            (
               "$n jabs a stiff hand into your throat!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You jab $N in the throat with a stiff hand!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n jabs $N in the throat with a stiff hand!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            dam = (ch->drain_level + ch->level) / 2;
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(0, (ch->drain_level + ch->level) / 6);
            dam += number_range(ch->level / 5,ch->level / 4);
            af.duration     = 3;
            af.location     = APPLY_NONE;
            af.modifier     = -1;
            affect_to_char(victim, &af);
            af.type         = gsn_mute;
            af.location     = 0;
            af.modifier     = 0;
            affect_to_char(victim, &af);
            damage
            (
               ch,
               victim,
               dam,
               gsn_cripple,
               DAM_BASH,TRUE
            );
            break;
         }
         default:
         {
            send_to_char("Your attempt to cripple flounders.\n\r", ch);
            check_improve(ch, gsn_cripple, FALSE, 1);
            return;
         }
      }
      check_improve(ch, gsn_cripple, TRUE, 1);
      WAIT_STATE(ch, skill_table[gsn_cripple].beats);
      if
      (
         !IS_NPC(ch) &&
         !IS_IMMORTAL(ch) &&
         !IS_IMMORTAL(victim)
      )
      {
         if
         (
            !IS_NPC(victim) ||
            (
               IS_AFFECTED(victim, AFF_CHARM) &&
               victim->master != ch
            ) ||
            (
               IS_NPC(victim) &&
               victim->house
            )
         )
         {
            QUIT_STATE(ch, 20);
            if (!IS_NPC(victim))
            {
               QUIT_STATE(victim, 20);
            }
         }
      }
   }
   else
   {
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (ch->fighting == NULL ||
         victim->fighting == NULL)
      )
      {
         sprintf
         (
            buf,
            "Help! %s just tried to cripple me!",
            PERS(ch, victim)
         );
         do_myell(victim, buf);
         sprintf
         (
            log_buf,
            "[%s] tried to cripple [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
      }
      damage
      (
         ch,
         victim,
         0,
         gsn_cripple,
         DAM_BASH,
         TRUE
      );
      WAIT_STATE(ch, skill_table[gsn_cripple].beats * 2 / 3);
      check_improve(ch, gsn_cripple, FALSE, 1);
      if
      (
         !IS_NPC(ch) &&
         !IS_IMMORTAL(ch) &&
         !IS_IMMORTAL(victim)
      )
      {
         if
         (
            !IS_NPC(victim) ||
            (
               IS_AFFECTED(victim, AFF_CHARM) &&
               victim->master != ch
            ) ||
            (
               IS_NPC(victim) &&
               victim->house
            )
         )
         {
            QUIT_STATE(ch, 20);
            if (!IS_NPC(victim))
            {
               QUIT_STATE(victim, 20);
            }
         }
      }
   }
}

void do_fists(CHAR_DATA *ch, char * argument)
{
   AFFECT_DATA af;
   sh_int sn=-1;
   int school;

   if (ch->class != (GUILD_MONK -1)){
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (IS_NPC(ch)){
      send_to_char("Huh?\n\r",ch);
      return;
   }

   school = ch->pcdata->special;

   if (school == SUBCLASS_SCHOOL_DRAGON){
      sn = gsn_fists_fire;
   }
   if (school == SUBCLASS_SCHOOL_SNAKE){
      sn = gsn_fists_poison;
   }
   if (school == SUBCLASS_SCHOOL_CRANE){
      sn = gsn_fists_ice;
   }
   if (school == SUBCLASS_SCHOOL_MANTIS){
      sn = gsn_fists_divine;
   }
   if (school == SUBCLASS_SCHOOL_TIGER){
      sn = gsn_fists_fury;
   }
   if(sn==-1)
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (!has_skill(ch,sn) || ch->pcdata->learned[sn] <0){
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,sn)){
      send_to_char("You are already concentrating on your fighting style!\n\r",ch);
      return;
   }

   if (ch->mana < 25){
      send_to_char("You don't have the mental energy.\n\r",ch);
      return;
   }
   ch->mana -= 25;
   if (number_percent() > get_skill(ch,sn)){
      send_to_char("You fail to concentrate on your inner strength.\n\r",ch);
      check_improve(ch,sn,FALSE,1);
      return;
   }
   send_to_char("You begin to apply your inner strength to your fighting style!\n\r",ch);

   check_improve(ch,sn,TRUE,1);

   af.where     = TO_AFFECTS;
   af.type      = sn;
   af.level     = ch->level;
   af.duration  = 5;
   af.location  = 0;
   af.modifier  = 0;
   af.bitvector = 0;
   if (ch->pcdata->special == SUBCLASS_SCHOOL_TIGER){
      af.duration = ch->level/3;
      af.location = APPLY_DAMROLL;
      af.modifier = ch->level/5;
      affect_to_char(ch,&af);
      af.location = APPLY_HITROLL;
   }
   affect_to_char( ch, &af );


   WAIT_STATE(ch,24);
   return;
}

void do_open_claw(CHAR_DATA *ch, char * argument)
{
   AFFECT_DATA af;
   sh_int sn = gsn_open_claw;

   if (IS_NPC(ch)){
      send_to_char("Huh?\n\r",ch);
      return;
   }


   if (!has_skill(ch,sn) || ch->pcdata->learned[sn] <0){
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,sn)){
      send_to_char("You are already practicing the art of open claw fighting!\n\r",ch);
      return;
   }

   if (number_percent() > get_skill(ch,sn)){
      send_to_char("You fail to focus your chi to form claws.\n\r",ch);
      check_improve(ch,sn,FALSE,1);
      return;
   }
   send_to_char("You focus your chi to harden your fingers into claws!\n\r",ch);

   check_improve(ch,sn,TRUE,1);

   af.where     = TO_AFFECTS;
   af.type      = sn;
   af.level     = ch->level;
   af.duration  = 5;
   af.location  = 0;
   af.modifier  = 0;
   af.bitvector = 0;
   affect_to_char( ch, &af );
   WAIT_STATE(ch,24);
   return;
}

void do_iron_will(CHAR_DATA *ch, char * argument)
{
   AFFECT_DATA af;
   sh_int sn = gsn_iron_will;

   if (IS_NPC(ch)){
      send_to_char("Huh?\n\r",ch);
      return;
   }


   if (!has_skill(ch,sn) || ch->pcdata->learned[sn] <0){
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (ch->mana < 35){
      send_to_char("You don't have enough mental energy to focus your inner strength.\n\r",ch);
      return;
   }

   if (is_affected(ch,sn)){
      send_to_char("You are already focusing your inner strength!\n\r",ch);
      return;
   }

   ch->mana -= 35;

   if (number_percent() > get_skill(ch,sn)){
      send_to_char("You fail to focus your inner strength.\n\r",ch);
      check_improve(ch,sn,FALSE,1);
      return;
   }
   send_to_char("You focus your inner strength, and your will becomes hard as iron.\n\r",ch);

   check_improve(ch,sn,TRUE,1);

   af.where     = TO_AFFECTS;
   af.type      = sn;
   af.level     = ch->level;
   af.duration  = ch->level/3 + 5;
   af.location  = 0;
   af.modifier  = 0;
   af.bitvector = 0;
   affect_to_char( ch, &af );
   WAIT_STATE(ch,24);
   return;
}

void do_spin_kick(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   char buf[MAX_STRING_LENGTH];
   int dam;
   int skill;
   OBJ_DATA* obj;

   if
   (
      (
         skill = get_skill(ch, gsn_spin_kick)
      ) < 1 ||
      (
         !IS_NPC(ch) &&
         !has_skill(ch, gsn_spin_kick)
      )
   )
   {
      send_to_char("Careful!  You might get dizzy....\n\r", ch);
      return;
   }

   if (check_peace(ch))
   {
      return;
   }

   ;
   if
   (
      (
         (obj = get_eq_char(ch, WEAR_FEET)) != NULL ||
         (obj = get_eq_char(ch, WEAR_HOOVES)) != NULL ||
         (obj = get_eq_char(ch, WEAR_FOURHOOVES)) != NULL
      ) &&
      obj->pIndexData->vnum == OBJ_VNUM_SHACKLES
   )
   {
      WAIT_STATE(ch, 24);
      send_to_char("You cannot kick anything while in chains!\n\r", ch);
      return;
   }

   if (number_percent() < UMIN(skill, 98))
   {
      switch(number_range(1,4))
      {
         case(1):
         {
            send_to_char
            (
               "You spin in a tight circle, rapidly kicking out multiple times!\n\r",
               ch
            );
            act
            (
               "$n spins in a circle, rapidly kicking out multiple times!",
               ch,
               NULL,
               NULL,
               TO_ROOM
            );
            break;
         }
         case(2):
         {
            send_to_char
            (
               "You spin on one leg with your knee tucked before leaping into a vicious tornado kick!\n\r",
               ch
            );
            act
            (
               "$n spins on one leg with $s knee tucked in before leaping into a vicious tornado kick!",
               ch,
               NULL,
               NULL,
               TO_ROOM
            );
            break;
         }
         case(3):
         {
            send_to_char
            (
               "You leap into the air with one leg out and spin in a tight circle!\n\r",
               ch
            );
            act
            (
               "$n leaps into the air with one leg out and spins in a tight circle!",
               ch,
               NULL,
               NULL,
               TO_ROOM
            );
            break;
         }
         case(4):
         {
            send_to_char
            (
               "You focus your chi and run sideways in a circle in midair while lashing out with deadly kicks!\n\r",
               ch
            );
            act
            (
               "$n focuses $s chi and runs sideways in a circle midair while lashing out with deadly kicks!",
               ch,
               NULL,
               NULL,
               TO_ROOM
            );
            break;
         }
      }

      for(vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         vch_next = vch->next_in_room;
         if
         (
            is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK) ||
            is_same_group(ch, vch) ||  /* checks ch == vch */
            oblivion_blink(ch, vch)
         )
         {
            continue;
         }

         if
         (
            !IS_NPC(ch) &&
            !IS_NPC(vch) &&
            (
               ch->fighting == NULL ||
               vch->fighting == NULL
            )
         )
         {
            switch(number_range(0, 2))
            {
               case (0):
               {
                  sprintf
                  (
                     buf,
                     "Argh, %s is spin kicking!",
                     PERS(ch, vch)
                  );
                  break;
               }
               default:  /* 1, 2 */
               {
                  sprintf
                  (
                     buf,
                     "Help! %s just attacked me!",
                     PERS(ch, vch)
                  );
                  break;
               }
            }
            do_myell(vch, buf);
            sprintf
            (
               log_buf,
               "[%s] spin kicked [%s] at %d",
               ch->name,
               vch->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
         }

         dam = dice(6, ch->level / 3) + 40;
         dam += dice(8, skill / 5);

         damage(ch, vch, dam, gsn_spin_kick, DAM_BASH, TRUE);
      }
      check_improve(ch, gsn_spin_kick, TRUE, 1);
      WAIT_STATE(ch, skill_table[gsn_spin_kick].beats);
   }
   else
   {
      send_to_char("You stumble as you try to perform a spin kick.\n\r", ch);
      check_improve(ch, gsn_spin_kick, FALSE, 1);
      WAIT_STATE(ch, skill_table[gsn_spin_kick].beats / 2);
   }
   return;
}

void do_iron_palm( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   CHAR_DATA *victim;
   AFFECT_DATA* paf;
   bool crit;
   int crit_chance;
   int mod;
   int chance;
   int dam;

   if( (chance = get_skill(ch,gsn_iron_palm)) < 1
   || !has_skill(ch,gsn_iron_palm) )
   {
      send_to_char("You are unskilled in that technique!\n\r",ch);
      return;
   }

   one_argument( argument, arg );

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if
   (
      (
         victim = get_char_room(ch, arg)
      ) == NULL
   )
   {
      send_to_char("They are not here.\n\r",ch);
      return;
   }
   if (ch->mana < 25)
   {
      send_to_char("You do not have enough focus to do that!\n\r", ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (number_percent() > chance - 10)
   {
      act("Your concentration slips as you strike at $N!",ch,0,victim,TO_CHAR);
      act("$n strikes at you, but loses $s concentration!",ch,0,victim,TO_VICT);
      act("$n strikes at $N, but loses $s concentration!",ch,0,victim,TO_NOTVICT);

      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (ch->fighting == NULL || victim->fighting == NULL))
      {
         switch(number_range(0,2))
         {
            case (0):
            sprintf(buf,"Help! %s just tried to viciously strike me with a hardened palm!",
            PERS(ch,victim));
            break;
            case (1):
            sprintf(buf,"Help! %s is attacking me with an Iron Palm!",PERS(ch,victim));
            break;
            case (2):
            sprintf(buf,"Help! %s just attacked me!",PERS(ch,victim));
         }
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] iron palmed [%s] at %d", ch->name,
         victim->name,victim->in_room->vnum);
         log_string(log_buf);
      }

      damage(ch,victim,0,gsn_iron_palm,DAM_BASH,TRUE);
      ch->mana = UMAX(0, ch->mana - 12);
      check_improve(ch,gsn_iron_palm,FALSE,1);
      WAIT_STATE(ch, skill_table[gsn_iron_palm].beats/2);
      return;
   }

   act
   (
      "You channel your will through your palm as you strike $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n viciously strikes you with a hardened palm!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n viciously strikes $N with a hardened palm!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );

   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (ch->fighting == NULL || victim->fighting == NULL))
   {
      switch(number_range(0,2))
      {
         case (0):
         sprintf(buf,"Help! %s just viciously struck me with a hardened palm!",PERS(ch,victim));
         break;
         case (1):
         sprintf(buf,"Help! %s is attacking me with an Iron Palm!",PERS(ch,victim));
         break;
         case (2):
         sprintf(buf,"Help! %s just attacked me!",PERS(ch,victim));
      }

      do_myell(victim,buf);
      sprintf(log_buf, "[%s] iron palmed [%s] at %d", ch->name,
      victim->name,victim->in_room->vnum);
      log_string(log_buf);
   }

   ch->mana = UMAX(0, ch->mana - 25);
   WAIT_STATE(ch, skill_table[gsn_iron_palm].beats);

   dam = dice((ch->level+ch->drain_level)/5,15);
   dam += dice(10,chance/5);
   dam *= battlecry_multiplier(ch, victim, gsn_iron_palm);

   /*
      every level past 40 is 5 points, skill past 75 is 2
      every 20 points is 1% more,
      capped to a range of 10 to 15%
   */
   crit_chance = (ch->level - 40) * 5 + (chance - 75) * 2;
   crit_chance /= 20;
   crit_chance += 10;
   crit_chance = URANGE(10, crit_chance, 15);
   if (number_percent() <= crit_chance)
   {
      crit = TRUE;
      dam *= 3;
      dam /= 2;
      act
      (
         "You knock $N onto $S back!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n knocks you flat onto your back!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's strike knocks $N sprawling backwards!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, PULSE_VIOLENCE * 3 / 2);
   }
   else
   {
      crit = FALSE;
   }
   if (damage(ch, victim, dam, gsn_iron_palm, DAM_BASH, TRUE))
   {
      paf = affect_find(victim->affected, gsn_iron_palm);
      if (paf != NULL)
      {
         mod = paf->modifier;
         affect_strip(victim, gsn_iron_palm);
      }
      else
      {
         mod = 0;
      }
      paf = new_affect();
      paf->where = TO_AFFECTS;
      paf->level = ch->level + ch->drain_level;
      paf->location = APPLY_AC;
      paf->modifier = number_range(10, 25);
      if (crit)
      {
         paf->modifier *= 2;
      }
      paf->modifier += mod;
      if (paf->modifier > 200)
      {
         paf->modifier = 200;
      }
      paf->duration = 2;
      paf->type = gsn_iron_palm;
      affect_to_char(victim, paf);
      free_affect(paf);
   }

   check_improve(ch,gsn_iron_palm,TRUE,1);
   return;
}

/*
* Inflict damage from a hit.
*/
bool damage(CHAR_DATA* ch, CHAR_DATA* victim, int dam, int dt, int dam_type, int show)
{
   extern bool defense_not_countered;
   CHAR_DATA* new_victim;
   OBJ_DATA* obj;
   OBJ_DATA* wield;
   OBJ_DATA* brand;  /* any brand */
   OBJ_DATA* corpse;
   AFFECT_DATA af;
   double damacreduce;
   int victim_ac;
   int orig_dam;
   int temp;
   bool immune = FALSE;
   bool evaded = FALSE;
   bool notselfhit;
   char corpse_name[MAX_INPUT_LENGTH];
   long id;

   defense_not_countered = TRUE;

   if (victim == NULL)
   {
      return FALSE;
   }

   /* Check null rooms */
   if (!check_room(ch, FALSE, NULL))
   {
      /*
      No purge
      bug("Purge in bool damage(ch)", 0);
      */
      return FALSE;
   }
   if (!check_room(victim, FALSE, NULL))
   {
      /*
      No purge
      bug("Purge in bool damage(victim)", 0);
      */
      return FALSE;
   }
   /* If either is in NULL, this will be true */
   if (ch->in_room->vnum != victim->in_room->vnum)
   {
      return FALSE;
   }

   /*
   TRUE, FALSE show up.  Negative (special)values do not do this
   Strip sleep-effects from victim.
   Make attacker visible
   */
   if (show >= 0 && victim != ch)
   {
      un_blackjack(victim, NULL);
      un_strangle(victim, NULL);
      affect_strip(victim, gsn_sleep);
      affect_strip(victim, gsn_stunning_strike);
      affect_strip(victim, gsn_peace);
      affect_strip(victim, gsn_camp);

      affect_strip(ch, gsn_peace);
      affect_strip(ch, gsn_camp);
      un_camouflage(ch, NULL);
      un_shroud(ch, NULL);
      un_earthfade(ch, NULL);
      affect_strip(ch, gsn_stalking);
      un_hide(ch, NULL);
      un_invis(ch, NULL);
      un_sneak(ch, NULL);
      un_forest_blend(ch);  /* - Wicket */
   }
   /* No camping or sitting on furniture when hurt, or fighting */
   if (show >= 0)
   {
      ch->on = NULL;
   }
   victim->on = NULL;
   affect_strip(victim, gsn_camp);
   if (is_affected(victim, gsn_healing_trance))
   {
      send_to_char("You cease to meditate.\n\r", victim);
      affect_strip(victim, gsn_healing_trance);
   }

   notselfhit = (victim != ch);

   if (victim->position == POS_DEAD)
   {
      return FALSE;
   }

   if (is_safe(ch, victim, 0))
   {
      return FALSE;
   }

   /* 0 damage, (misses) */
   if (!dam)
   {
      if
      (
         notselfhit &&
         victim->position > POS_STUNNED
      )
      {
         if (show >= 0)
         {
            if (victim->fighting == NULL)
            {
               set_fighting(victim, ch);
               if
               (
                  IS_NPC(victim) &&
                  HAS_TRIGGER(victim, TRIG_KILL)
               )
               {
                  mp_percent_trigger(victim, ch, NULL, NULL, TRIG_KILL);
               }
            }
            victim->on = NULL;
            if (victim->fighting == NULL)
            {
               victim->position = POS_STANDING;
            }
            else
            {
               victim->position = POS_FIGHTING;
            }
            if (ch->fighting == NULL)
            {
               set_fighting(ch, victim);
            }
            if
            (
               victim->master &&
               victim->master == ch
            )
            {
               stop_follower(victim);
            }
         }
         else
         {
            victim->on = NULL;
            if (victim->fighting == NULL)
            {
               victim->position = POS_STANDING;
            }
            else
            {
               victim->position = POS_FIGHTING;
            }
         }
      }

      if (show > 0)
      {
         dam_message(ch, victim, 0, dt, FALSE);
      }
      else if (show < 0)
      {
         dam_message2(show, victim, 0, dt, immune);
      }
      return FALSE;
   }

   if
   (
      (
         temp = check_ring_focus(ch, victim, dam, dt)
      ) == FOCUS_RING_FULL
   )
   {
      dam *= 5;
      dam /= 2;
   }
   else if (temp == FOCUS_RING_LIMITED)
   {
      dam++;
   }

   /* Reduce damage from dragonbreath */
   if
   (
      (
         dt == gsn_acid_breath ||
         dt == gsn_fire_breath ||
         dt == gsn_frost_breath ||
         dt == gsn_gas_breath ||
         dt == gsn_lightning_breath
      ) &&
      dam > 1500
   )
   {
      dam = 1500;
   }
   /* damage reduction */
   if (dam > 85)
   {
      dam -= 85;
      dam *= 7;
      dam /= 10;
      dam += 85;
   }


   if (notselfhit)
   {
      /*
      Certain attacks are forbidden.
      Most other attacks are returned.
      */
      if
      (
         is_safe(ch, victim, 0)
      )
      {
         return FALSE;
      }
      check_killer(ch, victim);

      if
      (
         (
            dt >= TYPE_HIT ||
            dt == gsn_backstab ||
            dt == gsn_ambush ||
            dt == gsn_cleave ||
            dt == gsn_deathstrike ||
            dt == gsn_iron_palm
         ) &&
         check_counter(ch, victim, dam, dt)
      )
      {
         return FALSE;
      }

      if (victim->position > POS_STUNNED)
      {
         if (show >= 0)
         {
            if (victim->fighting == NULL)
            {
               set_fighting(victim, ch);
               if
               (
                  IS_NPC(victim) &&
                  HAS_TRIGGER(victim, TRIG_KILL)
               )
               {
                  mp_percent_trigger(victim, ch, NULL, NULL, TRIG_KILL);
               }
            }
            victim->on = NULL;
            if (victim->fighting == NULL)
            {
               victim->position = POS_STANDING;
            }
            else
            {
               victim->position = POS_FIGHTING;
            }
            if (ch->fighting == NULL)
            {
               set_fighting(ch, victim);
            }
            if
            (
               victim->master &&
               victim->master == ch
            )
            {
               stop_follower(victim);
            }
         }
         else
         {
            victim->on = NULL;
            if (victim->fighting == NULL)
            {
               victim->position = POS_STANDING;
            }
            else
            {
               victim->position = POS_FIGHTING;
            }
         }
      }
   }

   /*
   Check for parry, and dodge. Relocated here for purpose of
   testing evasive dodge before damage is called.
   */
   if
   (
      dt == gsn_fist_god &&
      number_range(1, 3) == 1 &&
      check_dodge(ch, victim, dt)
   )
   {
      return FALSE;
   }
   if
   (
      notselfhit &&
      (
         dt >= TYPE_HIT ||
         dt == gsn_dual_wield ||
         dt == gsn_fists_divine ||
         dt == gsn_fists_fire ||
         dt == gsn_fists_ice ||
         dt == gsn_fists_poison ||
         dt == gsn_open_claw ||
         dt == gsn_darkforge_fists
      )
   )
   {
      if
      (
         defense_not_countered &&
         (
            new_victim = check_evasive(ch, victim)
         ) != NULL
      )
      {
         victim = new_victim;
         evaded = TRUE;
      }
      else if
      (
         (
            victim->house == HOUSE_LIGHT &&
            check_halo_sun(ch, victim, dt)
         ) ||
         check_void(ch, victim, dt) ||
         check_utara_brand_blur(ch, victim, dt) ||
         check_drinlinda_defense_brand(ch, victim, dt) ||
         check_evasive_defense(ch, victim, dt) ||
        /* check_drithentir_vampiric_brand(ch, victim, dt) ||*/
         (
            defense_not_countered &&
            check_parry(ch, victim, dt)
         ) ||
         (
            defense_not_countered &&
            check_block(ch, victim, dt)
         ) ||
         (
            defense_not_countered &&
            check_side_step(ch, victim, dt)
         ) ||
         (
            defense_not_countered &&
            check_acrobatics(ch, victim, dt)
         ) ||
         (
            defense_not_countered &&
            check_tumble(ch, victim, dt)
         ) ||
         (
            defense_not_countered &&
            check_dodge(ch, victim, dt)
         ) ||
         (
            defense_not_countered &&
            check_shield_block(ch, victim, dt)
         )
      )
      {
         return FALSE;
      }
   }
   if (check_drithentir_vampiric_brand(ch, victim, dt))
   {
      return TRUE;
   }
   if
   (
      evaded &&
      show >= 0 &&
      victim->position > POS_STUNNED
   )
   {
      victim->on = NULL;
      if (victim->fighting == NULL)
      {
         victim->position = POS_STANDING;
      }
      else
      {
         victim->position = POS_FIGHTING;
      }
   }
   if
   (
      dt != gsn_telekinesis &&
      dt != gsn_wind_shear &&
      dt != gsn_mob_pain &&
      dam > 0
   )
   {
      if
      (
         is_affected(victim, gsn_temporal_shield) &&
         number_percent() < 15
      )
      {
         send_to_char
         (
            "You phase out of time and are unaffected by the attack.\n\r",
            victim
         );
         act
         (
            "$E phases out of existence and is unaffected by your attack.\n\r",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         return FALSE;
      }
      if
      (
         is_affected(victim, gsn_iron_scales_dragon) &&
         number_percent() <= 9 + (victim->level - 30) / 5
         /* Starts at 9%, goes up to 13% */
      )
      {
         int reduce = get_skill(victim, gsn_iron_scales_dragon) - 5;
         reduce = URANGE(1, reduce, 95);
         send_to_char
         (
            "You focus deep within your mind and tap into your inner Chi.\n\r"
            "Your skin becomes as strong as iron and absorbs the damage!\n\r",
            victim
         );
         act
         (
            "$n grimaces and gets a wild look!\n\r"
            "$n's skin turns to iron!",
            victim,
            NULL,
            NULL,
            TO_ROOM
         );
         dam -= dam * reduce / 100;
         check_improve(victim, gsn_iron_scales_dragon, TRUE, 4);
      }
   }
   if
   (
      ch != victim &&
      !evaded &&
      show > 0 &&
      frog_dodge(victim, ch, dt)
   )
   {
      return FALSE;
   }
   if
   (
      dt >= TYPE_HIT ||
      dt == gsn_backstab ||
      dt == gsn_ambush ||
      dt == gsn_cleave ||
      dt == gsn_deathstrike ||
      dt == gsn_downstrike ||
      dt == gsn_lunge ||
      dt == gsn_swing ||
      dt == gsn_impale ||
      dt == gsn_jump
   )
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }
   else if
   (
      dt == gsn_dual_backstab ||
      dt == gsn_dual_wield
   )
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else
   {
      wield = NULL;
   }

   if (dt == gsn_archery)
   {
      OBJ_DATA* arrow;
      if
      (
         (
            arrow = get_eq_char(ch, WEAR_ABOUT)
         ) != NULL &&
         IS_SET(arrow->value[1], CONT_IS_QUIVER) &&
         (
            arrow = arrow->contains
         ) != NULL &&
         arrow->item_type == ITEM_WEAPON &&
         arrow->value[0] == WEAPON_ARROWS
      )
      {
         wield = arrow;
         dt = TYPE_HIT + arrow->value[3];
      }
   }


   /*
   * Damage modifiers.
   */

   if( !IS_NPC(victim)
   && victim->pcdata->condition[COND_DRUNK]  > 10 )
   dam -= dam / 10;

   if
   (
      is_affected(victim, gsn_iron_will) &&
      number_percent() < 30 &&
      dt != gsn_mob_pain
   )
   {
      int skill = get_skill(ch, gsn_iron_will);

      if (skill >= 75)
      {
         /* ramp up quickly from 1/6th up to 1/3rd */
         dam -= dam * (skill - 50) / 150;
      }
      else
      {
         /* slowly ramp up to 1/6th */
         dam -= dam * skill / 450;
      }
   }

   if
   (
      is_affected(victim, gsn_dark_armor) &&
      !IS_AFFECTED(victim, AFF_SANCTUARY) &&
      dt != gsn_poison &&
      dt != gsn_plague &&
      dt != gsn_mob_pain
   )
   {
      dam = dam - 4*dam/10;
   }

   if
   (
      IS_AFFECTED(victim, AFF_SANCTUARY) &&
      dt != gsn_poison &&
      dt != gsn_plague &&
      dt != gsn_mob_pain &&
      (
         !wield ||
         wield->pIndexData->vnum != OBJ_VNUM_STRIFE_SPEAR
      )
   )
   {
      dam -= dam/2;
   }


   /* elemental masteries -werv */
   if
   (
      dt < TYPE_HIT &&
      !IS_NPC(ch) &&
      (
         (
            (
               dt == gsn_windwall ||
               dam_type == DAM_LIGHTNING
            ) &&
            number_percent() < get_skill(ch, gsn_airmastery)
         ) ||
         (
            dam_type == DAM_FIRE &&
            number_percent() < get_skill(ch, gsn_firemastery)
         ) ||
         (
            (
               dam_type == DAM_COLD ||
               dam_type == DAM_DROWNING
            ) &&
            number_percent() < get_skill(ch, gsn_watermastery)
         ) ||
         (
            dam_type == DAM_BASH &&
            number_percent() < get_skill(ch, gsn_earthmastery)
         )
      )
   )
   {
      dam += dam/5;
   }

   /* strength adjust -werv */
   if
   (
      dam != 0 &&
      (
         dt >= TYPE_HIT ||
         dt == gsn_dual_wield
      )
   )
   {
      float mult = (float) get_curr_stat(ch, STAT_STR);
      if (ch->class == CLASS_MONK)
      {
         mult = mult / 20.0;
      }
      else
      {
         mult = mult / 23.0;
      }
      /*
      Str cap removed.
      if (mult > 1)
      {
      mult = 1;
      }
      */
      dam = dam * mult;
      if (dam < 1)
      {
         dam = 1;
      }
   }


   /* barrier spell after sanctuary and ac -Werv */
   if
   (
      is_affected(victim, gsn_barrier) &&
      dt != gsn_mob_pain
   )
   {
      AFFECT_DATA* af;
      af = victim->affected;
      while (af != NULL && af->type != gsn_barrier)
      {
         af = af->next;
      }
      if (af->duration != -1)
      {
         af->duration = af->duration - dam / 5;
         if (af->duration <= 0)
         {
            send_to_char("Your barrier has fallen.\n\r", victim);
            affect_strip(victim, gsn_barrier);
         }
      }
      if (af->type != gsn_barrier)
      {
         log_string("BUG: Barrier affect not found!");
      }
      dam -= dam / 5;
   }

   if
   (
      victim->morph_form[0] == MORPH_BEAR &&
      (
         dam_type == DAM_BASH ||
         dam_type == DAM_PIERCE ||
         dam_type == DAM_SLASH
      )
   )
   {
      dam -= dam * 3 / 10;
   }
   if
   (
      (
         dt >= TYPE_HIT ||
         dt == gsn_dual_wield ||
         dt == gsn_backstab ||
         dt == gsn_dual_backstab ||
         dt == gsn_fist_god ||
         (
            dt == gsn_demon_swarm &&
            !IS_NPC(victim)
         ) ||
         dt == gsn_ambush ||
         dt == gsn_cleave ||
         dt == gsn_deathstrike ||
         dt == gsn_iron_palm ||
         dt == gsn_swing ||
         dt == gsn_archery ||
         HITS
      ) &&
      notselfhit
   )
   {
      if( is_affected(victim,gsn_steel_nerves))
      dam -= dam/2;
      if ( has_skill(victim,gsn_toughen) &&
      number_percent() < get_skill(victim, gsn_toughen))
      {
         dam -= dam/5;
         check_improve(victim,gsn_toughen,TRUE,4);
      }

      switch(dam_type)
      {
         case(DAM_PIERCE):victim_ac = GET_AC(victim,AC_PIERCE);       break;
         case(DAM_BASH):  victim_ac = GET_AC(victim,AC_BASH);         break;
         case(DAM_SLASH): victim_ac = GET_AC(victim,AC_SLASH);        break;
         default:         victim_ac = GET_AC(victim,AC_EXOTIC);       break;
      };
      victim_ac = -victim_ac;
      if (wield != NULL && IS_WEAPON_STAT(wield,WEAPON_PIERCING))
      victim_ac -= ((float)victim_ac*(float)wield->level/200.0);

      if (victim_ac > 400)
      damacreduce = 40.0 + ((float) victim_ac-400.0)/50.0;
      else
      damacreduce = ((float) victim_ac)/10.0;
      if (victim_ac < 0)
      damacreduce = 0;
      dam -= (float) dam * damacreduce/100.0;

   } else
   if
   (
      dt > 0 &&
      dt != gsn_mob_pain
   )
   {
      if( notselfhit
      && is_affected(victim,gsn_steel_nerves) )
      dam -= dam*4/10;
   }

   if
   (
      (
         dam_type == DAM_COLD ||
         dam_type == DAM_FIRE ||
         dam_type == DAM_HOLY ||
         dam_type == DAM_NEGATIVE ||
         dam_type == DAM_ACID
      ) &&
      dam > 125 &&
      (
         obj = get_eq_char(victim, WEAR_HEAD)
      ) != NULL &&
      obj->pIndexData->vnum == OBJ_VNUM_TIARA
   )
   {
      dam -= 125;
      dam *= 6;
      dam /= 10;
      dam += 125;
   }

   if
   (
      show > 0 &&
      check_crown_blood(ch,victim,dt,dam,dam_type)
   )
   {
      return FALSE;
   }

   /* Dielantha's cold resistance - runge*/
   if
   (
      is_affected(victim, gsn_sdragon_armor) &&
      dam_type == DAM_COLD
   )
   {
      dam -= dam / 3;
   }

   if
   (
      !IS_NPC(ch) &&
      ch->pcdata->special == SUBCLASS_CORRUPTOR &&
      dam_type == DAM_NEGATIVE
   )
   {
      dam += dam / 3;
   }

   if
   (
      (
         dam_type == DAM_BASH ||
         dam_type == DAM_SLASH
      ) &&
      is_affected(victim, gsn_strengthen_bone)
   )
   {
      dam -= dam / 3;
   }

   if (dt != gsn_mob_pain)
   {
      if
      (
         (
            IS_AFFECTED(victim, AFF_PROTECT_EVIL) &&
            IS_EVIL(ch)
         ) ||
         (
            IS_AFFECTED(victim, AFF_PROTECT_GOOD) &&
            IS_GOOD(ch)
         )
      )
      {
         dam -= dam / 4;
      }
      else if (is_affected(victim, gsn_justice_brand2))
      {
         dam -= dam/5;
      }
   }

   if (is_affected(victim, gsn_shroud_of_pro))
   {
      dam = (float) dam *  (85.0 / 100.0);
   }

   immune = FALSE;

   if (eye_of_beholder_absorb(ch, victim, dt, dam, dam_type))
   {
      return FALSE;
   }

   if
   (
      dt != gsn_meteor &&
      dt != gsn_ameteor
   )
   {
      switch(check_immune(victim, dam_type))
      {
         case(IS_IMMUNE):
         immune = TRUE;
         dam = 0;
         break;
         case(IS_RESISTANT):
         dam -= dam/3;
         break;
         case(IS_VULNERABLE):
         dam += dam/3;
         break;
      }
   }

   if (dt < TYPE_HIT && skill_table[dt].spell_fun != NULL)
   {
      switch(check_immune(victim,DAM_SPELLS))
      {
         case(IS_IMMUNE):
         immune = TRUE;
         dam = 0;
         break;
         case(IS_RESISTANT):
         dam -= dam/3;
         break;
         case(IS_VULNERABLE):
         dam += dam/3;
         break;
      }
   }

   /* iron vulnerability - runge. covers 'oldstyle' iron weapons as well */
   /* basing the vuln off of the material field excludes alot of weapons */
   /* so use the name when adding new material vulns */

   if( wield )
   {
      bool is_iron;
      bool wood;
      bool is_silver;
      bool metal;

      if (!str_cmp(wield->material,"iron"))
      is_iron = TRUE;
      else
      is_iron = FALSE;
      if (is_metal(wield))
      metal = TRUE;
      else
      metal = FALSE;
      if (is_wood(wield))
      wood = TRUE;
      else
      wood = FALSE;
      if (!str_cmp(wield->material,"silver"))
      is_silver = TRUE;
      else
      is_silver = FALSE;
      if (metal)
      switch(check_immune(victim,DAM_METAL))
      {
         case(IS_IMMUNE):
         immune = TRUE;
         dam = 0;
         break;
         case(IS_RESISTANT):
         dam -= dam/3;
         break;
         case(IS_VULNERABLE):
         dam += dam/3;
         break;
      }
      if (is_iron)
      switch(check_immune(victim,DAM_IRON))
      {
         case(IS_IMMUNE):
         immune = TRUE;
         dam = 0;
         break;
         case(IS_RESISTANT):
         dam -= dam/3;
         break;
         case(IS_VULNERABLE):
         dam += dam/3;
         break;
      }
      if (wood)
      switch(check_immune(victim,DAM_WOOD))
      {
         case(IS_IMMUNE):
         immune = TRUE;
         dam = 0;
         break;
         case(IS_RESISTANT):
         dam -= dam/3;
         break;
         case(IS_VULNERABLE):
         dam += dam/3;
         break;
      }
      if (is_silver)
      switch(check_immune(victim,DAM_SILVER))
      {
         case(IS_IMMUNE):
         immune = TRUE;
         dam = 0;
         break;
         case(IS_RESISTANT):
         dam -= dam/3;
         break;
         case(IS_VULNERABLE):
         dam += dam/3;
         break;
      }


   }

   /* Vrrin's brand, level 2 gives 15% increase in damage (hidden) */
   if
   (
      is_affected(ch, gsn_will_power) &&
      dt != gsn_mob_pain
   )
   {
      dam += dam * 15 / 100;
   }

   /*
   * Max damage
   */
   if
   (
      ch != victim &&
      dam > 1500
   )
   {
      dam = 1500;
   }

   if
   (
      dt != gsn_telekinesis &&
      dt != gsn_wind_shear &&
      dt != gsn_mob_pain &&
      (is_affected(victim, gsn_aura_defiance)) &&
      ch != victim &&
      number_percent() < get_skill(victim, gsn_aura_defiance) / 7
   )
   {
      if (number_range(1, 3) == 1)
      {
         send_to_char("You defiantly absorb the attack.\n\r", victim);
         act
         (
            "$E defiantly absorbs your attack.",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         victim->hit = victim->hit + dam / 2;
         if (victim->hit > victim->max_hit)
         {
            victim->hit = victim->max_hit;
         }
         return FALSE;
      }
      else
      {
         send_to_char("You defiantly evade the attack.\n\r", victim);
         act
         (
            "$E defiantly evades your attack.",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         return FALSE;
      }
   }

   if
   (
      dam == 0 &&
      (check_immune(victim, DAM_OTHER) != IS_IMMUNE) &&
      (
         dt == gsn_bash ||
         dt == gsn_dirt
      )
   )
   {
      dam = 1;
   }
   if (is_affected(victim, gsn_intangibility))
   {
      dam = 0;
      immune = FALSE;
   }
   if (show > 0)
   {
      dam_message(ch, victim, dam, dt, immune);
   }
   if (show < 0)
   {
      dam_message2(show, victim, dam, dt, immune);
   }

   if (dam == 0)
   return FALSE;

   /*
   * Hurt the victim.
   * Inform the victim of his new state.
   * Mental Link now does the damage the player receives, not what was intended.
   */
   orig_dam = dam;
   victim->hit -= dam;
   if (is_affected(victim,gsn_peace)) affect_strip(victim,gsn_peace);
   if (dam_type == DAM_FIRE || dam_type == DAM_ACID)
   victim->noregen_dam += dam;
   if (victim->noregen_dam > victim->max_hit)
   victim->noregen_dam = victim->max_hit;


   check_rage(ch,victim);
   /* Dielantha's 33% hp trigger */

   brand = get_eq_char(victim, WEAR_BRAND);
   if ((brand != NULL)
   && (brand->pIndexData->vnum == 28211)
   && (!is_affected(victim, gsn_sdragon_valor))
   && (victim->hit <= (victim->max_hit / 3 ))
   && (victim->position == POS_FIGHTING))
   {
      af.where = TO_AFFECTS;
      af.type = gsn_sdragon_valor;
      af.duration = 3;
      af.location = APPLY_HITROLL;
      af.bitvector = 0;
      af.modifier = (victim->level)/5;
      af.level=victim->level;
      affect_to_char(victim, &af);
      af.location = APPLY_DAMROLL;
      affect_to_char(victim, &af);
      act("$n's silver dragon brand flares brightly!",victim,0,0,TO_ROOM);
      act("Your silver dragon brand flares brightly, and courage flows through you!",victim,0,0,TO_CHAR);
   }

   if ( !IS_NPC(victim)
   &&   victim->level >= LEVEL_IMMORTAL
   &&   victim->hit < 1 )
   victim->hit = 1;
   update_pos( victim );

   switch( victim->position )
   {
      case POS_MORTAL:
      act( "$n is mortally wounded, and will die soon, if not aided.",
      victim, NULL, NULL, TO_ROOM );
      send_to_char(
      "You are mortally wounded, and will die soon, if not aided.\n\r",
      victim );
      break;

      case POS_INCAP:
      act( "$n is incapacitated and will slowly die, if not aided.",
      victim, NULL, NULL, TO_ROOM );
      send_to_char(
      "You are incapacitated and will slowly die, if not aided.\n\r",
      victim );
      break;

      case POS_STUNNED:
      act( "$n is stunned, but will probably recover.",
      victim, NULL, NULL, TO_ROOM );
      send_to_char("You are stunned, but will probably recover.\n\r",
      victim );
      break;

      case POS_DEAD:
      act( "$n is DEAD!!", victim, 0, 0, TO_ROOM );
      send_to_char( "You have been KILLED!!\n\r\n\r", victim );
      break;

      default:
      if ( dam > victim->max_hit / 4 )
      send_to_char( "That really did HURT!\n\r", victim );
      if ( victim->hit < victim->max_hit / 4 )
      send_to_char( "You sure are BLEEDING!\n\r", victim );
      break;
   }

   /*
   * Sleep spells and extremely wounded folks.
   */
   if ( !IS_AWAKE(victim) )
   stop_fighting( victim, FALSE );

   /*
   * Payoff for killing things.
   */
   if (victim->position == POS_DEAD)
   {
      bool npc = IS_NPC(victim);
      char buf[MAX_INPUT_LENGTH];
      id = victim->id;

      if
      (
         dt == gsn_taunt &&
         victim->fighting != NULL
      )
      {
         raw_kill(victim->fighting, victim);
      }
      else
      {
         raw_kill(ch, victim);
      }
      sprintf
      (
         corpse_name,
         "%s %ld",
         (
            npc ?
            "corpse" :
            "pccorpse corpse"
         ),
         id
      );
      if
      (
         !IS_NPC(ch) &&
         (
            corpse = get_obj_list(ch, corpse_name, ch->in_room->contents)
         ) != NULL &&
         corpse->item_type == ITEM_CORPSE_NPC &&
         can_see_obj(ch, corpse)
      )
      {
         if
         (
            corpse->contains &&
            IS_AWAKE(ch)
         ) /* not empty */
         {
            if (IS_SET(ch->act, PLR_AUTOLOOT))
            {
               sprintf(buf, "all \"%s\"", corpse_name);
               do_get(ch, buf);
            }
            else if
            (
               IS_SET(ch->act, PLR_AUTOGOLD) &&
               get_obj_list(ch, "gcash", corpse->contains)
            )
            {
               sprintf(buf, "all.gcash \"%s\"", corpse_name);
               do_get(ch, buf);
            }
         }
         if
         (
            IS_SET(ch->act, PLR_AUTOSAC) &&
            IS_AWAKE(ch)
         )
         {
            if (IS_SET(ch->act, PLR_AUTOLOOT) && corpse->contains)
            {
               /* No more flags hitting them */
               return FALSE;  /* leave if corpse has treasure */
            }
            else
            {
               sprintf(buf, "\"%s\"", corpse_name);
               do_sacrifice(ch, buf);
            }
         }
      }
      return FALSE;  /* No more flags hitting them */
   }

   if (victim == ch)
   {
      return !evaded;
   }

   /*
   * Take care of link dead people.
   */
   if
   (
      !IS_NPC(victim) &&
      victim->desc == NULL &&
      number_range( 0, victim->wait ) == 0
   )
   {
      do_recall(victim, "");
      return !evaded;
   }

   /*
   * Wimp out?
   */
   if( victim->wait < PULSE_VIOLENCE / 2 && victim->daze <= 1)
   {
      if( IS_NPC(victim) )
      {

         if( (IS_SET(victim->act, ACT_WIMPY)
         && number_bits( 2 ) == 0
         && victim->hit < victim->max_hit / 5)
         || (IS_AFFECTED(victim, AFF_CHARM)
         && victim->master
         && victim->master->in_room != victim->in_room) )
         do_flee( victim, "" );
      } else
      if( victim->level >= 30 )
      {
         if( victim->hit > 0
         && victim->hit <= victim->wimpy )
         do_flee( victim, "" );
      } else
      if( victim->hit > 0
      && victim->hit*100/victim->max_hit <= victim->wimpy )
      do_flee( victim, "" );
   }

   if (ch != NULL && victim != NULL)
   {
      if (is_affected(ch,gsn_mentallink) &&
      victim->race == grn_arborian)
      damage(victim,ch,orig_dam/5,gsn_mentallink,DAM_MENTAL,TRUE);
   }
   tail_chain( );
   return !evaded;
}

void check_rage(CHAR_DATA *ch, CHAR_DATA *victim)
{
   int chance = 0;
   AFFECT_DATA af;

   if (IS_NPC(victim))
   return;
   if (victim->pcdata->learned[gsn_rage] < 1 ||
   victim->pcdata->learnlvl[gsn_rage] > victim->level)
   return;

   if (is_affected(victim,gsn_rage))
   return;
   chance = chance + get_skill(victim,gsn_rage)/5;
   chance = chance + (victim->max_hit - victim->hit)/15;
   chance = chance - 30;
   if (number_percent() < chance){
      check_improve(victim,gsn_rage,1,FALSE);
      return;
   }
   check_improve(victim,gsn_rage,1,TRUE);
   act("You are filled with rage!",victim,NULL,ch,TO_CHAR);
   /*    act("$N is filled with rage!",victim,NULL,ch,TO_ROOM); */
   act("$n is filled with rage!",victim,NULL,ch,TO_ROOM);

   af.where = TO_AFFECTS;
   af.type = gsn_rage;
   af.modifier = 5;
   af.location = APPLY_DAMROLL;
   af.duration = 2;
   af.bitvector = AFF_HASTE;
   af.level = victim->drain_level + victim->level;
   affect_to_char(victim,&af);

   return;
}

void check_battleaxe_brand( CHAR_DATA *ch, CHAR_DATA *victim )
{
   AFFECT_DATA af;
   sh_int dam;

   if( ch == NULL
   || victim == NULL
   || ch == victim
   || ch->fighting != victim
   || ch->in_room != victim->in_room )
   return;

   /* power number 1 - randomly crush Forsaken */
   if( number_percent() < 10
   && IS_SET(victim->wiznet, PLR_FORSAKEN) )
   {
      act("Darkwood's wrath CRUSHES you!",ch,0,victim,TO_VICT);
      act("Darkwood's wrath LASHES OUT through you!",ch,0,victim,TO_CHAR);
      act("$n's brand of the Living Battleaxe flares brightly!",ch,0,victim,TO_NOTVICT);

      if(      (ch->drain_level + ch->level) < 20 )
      dam = dice(12,3);
      else if( (ch->drain_level + ch->level) < 25 )
      dam = dice(12,5);
      else if( (ch->drain_level + ch->level) < 30 )
      dam = dice(12,7);
      else if( (ch->drain_level + ch->level) < 35 )
      dam = dice(15,7);
      else if( (ch->drain_level + ch->level) < 40 )
      dam = dice(15,9);
      else if( (ch->drain_level + ch->level) < 52 )
      dam = dice(15,11);
      else
      dam = dice(15,11);

      dam += str_app[get_curr_stat(ch,STAT_STR)].todam;
      DAZE_STATE(victim,PULSE_VIOLENCE * 3 / 2);
      damage(ch,victim,dam,gsn_crush,DAM_BASH,TRUE);
      victim->position = POS_RESTING;
   }

   /* power number 2 - randomly hastes */
   if( number_percent() < 5
   && !IS_AFFECTED(ch, AFF_HASTE) )
   {
      if (IS_SET(ch->comm, COMM_ANSI))
      {
         send_to_char("\x01B[1;32m", ch);
      }
      send_to_char("The thrill of battle BOILS in your blood and you will a SURGE of power!",ch);
      if (IS_SET(ch->comm, COMM_ANSI))
      {
         send_to_char("\x01B[0;37m", ch);
      }
      send_to_char("\n\r", ch);
      act("$n's brand of the Living Battleaxe begins to glow!",ch,0,victim,TO_ROOM);

      af.where     = TO_AFFECTS;
      af.type      = gsn_battleaxe_haste;
      af.level     = (ch->level + ch->drain_level);
      af.duration  = 5;
      af.bitvector = AFF_HASTE;
      af.location  = APPLY_NONE;
      af.modifier  = 0;
      affect_to_char( ch, &af );
   }
   /* power number 3 - randomly boosts save vs. spells */
   if( number_percent() < 7
   && !is_affected(ch, gsn_battleaxe_defense) )
   {
      if (IS_SET(ch->comm, COMM_ANSI))
      {
         send_to_char("\x01B[1;32m", ch);
      }
      send_to_char("The strength of the Living Battleaxe bolsters your defenses!",ch);
      if (IS_SET(ch->comm, COMM_ANSI))
      {
         send_to_char("\x01B[0;37m", ch);
      }
      send_to_char("\n\r", ch);

      af.where = TO_AFFECTS;
      af.type = gsn_battleaxe_defense;
      af.modifier = -1 * (ch->level + ch->drain_level) / 5;
      af.level = ch->drain_level + ch->level;
      af.duration = (ch->drain_level + ch->level) / 5;
      af.bitvector = 0;

      af.location = APPLY_SAVING_SPELL;
      affect_to_char(ch,&af);
      af.location = APPLY_SAVING_TRANSPORT;
      affect_to_char(ch,&af);
      af.location = APPLY_SAVING_MALEDICT;
      affect_to_char(ch,&af);
      af.location = APPLY_SAVING_BREATH;
      affect_to_char(ch,&af);
      af.location = APPLY_SAVES;
      affect_to_char(ch,&af);
   }
}

/* "Spark" damage for Hector's brand - Wicket */
void check_hector_brand( CHAR_DATA *ch, CHAR_DATA *victim )
{
   int dam;

   if(!is_affected(ch,gsn_hector_brand_spark))
   return;

   if(number_percent() < 3)
   {
      act("$n's brand releases an incredible burst of mercuric energy!", ch, 0, 0, TO_ROOM);
      act("Your brand releases an incredible burst of mercuric energy!", ch, 0, 0, TO_CHAR);
      dam = ch->level*2;
   }
   else if(number_percent() < 5)
   {
      act("$n's brand sizzles and hisses as it discharges electrical energy!", ch, 0, 0, TO_ROOM);
      act("Your brand sizzles and hisses as it discharges electrical energy!", ch, 0, 0, TO_CHAR);
      dam = ch->level;
   }
   else
   return;

   /* Compensate for sanctuary */
   if(IS_AFFECTED(victim, AFF_SANCTUARY))
   dam *= 2;

   damage(ch, victim, dam, gsn_hector_brand_spark, DAM_LIGHTNING, TRUE);
}

/* Misdirection power for Utara's brand - Wicket
void check_gremlin_misdirection( CHAR_DATA *ch, CHAR_DATA *victim )
{

*/

void do_dim_mak(CHAR_DATA *ch, char * argument)
{
   AFFECT_DATA af;
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   int chance, dam;
   char buf[MAX_STRING_LENGTH];


   one_argument(argument,arg);

   if ( (chance = get_skill(ch,gsn_dimmak)) <= 0
   ||   (!IS_NPC(ch)
   &&  !has_skill(ch,gsn_dimmak)))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (ch->pcdata->learned[gsn_corrupt("subrank", &gsn_subrank)] < 9)
   {
      send_to_char("You are too inexperienced to use this technique.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }

   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (is_safe(ch,victim, 0))
   return;

   if (victim == ch)
   {
      send_to_char("There are easier ways to kill yourself.\n\r",ch);
      return;
   }

   if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
   {
      act("$N is your beloved master.",ch,NULL,victim,TO_CHAR);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /* modifiers */

   /* dex */
   chance += get_curr_stat(ch,STAT_DEX);
   chance -= get_curr_stat(victim,STAT_DEX);

   /* speed */
   if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
   chance += 10;
   if (IS_SET(victim->off_flags,OFF_FAST) ||
   IS_AFFECTED(victim,AFF_HASTE))
   chance -= 20;

   /* level */
   chance += (ch->drain_level + ch->level
   - victim->level - victim->drain_level)*2;

   if (number_percent() >= chance)
   {
      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (ch->fighting == NULL || victim->fighting == NULL))
      {
         sprintf(buf,"Help! %s just tried to use a nerve attack on me!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] used dim-mak on [%s] at %d", ch->name,
         victim->name,victim->in_room->vnum);
         log_string(log_buf);
      }

      damage(ch,victim,0,gsn_dimmak,DAM_BASH,TRUE);
      WAIT_STATE(ch,skill_table[gsn_dimmak].beats*2/3);
      check_improve(ch,gsn_dimmak,FALSE,1);
      return;
   }

   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (ch->fighting == NULL || victim->fighting == NULL))
   {
      sprintf(buf,"Help! %s just used a nerve attack on me!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] used dim-mak on [%s] at %d", ch->name,
      victim->name,victim->in_room->vnum);
      log_string(log_buf);
   }
   check_improve(ch,gsn_dimmak,TRUE,1);
   WAIT_STATE(ch,skill_table[gsn_dimmak].beats);

   af.where     = TO_AFFECTS;
   af.type      = gsn_dimmak;
   af.level     = ch->level;
   af.duration  = ch->level/10;
   af.bitvector = 0;
   dam = number_range(ch->level,ch->level+45);

   act("$n strikes you hard in neck!",ch,NULL,victim,TO_VICT);
   act("You strike $N hard in the neck!",ch,NULL,victim,TO_CHAR);
   act("$n strikes $N hard in the neck!",ch,NULL,victim,TO_NOTVICT);

   if (number_percent() < 30){
      if (number_percent() > 20){
         send_to_char("You feel a sharp pain!\n\r",victim);
         dam = dam * 2;
      }
      else
      {
         send_to_char("You feel a VERY sharp pain!\n\r",victim);
         dam = dam * 4;
         damage(ch,victim,dam,gsn_dimmak,DAM_PIERCE,TRUE);
         return;
      }
   }
   damage(ch,victim,dam,gsn_dimmak,DAM_PIERCE,TRUE);
   if (number_percent() < 25){
      if (number_range(1,2) == 1)
      {
         OBJ_DATA *obj, *secondary;
         if ( ( obj = get_eq_char( victim, WEAR_WIELD ) ) != NULL
         && !IS_OBJ_STAT(obj,ITEM_NOREMOVE))
         {
            obj_from_char( obj );
            send_to_char("Their grasp grows weak, and they drop their weapon!\n\r",ch);
            act("Your weapon falls from your grasp!",ch,NULL,victim,TO_VICT);
            act("$N's weapon falls from $S grasp!",ch,NULL,victim,TO_NOTVICT);
            if ( IS_OBJ_STAT(obj,ITEM_NODROP) || IS_OBJ_STAT(obj,ITEM_INVENTORY) )
            obj_to_char( obj, victim );
            else
            {
               obj_to_room( obj, victim->in_room );
               if (IS_NPC(victim) && victim->wait == 0 && can_see_obj(victim,obj))
               get_obj(victim,obj,NULL,0);
            }
            reslot_weapon(victim);
            if ((secondary = get_eq_char(victim,WEAR_DUAL_WIELD)) != NULL)
            {
               unequip_char(victim,secondary);
               equip_char(victim,secondary,WEAR_WIELD);
            }
         }
      }
   }

   if (is_affected(victim,gsn_dimmak))
   return;
   if (number_percent() < 25){
      send_to_char("Your victim looks weakened!\n\r",ch);
      if (number_percent() > 25){
         send_to_char("You feel weaker!\n\r",victim);
         af.location = APPLY_STR;
         af.modifier = -number_range(4,6);
         affect_to_char(victim,&af);
      }
      else
      {
         send_to_char("You feel MUCH weaker!\n\r",victim);
         af.location = APPLY_STR;
         af.modifier = -number_range(6,10);
         affect_to_char(victim,&af);
         return;
      }
   }
   if (number_percent() < 25){
      send_to_char("Your victim looks disoriented!\n\r",ch);
      if (number_percent() > 25){
         send_to_char("You feel disoriented!\n\r",victim);
         af.location = APPLY_DEX;
         af.modifier = -number_range(4,6);
         affect_to_char(victim,&af);
      }
      else
      {
         send_to_char("You feel VERY disoriented!\n\r",victim);
         af.location = APPLY_DEX;
         af.modifier = -number_range(6,10);
         affect_to_char(victim,&af);
         return;
      }
   }
   if (number_percent() < 25){
      send_to_char("Your victim looks confused!\n\r",ch);
      if (number_percent() > 25){
         send_to_char("You feel confused!\n\r",victim);
         af.location = APPLY_INT;
         af.modifier = -number_range(4,6);
         affect_to_char(victim,&af);
      }
      else
      {
         send_to_char("You feel VERY confused!\n\r",victim);
         af.location = APPLY_INT;
         af.modifier = -number_range(6,10);
         affect_to_char(victim,&af);
         return;
      }
   }



   return;
}


int award_standing(CHAR_DATA *victim)
{
   int days;
   int gain;
   /* shouldnt come up, but its safer to throw it out */
   if (IS_NPC(victim))
   return 0;
   if (!str_cmp(victim->pcdata->marker,"The Assassin") &&
   victim->pcdata->mark_price < 1000)
   return 1;
   if (victim->pcdata->mark_price < 1000)
   return 0;
   gain = 1;
   if (victim->pcdata->mark_price >= 5000) gain++;
   if (victim->pcdata->mark_price >= 10000) gain++;
   if (victim->pcdata->mark_price >= 50000) gain++;

   days  = (int) ((current_time-victim->pcdata->mark_time)/(3600*24));
   if (days > 15) gain++;
   if (days > 30) gain++;
   if (days > 60) gain++;
   if (days > 120) gain++;
   if (victim->level < 25) gain--;
   if (victim->level < 35) gain--;
   if (victim->level > 42) gain++;
   if (victim->level == 51) gain++;
   if (!str_cmp(victim->pcdata->marker,"Nebhotep") ||
   !str_cmp(victim->pcdata->marker,"Xurinos")) gain++;
   if (gain < 1) gain = 1;
   return gain;
}

void do_shieldbash(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   int chance;
   int dam;
   int lag;
   char buf[MAX_STRING_LENGTH];
   OBJ_DATA* obj;
   OBJ_DATA* shield;
   bool enf_shield;

   one_argument(argument,arg);

   if
   (
      (chance = get_skill(ch, gsn_shieldbash)) <= 0 ||
      !has_skill(ch,gsn_shieldbash)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }


   shield = get_eq_char(ch, WEAR_SHIELD);
   if (shield == NULL)
   {
      send_to_char("You must wear a shield to bash with one.\n\r", ch);
      return;
   }
   if (shield->pIndexData->vnum == OBJ_VNUM_PROTECTORATE)
   {
      enf_shield = TRUE;
   }
   else
   {
      enf_shield = FALSE;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r", ch);
         return;
      }
   }

   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r", ch);
      return;
   }

   if (check_peace(ch))
   {
      return;
   }

   if (victim->position < POS_FIGHTING)
   {
      act
      (
         "You'll have to let $M get back up first.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if (victim == ch)
   {
      send_to_char("You try to bash your brains out, but fail.\n\r", ch);
      return;
   }

   if (is_safe(ch, victim, 0))
   {
      return;
   }
   if
   (
      victim->position < POS_FIGHTING ||
      victim->daze > 0
   )
   {
      act
      (
         "You'll have to let $M get back up first.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   if
   (
      IS_AFFECTED(ch, AFF_CHARM) &&
      ch->master == victim
   )
   {
      act
      (
         "But $N is your friend!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }
   /*
   if (is_affected(victim,gsn_phasing) &&
   (number_percent() < (75+((victim->level-ch->level)*2))))
   {
   act("You phase out and $N's shield bash doesn't affect you.",victim,0,ch,TO_CHAR);
   act("$n phases out and $N's shield bash doesn't seem to affect him.",victim,0,ch,TO_NOTVICT);
   act("$n phases out and your shield bash doesn't seem to affect him.",victim,0,ch,TO_VICT);
   WAIT_STATE(ch,20);
   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (victim->fighting == NULL || ch->fighting == NULL))
   {
   sprintf(buf,"Help! %s is trying to bash me a shield!",PERS(ch,victim));
   do_myell(victim,buf);
   sprintf(log_buf, "[%s] shield bashed [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
   log_string(log_buf);
   }
   return;
   }
   */
   if (check_shadowstrike(ch, TRUE, TRUE))
   {
      return;
   }
   obj = get_eq_char(victim,WEAR_FINGER_L);
   if
   (
      obj != NULL &&
      obj->pIndexData->vnum == 16029
   )
   {
      act
      (
         "$N's shield bash seems to slide around you.",
         victim,
         0,
         ch,
         TO_CHAR
      );
      act
      (
         "$N's shield bash seems to slide around $n.",
         victim,
         0,
         ch,
         TO_NOTVICT
      );
      act
      (
         "Your shield bash seems to slide around $n.",
         victim,
         0,
         ch,
         TO_VICT
      );
      WAIT_STATE(ch, 20);
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            victim->fighting == NULL ||
            ch->fighting == NULL
         )
      )
      {
         sprintf
         (
            log_buf,
            "[%s] shield bashed [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
         sprintf
         (
            buf,
            "Help! %s is trying to bash me with a shield!",
            PERS(ch, victim)
         );
         do_myell(victim, buf);
      }
      damage
      (
         ch,
         victim,
         0,
         gsn_shieldbash,
         DAM_BASH,
         TRUE
      );
      return;
   }
   obj = get_eq_char(victim, WEAR_FINGER_R);
   if
   (
      obj != NULL &&
      obj->pIndexData->vnum == 16029
   )
   {
      act
      (
         "$N's shield bash seems to slide around you.",
         victim,
         0,
         ch,
         TO_CHAR
      );
      act
      (
         "$N's shield bash seems to slide around $n.",
         victim,
         0,
         ch,
         TO_NOTVICT
      );
      act
      (
         "Your shield bash seems to slide around $n.",
         victim,
         0,
         ch,
         TO_VICT
      );
      WAIT_STATE(ch, 20);
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            victim->fighting == NULL ||
            ch->fighting == NULL
         )
      )
      {
         sprintf
         (
            log_buf,
            "[%s] shield bashed [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
         sprintf
         (
            buf,
            "Help! %s is trying to bash me with a shield!",
            PERS(ch, victim)
         );
         do_myell(victim,buf);
      }
      damage
      (
         ch,
         victim,
         0,
         gsn_shieldbash,
         DAM_BASH,
         TRUE
      );
      return;
   }


   if
   (
      is_affected(victim, gsn_protective_shield) &&
      (number_percent() < (70+((victim->level-ch->level)*2)))
   )
   {
      act
      (
         "$N's shield bash seems to slide around you.",
         victim,
         0,
         ch,
         TO_CHAR
      );
      act
      (
         "$N's shield bash seems to slide around $n.",
         victim,
         0,
         ch,
         TO_NOTVICT
      );
      act
      (
         "Your shield bash seems to slide around $n.",
         victim,
         0,
         ch,
         TO_VICT
      );
      WAIT_STATE(ch, 20);
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            victim->fighting == NULL ||
            ch->fighting == NULL
         )
      )
      {
         sprintf
         (
            log_buf,
            "[%s] shield bashed [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
         sprintf
         (
            buf,
            "Help! %s is trying to bash me with a shield!",
            PERS(ch, victim)
         );
         do_myell(victim, buf);
      }
      damage
      (
         ch,
         victim,
         0,
         gsn_shieldbash,
         DAM_BASH,
         TRUE
      );
      return;
   }

   /* modifiers */
   dam = shield->level + number_range(1, ch->level);

   lag = 10;
   if (!is_metal(shield))
   {
      lag -= 4;
      dam /= 2;
   }
   lag += shield->level/15;
   lag += shield->weight/150;
   if (shield->pIndexData->limtotal < 30)
   {
      lag += 4;
   }
   if (shield->pIndexData->limtotal < 4)
   {
      lag += 4;
   }

   if (enf_shield)
   {
      lag += 4;
   }
   if (lag > 20) lag = 20;
   {
      chance -= GET_AC(victim, AC_BASH) /10;
   }
   chance = chance + shield->level/5;

   /* speed */
   if
   (
      IS_SET(ch->off_flags, OFF_FAST) ||
      IS_AFFECTED(ch, AFF_HASTE)
   )
   {
      chance += 10;
   }
   if
   (
      IS_SET(victim->off_flags, OFF_FAST) ||
      IS_AFFECTED(victim, AFF_HASTE)
   )
   {
      chance -= 30;
   }

   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level);

   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         victim->fighting == NULL ||
         ch->fighting == NULL
      )
   )
   {
      sprintf
      (
         log_buf,
         "[%s] shield bashed [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
      sprintf
      (
         buf,
         "Help! %s is bashing me with a shield!",
         PERS(ch, victim)
      );
      do_myell(victim, buf);
   }

   if (chance < 5)
   {
      chance = 5;
   }
   if (chance > 93)
   {
      chance = 93;
   }
   /* now the attack */
   if (number_percent() < chance )
   {
      if (oblivion_blink(ch, victim))
      {
         return;
      }

      switch(number_range(1,4))
      {
         case(1):
         {
            act
            (
               "$n sends you sprawling with a powerful shield bash!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You slam your shield into $N and send $M flying!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n sends $N sprawling with a powerful shield bash.",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(2):
         {
            act
            (
               "$n charges you with $s shield braced and sends you sprawling!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You charge $N with your shield braced and send $M sprawling!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n charges $N with $s shield braced and sends $M sprawling!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(3):
         {
            act
            (
               "$n lowers $s shield and plows into you, sending you flying!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You lower your shield and plow into $N, sending $M flying!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n lowers $s shield and plows into $N, sending $M flying!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
         case(4):
         {
            act
            (
               "$n smashes you with $s shield and sends you flying!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "You smash $N with your shield and send $M flying!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            act
            (
               "$n smashes $N with $s shield and sends $M flying!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            break;
         }
      }
      check_improve
      (
         ch,
         gsn_shieldbash,
         TRUE,
         1
      );
      DAZE_STATE(victim, lag);
      damage
      (
         ch,
         victim,
         dam,
         gsn_shieldbash,
         DAM_BASH,
         TRUE
      );

      WAIT_STATE(ch, 24);
      victim->position = POS_RESTING;
   }
   else
   {
      act
      (
         "You attempt to slam your shield into $N but miss.",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n attempts to shield bash you but misses.",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n attempts to shield bash $N but misses.",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      damage
      (
         ch,
         victim,
         0,
         gsn_shieldbash,
         DAM_BASH,
         FALSE
      );
      check_improve
      (
         ch,
         gsn_shieldbash,
         FALSE,
         1
      );
      WAIT_STATE(ch, skill_table[gsn_shieldbash].beats * 3/2);
   }
   check_killer(ch, victim);
}

void do_mentallink(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA * victim;
   AFFECT_DATA af;
   int chance;

   if (get_skill(ch,gsn_mentallink) <= 0 ||
   !has_skill(ch,gsn_mentallink))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   victim = ch->fighting;
   if (argument[0] != '\0')
   victim = get_char_room(ch,argument);
   if (victim == NULL)
   {
      send_to_char("Form a mental link to whom?\n\r",ch);
      return;
   }
   chance = 50;
   chance += get_curr_stat(ch,STAT_INT)*2;
   chance -= get_curr_stat(victim,STAT_INT)*2;
   chance += ch->level;
   chance -= victim->level;
   WAIT_STATE(ch,24);
   if (number_percent() > chance)
   {
      send_to_char("You failed to establish the link.\n\r",ch);
      return;
   }
   if (is_mental(victim))
   {
      send_to_char("You failed to establish the link.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }
   af.where        = TO_AFFECTS;
   af.type         = gsn_mentallink;
   af.level        = ch->level + ch->drain_level;
   af.duration     = 12;
   af.location     = 0;
   af.modifier     = 0;
   af.bitvector    = 0;


   affect_to_char(victim,&af);
   send_to_char("You succeed in forming the link.\n\r",ch);
   send_to_char("You feel an empathetic presence in your mind.\n\r",victim);
   return;
}

void do_taunt(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *victim;
   int chance, dam;
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   long id;

   dam = 0;
   one_argument(argument,arg);
   if ((chance = get_skill(ch,gsn_taunt) ) <= 0
   || !has_skill(ch,gsn_taunt) )
   {
      send_to_char("You do not know how to properly taunt.\n\r",ch);
      return;
   }
   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }
   else if ( (victim = get_char_room(ch,arg)) == NULL )
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't taunt at yourself!\n\r",ch);
      return;
   }
   if (!IS_NPC(victim))
   if (victim->pcdata->condition[COND_STARVING] <= 0)
   {
      send_to_char("They are not hungry enough to be affected by simple taunts.\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (is_safe(ch,victim, 0) )
   return;

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   act("$n cruelly taunts $N with food!",ch,0,victim,TO_NOTVICT);
   act("You cruelly taunt $N with food!",ch,0,victim,TO_CHAR);
   act("$n cruelly taunts you with food!",ch,0,victim,TO_VICT);

   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (victim->fighting == NULL || ch->fighting == NULL))
   {
      sprintf(buf,"Help! %s is torturing me with food!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] taunted [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }

   if (!IS_NPC(victim))
   dam = victim->pcdata->condition[COND_STARVING] * 20;
   else
   dam = ch->level * 6;

   /* sanity check - probally not needed but lets be safe*/
   if (dam > 400) dam = 400;

   if (number_percent() < chance)
   {
      check_improve(ch,gsn_taunt,TRUE,1);
      WAIT_STATE(ch, skill_table[gsn_taunt].beats);
   } else dam = 0;

   id = victim->id;
   if (dam > 0)
   {
      /*
      increase hunger
      if (!IS_NPC(victim))
      {
      gain_condition
      (
      victim,
      COND_STARVING,
      -1
      );
      }
      */
      damage(ch, victim, dam, gsn_taunt, DAM_OTHER, TAUNT_DAM_TYPE);
   }
   else
   {
      send_to_char("You fail to properly issue the taunt.\n\r",ch);
      check_improve(ch,gsn_taunt,FALSE,1);
      WAIT_STATE(ch,skill_table[gsn_taunt].beats);
   }
   if
   (
      victim->valid &&
      victim->id == id &&
      (
         IS_NPC(victim) ||
         victim->ghost == 0
      )
   )
   {
      if (victim->fighting == NULL)
      {
         set_fighting(victim, ch);
      }
      else if (ch->fighting == NULL)
      {
         set_fighting(ch, victim);
      }
   }
   return;
}

/*      Ring of Physical and Mental Focus 2.5 times damage      */
/*      If it fails to 2.5 times damage, it increases it by 1hp */
/*      Physical works only on skills   1/100 hits      */
/*      Mental works only on spells     1/25 spells     */
/*      BEGIN focus rings       */
/*      Actual Checking function        */
int check_ring_focus(CHAR_DATA *ch,CHAR_DATA *victim,int dam,int dt)
{
   OBJ_DATA *FocusRing;

   if (ch != victim)
   {
      if
      (
         dt > 0 &&
         dt < MAX_SKILL &&
         skill_table[dt].spell_fun != spell_null /* If its a spell */
      )
      {
         if( ((FocusRing = get_eq_char(ch,WEAR_FINGER_R)) != NULL
         && (FocusRing->pIndexData->vnum == OBJ_VNUM_MENTAL_FOCUS))
         || ((FocusRing = get_eq_char(ch,WEAR_FINGER_L)) != NULL
         && (FocusRing->pIndexData->vnum == OBJ_VNUM_MENTAL_FOCUS)))
         {
            if (number_percent() <= 4)
            {
               /*begin chance if mental*/
               act("$p flares silver as you achieve true focus!", ch, FocusRing, victim, TO_CHAR );
               act("$n achieves complete focus and releases $s channeled energy!", ch, FocusRing, victim, TO_VICT );
               act("$p flares silver as $n achieves true focus!", ch, FocusRing, victim, TO_NOTVICT );
               return FOCUS_RING_FULL;
               /*end chance if mental*/
            }
            else
            return FOCUS_RING_LIMITED;
         }
         return FOCUS_RING_NONE;
      }
      else
      {
         if( ((FocusRing = get_eq_char(ch,WEAR_FINGER_R)) != NULL
         && (FocusRing->pIndexData->vnum == OBJ_VNUM_PHYSICAL_FOCUS))
         || ((FocusRing = get_eq_char(ch,WEAR_FINGER_L)) != NULL
         && (FocusRing->pIndexData->vnum == OBJ_VNUM_PHYSICAL_FOCUS)))
         {
            if (number_percent() <= 1)
            {
               /* begin chance if physical */
               act("You focus your concentration and land a devastating blow!", ch, FocusRing, victim, TO_CHAR );
               act("$n's $p glints in the light as you are pummeled by a devastating blow!", ch, FocusRing, victim, TO_VICT );
               act("$n focuses $s concentration and lands a devastating blow!", ch, FocusRing,victim, TO_NOTVICT );
               return FOCUS_RING_FULL;
            }       /*end chance if physical*/
            else
            return FOCUS_RING_LIMITED;
         }
         return FOCUS_RING_NONE;
      }
   }
   return FOCUS_RING_NONE;
}

bool check_two_hand_wield(CHAR_DATA *ch)
{
   OBJ_DATA *check;
   if (ch == NULL) return FALSE;
   if (get_skill(ch, gsn_two_hand_wield) < 1 ||
   !has_skill(ch,gsn_two_hand_wield))
   return FALSE;
   check = get_eq_char(ch,WEAR_WIELD);
   if (check == NULL) return FALSE;
   if (check->value[0] == WEAPON_DAGGER) return FALSE;
   check = get_eq_char(ch,WEAR_HOLD);
   if (check != NULL) return FALSE;
   check = get_eq_char(ch,WEAR_SHIELD);
   if (check != NULL) return FALSE;
   check = get_eq_char(ch,WEAR_DUAL_WIELD);
   if (check != NULL) return FALSE;
   return TRUE;
}

/* used for damage on a victim from a non-mob */
void dam_message2( int type, CHAR_DATA *victim,int dam,int dt,bool immune )
{
   char buf1[256], buf3[256];
   CHAR_DATA *gch;
   const char *vs;
   const char *vp;
   char type_name[40];
   char punct;
   bool color_on = TRUE;

   if (victim == NULL)
   return;

   switch(type)
   {
      case GLOBAL_QUAKE_DAM_TYPE:
      sprintf(type_name, "The worlds rumbling");
      break;
      case GLOBAL_METEOR_DAM_TYPE:
      sprintf(type_name, "The falling rocks");
      break;
      case ROOM_METEOR_DAM_TYPE:
      sprintf(type_name, "The flaming hot rocks");
      break;
      case GLOBAL_RIFT_DAM_TYPE:
      sprintf(type_name, "The fiery explosion");
      break;
      case TRAP_PUNJIE_DAM_TYPE:
      sprintf(type_name, "The punjie stick's");
      break;
      case RAGING_FIRE_DAM_TYPE:
      sprintf(type_name, "The burning forest");
      break;
      case METEOR_STORM_DAM_TYPE:
      sprintf(type_name, "A falling rock");
      break;
      case TORNADO_DROWN_DAM_TYPE:
      sprintf(type_name, "The waves");
      break;
      case TORNADO_LIT_DAM_TYPE:
      sprintf(type_name, "The bolt of lightning");
      break;
      case TORNADO_WIND_DAM_TYPE:
      sprintf(type_name, "The strong winds");
      break;
      case DEMON_WIMP_DAM_TYPE:
      sprintf(type_name, "The mezzoloth's fiery explosion");
      break;
      case MOB_DAM_TYPE:
      {
         sprintf(type_name, "The crowd's revolt");
         break;
      }
      case (DEHYDRATION_DAM_TYPE):
      case (STARVATION_DAM_TYPE):
      case (BLOODMIST_DAM_TYPE):
      case (BOILING_BLOOD_DAM_TYPE):
      case (TAUNT_DAM_TYPE):
      case (POISON_DAM_TYPE):
      case (PLAGUE_DAM_TYPE):
      case (SUFFOCATE_DAM_TYPE):
      case (TEMP_SHEER_DAM_TYPE):
      {
         dam_message(victim, victim, dam, dt, immune);
         return;
      }
      default: break;
   }
   if (is_affected(victim, gsn_intangibility))
   {
      color_on = FALSE;
      vs = "pass right through";
      vp = "passes right through";
   }
   else if ( dam ==   0 ) { vs = "miss";       vp = "misses";          }
   else if ( dam <=   4 ) { vs = "scratch";    vp = "scratches";       }
   else if ( dam <=   8 ) { vs = "graze";      vp = "grazes";          }
   else if ( dam <=  13 ) { vs = "hit";        vp = "hits";            }
   else if ( dam <=  18 ) { vs = "injure";     vp = "injures";         }
   else if ( dam <=  23 ) { vs = "wound";      vp = "wounds";          }
   else if ( dam <=  28 ) { vs = "maul";       vp = "mauls";           }
   else if ( dam <=  33 ) { vs = "decimate";   vp = "decimates";       }
   else if ( dam <=  38 ) { vs = "devastate";  vp = "devastates";      }
   else if ( dam <=  43 ) { vs = "maim";       vp = "maims";           }
   else if ( dam <=  55 ) { vs = "MUTILATE";   vp = "MUTILATES";       }
   else if ( dam <=  65 ) { vs = "DISEMBOWEL"; vp = "DISEMBOWELS";     }
   else if ( dam <=  75 ) { vs = "DISMEMBER";  vp = "DISMEMBERS";   }
   else if ( dam <=  85 ) { vs = "MASSACRE";   vp = "MASSACRES";       }
   else if ( dam <= 100 ) { vs = "MANGLE";     vp = "MANGLES";         }
   else if ( dam <= 130 ) { vs = "*** DEMOLISH ***";
   vp = "*** DEMOLISHES ***";                 }
   else if ( dam <= 160 ) { vs = "*** DEVASTATE ***";
   vp = "*** DEVASTATES ***";                 }
   else if ( dam <= 200)  { vs = "=== OBLITERATE ===";
   vp = "=== OBLITERATES ===";                }
   else if ( dam <= 280)  { vs = ">>> ANNIHILATE <<<";
   vp = ">>> ANNIHILATES <<<";                }
   else if ( dam <= 380)  { vs = "<<< ERADICATE >>>";
   vp = "<<< ERADICATES >>>";                 }
   else if ( dam <= 600)  { vs = "do UNSPEAKABLE things to";
   vp = "does UNSPEAKABLE things to";         }
   else                   { vs = "DO UNSPEAKABLE THINGS TO";
   vp = "DOES UNSPEAKABLE THINGS TO";         }

   punct   = (dam <= 33) ? '.' : '!';

   for (gch = victim->in_room->people; gch != NULL; gch = gch->next_in_room)
   {
      if (!IS_AWAKE(gch) && gch != victim) continue;
      if (gch != victim)
      {
         if
         (
            IS_SET(gch->comm,COMM_ANSI) &&
            color_on
         )
         sprintf( buf1, "%s \x01B[1;31m%s\x01B[0;37m %s%c\n\r",  type_name,
         vp, get_descr_form(victim,gch,FALSE),punct);
         else
         sprintf( buf1, "%s %s %s%c\n\r",  type_name, vp,
         get_descr_form(victim,gch,FALSE), punct);
         send_to_char(buf1,gch);
      }
   }
   if
   (
      IS_SET(victim->comm,COMM_ANSI) &&
      color_on
   )
   sprintf( buf3, "%s \x01B[1;31m%s\x01B[0;37m you%c\n\r", type_name,
   vp, punct );
   else
   sprintf( buf3, "%s %s you%c\n\r", type_name, vp, punct );
   send_to_char(buf3,victim);

   return;
}

void do_skullbash(CHAR_DATA *ch, char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   OBJ_DATA *weapon;
   int dam, chance;
   char buf[MAX_STRING_LENGTH];
   AFFECT_DATA af;

   one_argument(argument,arg);


   if (get_skill(ch,gsn_skull_bash)  <= 0
   || !has_skill(ch,gsn_skull_bash) )
   {
      send_to_char("You don't know how to bash someone's skull properly.\n\r", ch);
      return;
   }


   if (!check_two_hand_wield(ch) )
   {
      send_to_char("You must wielding your weapon with both hands.\n\r", ch);
      return;
   }

   weapon = get_eq_char(ch, WEAR_WIELD);
   if (weapon == NULL)
   {
      send_to_char("You must be wielding a weapon in both hands.\n\r",ch);
      return;
   }

   if( attack_table[weapon->value[3]].damage != DAM_BASH)
   {
      send_to_char("Your weapon is not appropriate for bashing.\n\r", ch);
      return;
   }

   if (weapon->weight <= 15)
   {
      send_to_char("You'll need something heavier than that.\n\r", ch);
      return;
   }

   if (arg[0] != '\0')
   victim = get_char_room(ch,arg);
   else
   victim =  ch->fighting;

   if (victim == NULL)
   {
      send_to_char("They aren't here.\n\r", ch);
      return;
   }

   if (ch == victim)
   {
      send_to_char("Do you want to make yourself even uglier?\n\r",ch);
      return;
   }

   if (check_peace(ch)) return;

   if (is_safe(ch,victim, 0)) return;

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if ( number_range(1,2) == 1)
   if (check_dodge(ch, victim, gsn_skull_bash) )
   {
      check_improve(ch,gsn_skull_bash,FALSE,1);
      WAIT_STATE(ch,24);
      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (victim->fighting == NULL || ch->fighting == NULL))
      {
         sprintf(buf,"Help! %s is swinging their weapon at my head!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] skull bashed [%s] at %d", ch->name, victim->name,ch->in_room->vnum);
         log_string(log_buf);
      }
      damage(ch,victim,0,gsn_skull_bash, DAM_BASH, TRUE);
      return;
   }

   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (victim->fighting == NULL || ch->fighting == NULL))
   {
      sprintf(buf,"Help! %s is swinging their weapon into my head!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] skull bashed [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }


   act("You bring your weapon down on $N's head with spectacular force!", ch, NULL, victim, TO_CHAR);
   act("$n painfully smashes your head with $s weapon!", ch, NULL ,victim, TO_VICT);
   act("$n takes $s weapon and smashes $N's head with a loud crack!", ch, NULL, victim, TO_NOTVICT);

   chance = get_skill(ch, gsn_skull_bash);
   if (chance < 70) chance = 0;
   else if (chance < 80) chance = 5;
   else if (chance < 90) chance = 10;
   else if (chance < 95) chance = 14;
   else if (chance < 100) chance = 18;
   else chance = 20;
   chance += 30;
   if (weapon->weight < 150)
   {
      chance -= (150 - weapon->weight) / 10;
   }

   if (chance > number_percent() && !is_affected(victim, gsn_skull_bash) )
   {
      act("You feel a little stunned from the blow.", ch, NULL, victim, TO_VICT);
      act("$N reels back from your brutal attack.", ch, NULL, victim, TO_CHAR);
      act("$N looks very disoriented.", ch, NULL, victim, TO_NOTVICT);

      af.where        = TO_AFFECTS;
      af.type         = gsn_skull_bash;
      af.level        = ch->level;
      af.duration      = 1;
      af.location     = 0;
      af.modifier     = 0;
      af.bitvector    = 0;
      affect_to_char(victim,&af);
   }

   check_improve(ch,gsn_skull_bash,TRUE,1);
   dam = dice(weapon->value[1],weapon->value[2]);
   dam += (get_skill(ch,gsn_skull_bash) / 4);

   if ((ch->drain_level + ch->level) <= 15)
   dam *= 1;
   else if ((ch->drain_level + ch->level) <= 20)
   dam *= 3/2;
   else if ((ch->drain_level + ch->level) < 25)
   dam *= 2;
   else if ((ch->drain_level + ch->level) < 30)
   dam *= 7/3;
   else if ((ch->drain_level + ch->level) < 40)
   dam *= 5/2;
   else if ((ch->drain_level + ch->level) <= 49)
   dam *= 7/2;
   else if ((ch->drain_level + ch->level) <= 55)
   dam *= 10/3;
   else dam *= 10/3;
   dam *= battlecry_multiplier(ch,victim,gsn_skull_bash);
   damage(ch,victim,dam,gsn_skull_bash, attack_table[weapon->value[3]].damage, TRUE);
   WAIT_STATE(ch,24);
   return;
}

void do_feign_death( CHAR_DATA *ch, char *argument)
{
   int chance;
   AFFECT_DATA* paf;
   int modifier;

   if ((chance = get_skill(ch,gsn_feign_death)) <= 0
   || !has_skill(ch,gsn_feign_death))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_feign_death))
   {
      affect_strip(ch, gsn_feign_death);
      send_to_char("You are no longer feigning death.\n\r",ch);
      return;
   }
   if (ch->fighting)
   modifier = 2;
   else modifier = 1;
   if (ch->in_room->house != 0 &&
   ch->in_room->house != ch->house)
   {
      send_to_char("You cannot fake death in this house.\n\r",ch);
      return;
   }
   if (number_percent() < chance/modifier)
   {
      send_to_char("You fake your own death.\n\r",ch);
      act( "$n is DEAD!!", ch, 0, 0, TO_ROOM );
      death_cry(ch);

      paf = new_affect();
      paf->where        = TO_AFFECTS;
      paf->type         = gsn_feign_death;
      paf->level        = ch->level;
      paf->duration     = ch->level/7;
      paf->bitvector    = AFF_SNEAK;
      paf->bitvector2   = AFF_FEIGN_DEATH;
      affect_to_char_version(ch, paf, AFFECT_CURRENT_VERSION);
      free_affect(paf);
      check_improve(ch,gsn_feign_death,TRUE,2);
      stop_fighting(ch,TRUE);
   }
   else
   {
      send_to_char("You fail feigning death.\n\r",ch);
      check_improve(ch,gsn_feign_death,FALSE,2);
   }
   WAIT_STATE(ch,12);
   return;
}


void do_killer_instinct( CHAR_DATA *ch, char *argument)
{
   int chance;
   AFFECT_DATA af;

   if ((chance = get_skill(ch,gsn_killer_instinct)) <= 0
   || !has_skill(ch,gsn_killer_instinct))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_killer_instinct))
   {
      send_to_char("You are already focused on the hunt.\n\r",ch);
      return;
   }

   if (number_percent() < chance)
   {
      send_to_char("You focus your will on the hunt!\n\r",ch);
      act("$n looks much more focused.",ch,NULL,NULL,TO_ROOM);
      check_improve(ch,gsn_killer_instinct,TRUE,2);

      af.where        = TO_AFFECTS;
      af.type         = gsn_killer_instinct;
      af.level        = ch->level;
      af.duration     = ch->level/4;
      af.modifier     = ch->level;
      af.bitvector    = 0;
      af.location     = APPLY_AC;
      affect_to_char( ch, &af);
   }
   else
   {
      send_to_char("You can't seem to focus.\n\r",ch);
      check_improve(ch,gsn_killer_instinct,FALSE,2);
   }
   WAIT_STATE(ch,12);
   return;
}

void do_block_retreat( CHAR_DATA *ch, char *argument)
{
   AFFECT_DATA af;

   if (get_skill(ch,gsn_block_retreat) <= 0
   || !has_skill(ch,gsn_block_retreat))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_block_retreat))
   {
      affect_strip(ch, gsn_block_retreat);
      send_to_char("You no longer focus on blocking retreats.\n\r",ch);
      return;
   }

   send_to_char("You begin to pay attention to attempts to retreat.\n\r",ch);
   check_improve(ch,gsn_block_retreat,TRUE,5);
   af.where        = TO_AFFECTS;
   af.type         = gsn_block_retreat;
   af.level        = ch->level;
   af.duration     = 5;
   af.modifier     = 0;
   af.bitvector    = 0;
   af.location     = 0;
   affect_to_char( ch, &af);
   WAIT_STATE(ch,12);
   return;
}

void do_wildfury( CHAR_DATA *ch, char *argument)
{
   int chance;
   AFFECT_DATA af;

   if ((chance = get_skill(ch,gsn_wildfury)) <= 0
   || !has_skill(ch,gsn_wildfury))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (is_affected(ch,gsn_wildfury))
   {
      send_to_char("You are already furious.\n\r",ch);
      return;
   }

   if (IS_AFFECTED(ch,AFF_CALM))
   {
      send_to_char("You just don't have the anger in you at the moment.\n\r",ch);
      return;
   }

   if (number_percent() < chance)
   {
      send_to_char("You become furious!\n\r",ch);
      act("$n begins to behave like a wild animal.",ch,NULL,NULL,TO_ROOM);
      check_improve(ch,gsn_wildfury,TRUE,2);

      af.where        = TO_AFFECTS;
      af.type         = gsn_wildfury;
      af.level        = ch->level;
      af.duration     = ch->level/2;
      af.modifier     = ch->level/5;
      af.bitvector    = 0;
      af.location     = APPLY_HITROLL;
      affect_to_char( ch, &af);
      af.location     = APPLY_DAMROLL;
      affect_to_char( ch, &af);
   }
   else
   {
      send_to_char("You remain calm.\n\r",ch);
      check_improve(ch,gsn_wildfury,FALSE,2);
   }
   WAIT_STATE(ch,12);
   return;
}

void do_beast_command(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *mob;
   int sn;
   int cnt, count;
   int dam;

   sn = gsn_beastial_command;
   if (!has_skill(ch,sn) || get_skill(ch,sn) <= 0)
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   WAIT_STATE(ch,24);
   count = 0;
   for (mob = char_list; mob != NULL; mob = mob->next)
   {
      if (IS_NPC(mob) && IS_AFFECTED(mob,AFF_CHARM)
      && (mob->master == ch))
      {
         cnt = 0;
         while(animal_table[cnt].name != NULL)
         {
            if (animal_table[cnt].vnum == mob->pIndexData->vnum)
            {
               if (mob->in_room == ch->in_room)
               count++;
            }
            cnt++;
         }
      }
   }
   if (count == 0)
   {
      send_to_char("You have no animals to command.\n\r",ch);
      return;
   }
   if (number_percent() > get_skill(ch,sn))
   {
      send_to_char("Your animals are stubborn and do not heed your commands.\n\r",ch);
      check_improve(ch,sn,FALSE,1);
      return;
   }
   check_improve(ch,sn,TRUE,1);
   if (ch->fighting == NULL)
   {
      send_to_char("Your animals are confused by your commands..attack who?\n\r",ch);
      return;
   }
   for (mob = char_list; mob != NULL; mob = mob->next)
   {
      if (IS_NPC(mob) && IS_AFFECTED(mob,AFF_CHARM)
      && (mob->master == ch))
      {
         cnt = 0;
         while(animal_table[cnt].name != NULL)
         {
            if (animal_table[cnt].vnum == mob->pIndexData->vnum)
            {
               if (mob->in_room == ch->in_room)
               {
                  act("$N obeys $n's command to attack!",ch,0,mob,TO_ROOM);
                  act("$N obeys your command to attack!",ch,0,mob,TO_CHAR);
                  dam = mob->level + mob->damroll;
                  dam = dam + mob->size*10;
                  dam += number_range(-dam/2,dam/2);
                  if (dam <= 40) dam = 40;
                  if (ch->fighting != NULL)
                  damage( mob, ch->fighting, dam, TYPE_HIT+mob->dam_type, attack_table[mob->dam_type].damage, TRUE );
               }
            }
            cnt++;
         }
      }
   }

   return;
}

void do_call_wild(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *mob;
   int sn;
   int cnt, count;

   sn = gsn_call_of_the_wild;
   if (!has_skill(ch,sn) || get_skill(ch,sn) <= 0)
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (!check_room(ch, FALSE, ""))
   {
      return;
   }
   count = 0;
   for (mob = char_list; mob != NULL; mob = mob->next)
   {
      if
      (
         IS_NPC(mob) &&
         IS_AFFECTED(mob,AFF_CHARM) &&
         mob->master == ch &&
         mob->fighting == NULL &&
         mob->in_room &&
         mob->in_room != ch->in_room &&
/*
         Works in area for now
         mob->in_room->area == ch->in_room->area &&
*/
         (
            IS_AWAKE(mob) ||
            (
               !IS_AFFECTED(mob, AFF_SLEEP) &&
               !is_affected(mob, gsn_blackjack) &&
               !is_affected(mob, gsn_strangle)
            )
         ) &&
         !is_affected(mob, gsn_shock_sphere)
      )
      {
         cnt = 0;
         while(animal_table[cnt].name != NULL)
         {
            if (animal_table[cnt].vnum == mob->pIndexData->vnum)
            {
               count++;
            }
            cnt++;
         }
      }
   }
   if (count == 0)
   {
      send_to_char
      (
         "You have no animals whom can be called back to you.\n\r",
         ch
      );
      return;
   }
   WAIT_STATE(ch,12);
   act( "$n calls out into the wild for $s pets to return.", ch, NULL, NULL, TO_ROOM );
   send_to_char("You call out into the wild for your pets to return.\n\r",ch);
   if (number_percent() > get_skill(ch,sn))
   {
      send_to_char("Your animals don't seem to be responding.\n\r",ch);
      check_improve(ch,sn,FALSE,1);
      return;
   }
   check_improve(ch,sn,TRUE,1);

   for (mob = char_list; mob != NULL; mob = mob->next)
   {
      if
      (
         IS_NPC(mob) &&
         IS_AFFECTED(mob, AFF_CHARM) &&
         mob->master == ch &&
         mob->fighting == NULL &&
         mob->in_room &&
         mob->in_room != ch->in_room &&
/*
         Works in area for now
         mob->in_room->area == ch->in_room->area &&
*/
         (
            IS_AWAKE(mob) ||
            (
               !IS_AFFECTED(mob, AFF_SLEEP) &&
               !is_affected(mob, gsn_blackjack) &&
               !is_affected(mob, gsn_strangle)
            )
         ) &&
         !is_affected(mob, gsn_shock_sphere)
      )
      {
         cnt = 0;
         while(animal_table[cnt].name != NULL)
         {
            if (animal_table[cnt].vnum == mob->pIndexData->vnum)
            {
               if (mob->in_room != ch->in_room)
               {

                  act( "$n goes to find its master.", mob, NULL, NULL, TO_ROOM );
                  char_from_room( mob );
                  char_to_room( mob, ch->in_room );
                  act( "$N answers $n's call.", ch, NULL, mob, TO_ROOM );
                  act( "$n answers your call.", mob, NULL, ch, TO_VICT );
               }
            }
            cnt++;
         }
      }
   }

   return;
}

/* Fire breath ability for xeonauz's brand - Jord */
void check_xeonauz_brand( CHAR_DATA *ch, CHAR_DATA *victim)
{
   int dam;
   OBJ_DATA *obj_next, *obj_lose;

   if (number_percent() > 8) return;
   act("a sword wrapped in flames burns brightly!", ch, NULL, NULL, TO_ALL);

   dam = ch->level*2;
   dam += number_range(0,30);
   damage(ch, victim, dam, gsn_breath_fire, DAM_FIRE, TRUE);

   if ( number_percent( ) < ch->level && !saves_spell( victim, ch->level - 2, victim,DAM_FIRE, SAVE_BREATH ) )
   {
      for ( obj_lose = victim->carrying; obj_lose != NULL;obj_lose = obj_next)
      {
         char *msg, *msg2;

         obj_next = obj_lose->next_content;
         if
         (
            obj_lose->wear_loc == WEAR_INSIDE_COVER ||
            number_bits(2)
         )
         {
            continue;
         }

         switch ( obj_lose->item_type )
         {
            default:             continue;
            case ITEM_CONTAINER:
            msg = "$p ignites and burns!";
            msg2 = "$N's $p ignites and burns!"; break;
            case ITEM_POTION:
            msg = "$p bubbles and boils!";
            msg2 = "$N's $p bubbles and boils!"; break;
            case ITEM_SCROLL:
            msg = "$p crackles and burns!";
            msg2 = "$N's $p crackles and burns!"; break;
            case ITEM_STAFF:
            msg = "$p smokes and chars!";
            msg2 = "$N's $p smokes and chars!"; break;
            case ITEM_WAND:
            msg = "$p sparks and sputters!";
            msg2 = "$N's $p sparks and sputters!"; break;
            case ITEM_FOOD:
            msg = "$p blackens and crisps!";
            msg2 = "$N's $p blackens and crisps!"; break;
            case ITEM_HERB:
            msg = "$p smolders and burns!";
            msg2 = "$N's $p smolders and burns!"; break;
            case ITEM_PILL:
            msg = "$p melts and drips!";
            msg2 = "$N's $p melts and drips!"; break;
         }

         act( msg, victim, obj_lose, NULL, TO_CHAR );
         act( msg2, ch, obj_lose, victim, TO_CHAR );
         extract_obj( obj_lose, FALSE );
      }
   }
}

/* Combat ability for vrrin's brand. */
void check_vrrin_brand(CHAR_DATA* ch, CHAR_DATA* victim)
{
   int dam;
   bool oblivion = FALSE;
   bool dread = FALSE;
   AFFECT_DATA* paf;

   if
   (
      !(oblivion = is_affected(ch, gsn_will_oblivion)) &&
      !(dread = is_affected(ch, gsn_will_dread)) &&
      !is_affected(ch, gsn_will_power)
   )
   {
      return;
   }
   if (dread)
   {
      if (number_percent() > 5)
      {
         return;
      }
      magic_spell_vict
      (
         ch,
         victim,
         CAST_BITS_PLR_SKILL,
         ch->level,
         gsn_power_word_fear
      );
      return;
   }
   if (number_percent() > 8)
   {
      return;
   }
   act
   (
      "The Faded Aura surrounding $n vanishes from sight.",
      ch,
      NULL,
      NULL,
      TO_ROOM
   );
   send_to_char
   (
      "The Faded Aura surrounding you vanishes from sight.\n\r",
      ch
   );
   send_to_char
   (
      "You feel your essence being torn apart by some unseen force.\n\r",
      victim
   );
   if (oblivion && !is_affected(victim, gsn_mantle_oblivion))
   {
      paf = new_affect();
      paf->where = TO_AFFECTS;
      paf->type = gsn_mantle_oblivion;
      paf->duration = 8;
      paf->location = APPLY_REGENERATION;
      paf->modifier = -3;
      affect_to_char(victim, paf);
      free_affect(paf);
      send_to_char
      (
         "A mantle of oblivion surrounds you and you feel your\n\r"
         "constitution begin to slip away.\n\r",
         victim
      );
   }
   dam = ch->level * 2 + number_range(0, 30);
   damage(victim, victim, dam, gsn_will_power, DAM_OTHER, TRUE);
   send_to_char
   (
      "The Faded Aura appears and suffuses your being once more.\n\r",
      ch
   );
   act
   (
      "The Faded Aura appears and suffuses $ns being once more.",
      ch,
      NULL,
      NULL,
      TO_ROOM
   );
}

void do_mute(CHAR_DATA *ch,char *argument)
{
   char buf[MAX_STRING_LENGTH];
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA af;
   int chance;

   if ( (chance = get_skill(ch,gsn_mute)) <= 0
   || !has_skill(ch,gsn_mute))
   {
      send_to_char("You don't know how to silence someone.\n\r",ch);
      return;
   }
   if (house_down(ch,HOUSE_OUTLAW))
   return;
   one_argument(argument,arg);
   if (arg[0] == '\0')
   victim = ch->fighting;
   else
   victim = get_char_room(ch,arg);

   if (victim == NULL)
   {
      send_to_char("Attempt to silence whom?\n\r",ch);
      return;
   }
   if (victim == ch)
   {
      send_to_char("You can't do that.\n\r",ch);
      return;
   }
   if (IS_NPC(victim) && victim->house != 0)
   {
      send_to_char("They can not be silenced.\n\r",ch);
      return;
   }
   if (check_peace(ch)) return;

   if (is_safe(ch,victim, 0))
   return;

   if (is_affected(victim,gsn_mute))
   {
      send_to_char("They have already been silenced.\n\r",ch);
      return;
   }
   if (oblivion_blink(ch, victim))
   {
      return;
   }

   chance += ch->level*3;
   chance -= victim->level*3;
   chance += get_curr_stat(ch,STAT_DEX)*2;
   chance -= get_curr_stat(victim,STAT_DEX)*2;
   if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
   chance += 15;
   if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
   chance -= 15;
   if (chance > 90) chance = 90;
   if (chance < 10) chance = 10;

   if (number_percent() > chance)
   {
      act("$n grabs $N's throat but $N quickly jerks away.",ch,0,victim,TO_NOTVICT);
      act("You grab $N's throat but $N quickly jerks out of your grip.",ch,0,victim,TO_CHAR);
      act("$n grabs your throat but you instinctively jerk away.",ch,0,victim,TO_VICT);
      check_improve(ch,gsn_mute,FALSE,1);
      WAIT_STATE(ch,PULSE_VIOLENCE);
   }
   else
   {
      act("$n swiftly strikes $N in the throat and crushes $s larynx.",ch,0,victim,TO_NOTVICT);
      act("You swiftly strike $N in the throat and crush $s larynx.",ch,0,victim,TO_CHAR);
      act("$n swiftly strikes you in the throat, crushing your larynx.",ch,0,victim,TO_VICT);
      check_improve(ch,gsn_mute,TRUE,1);
      af.where     = TO_AFFECTS;
      af.type      = gsn_mute;
      af.level     = ch->drain_level + ch->level;
      af.duration  = 3;
      af.location  = APPLY_DEX;
      af.modifier  = -3;
      af.bitvector = 0;
      affect_to_char(victim,&af);
      af.location  = APPLY_SAVES;
      af.modifier  = 10;
      affect_to_char(victim,&af);
      WAIT_STATE(ch,PULSE_VIOLENCE);
   }

   if (!IS_NPC(ch) && !IS_NPC(victim)
   && (ch->fighting == NULL
   || victim->fighting == NULL) )
   {
      sprintf(buf,"Help, %s is attacking me!",PERS(ch,victim));
      do_myell(victim,buf);
      sprintf(log_buf, "[%s] muted [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }
   if (victim->fighting == NULL)
   {
      multi_hit(victim,ch,TYPE_UNDEFINED);
   }

   return;
}

void do_bribery(CHAR_DATA *ch, char *argument)
{
   CHAR_DATA *victim;
   char arg[MAX_INPUT_LENGTH];
   int chance;
   int cost;
   AFFECT_DATA af;

   if ( (chance = get_skill(ch,gsn_bribe)) <= 0
   ||   (!IS_NPC(ch) &&
   !has_skill(ch,gsn_tame)))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   chance = get_skill(ch,gsn_bribe);
   one_argument(argument,arg);
   if (arg[0] == '\0')
   victim = ch->fighting;
   else
   victim = get_char_room(ch,arg);
   if (victim == NULL)
   {
      send_to_char("Bribe who?.\n\r",ch);
      return;
   }
   if (!IS_NPC(victim))
   {
      send_to_char("Why not just ask if they'll take the money?\n\r",ch);
      return;
   }
   if (is_affected(victim,gsn_bribe))
   {
      send_to_char("They don't seem to be interested in another bribe!\n\r",ch);
   }
   WAIT_STATE(ch,12);
   if (victim->house != 0) chance = 0;
   if (IS_SET(victim->act,ACT_UNDEAD)) chance = 0;
   chance += victim->alignment/20;
   if (IS_AFFECTED(victim, AFF_CHARM))
   chance = 0;
   if (victim->level - 4 > ch->level)
   {
      act("$n tries to bribe $N.",ch,0,victim,TO_NOTVICT);
      act("$n tries to bribe you with gold.",ch,0,victim,TO_VICT);
      act("You try to bribe $N, but $M doesn't seem interested.",ch,0,victim,TO_CHAR);
      do_say(victim, "Why should I take a bribe when I can just kill you?");
      return;
   }
   chance += ch->level * 5;
   chance -= victim->level * 5;
   if (chance > 90)        chance = 90;
   if (number_percent() > chance)
   {
      act("$n tries to bribe $N.",ch,0,victim,TO_NOTVICT);
      act("$n tries to bribe you with gold.",ch,0,victim,TO_VICT);
      act("You try to bribe $N, but $M doesn't seem interested.",ch,0,victim,TO_CHAR);
      check_improve(ch,gsn_bribe,FALSE,2);
      return;
   }
   cost = victim->level * 100;
   cost += cost/(number_range(5,20));
   if (cost > 10000) cost = 10000;
   if (ch->gold < cost)
   {
      send_to_char("You don't have enough gold to interest them!\n\r",ch);
      act("$n tries to bribe $N.",ch,0,victim,TO_NOTVICT);
      act("$n tries to bribe you with gold.",ch,0,victim,TO_VICT);
      do_say(victim,"You call that money!");
      return;
   }
   ch->gold -= cost;
   victim->gold += cost;
   act("$n bribes $N with gold.",ch,0,victim,TO_NOTVICT);
   act("You bribe $N with your gold.",ch,0,victim,TO_CHAR);
   act("$n bribes you with gold.",ch,0,victim,TO_VICT);
   af.where    = TO_AFFECTS;
   af.type     = gsn_bribe;
   af.level    = victim->level;
   af.duration = 12;
   af.modifier = 0;
   af.location = 0;
   af.bitvector = 0;
   affect_to_char(victim, &af);
   if (victim->level >= ch->level)
   do_say(victim, "Thanks for the gold, now get lost before I change my mind.");
   check_improve(ch,gsn_bribe,TRUE,2);
   stop_fighting(victim,TRUE);
   victim->last_fought = -1;
   return;
}

void do_bind(CHAR_DATA *ch, char * argument)
{
   OBJ_DATA *scan;
   int found;
   CHAR_DATA *victim;
   AFFECT_DATA af;
   char buf[MAX_STRING_LENGTH];
   int chance;

   if
   (
      !has_skill(ch, gsn_bind) ||
      (
         chance = get_skill(ch, gsn_bind)
      ) < 1
   )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   found = FALSE;
   for (scan = ch->carrying; scan != NULL; scan = scan->next_content)
   {
      if (scan->pIndexData->vnum == OBJ_VNUM_ROPE)
      {
         found = TRUE;
         break;
      }
   }
   if (found == FALSE)
   {
      send_to_char("You lack the rope to bind anyone.\n\r",ch);
      return;
   }
   victim = get_char_room(ch, argument);
   if (victim == NULL)
   {
      send_to_char("Bind whom?\n\r",ch);
      return;
   }
   if (IS_AWAKE(victim))
   {
      send_to_char("They are far too alert to bind right now.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (is_affected(victim, gsn_bind))
   {
      send_to_char("They are already bound well enough.\n\r",ch);
      return;
   }
   extract_obj(scan, FALSE);
   WAIT_STATE(ch, 24);
   if
   (
      IS_AFFECTED(victim, AFF_SLEEP) ||
      is_affected(victim, gsn_blackjack) ||
      is_affected(victim, gsn_strangle)
   )
   {
      chance -= 5;  /* max 95% chance if forcibly asleep */
   }
   else
   {
      chance -= 15;  /* max 85% chance if normally sleeping */
   }
   if (number_percent() > chance)
   {
      check_improve(ch,gsn_bind,FALSE,1);
      send_to_char("You make a mistake and wake them up!\n\r",ch);
      sprintf(buf,"Help! %s tried to bind me with ropes!",PERS(ch,victim));
      if (!IS_NPC(victim))
      {
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] bound [%s] at %d",
         ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      damage(ch,victim,2 + 2*number_range(2,5),gsn_bind,DAM_BASH,TRUE);
      multi_hit(victim, ch, TYPE_UNDEFINED);
      return;
   }
   if (!IS_NPC(victim))
   {
      sprintf(log_buf, "[%s] bound [%s] at %d",
      ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }
   check_improve(ch,gsn_bind,TRUE,1);
   af.where = TO_AFFECTS;
   af.type = gsn_bind;
   af.duration = 3;
   af.bitvector = 0;
   af.level = ch->drain_level + ch->level;
   af.modifier = -3;
   af.location = APPLY_DEX;
   affect_to_char(victim, &af);
   send_to_char("You bind them with heavy rope.\n\r",ch);
   send_to_char("Your hands are bound with heavy rope!\n\r",victim);
   act("$n ties $N up with heavy rope!",ch,0,victim,TO_ROOM);
   return;
}

void do_gag(CHAR_DATA *ch, char * argument)
{
   OBJ_DATA *scan;
   int found;
   CHAR_DATA *victim;
   AFFECT_DATA af;
   char buf[MAX_STRING_LENGTH];
   int chance;

   if
   (
      !has_skill(ch, gsn_gag) ||
      (
         chance = get_skill(ch, gsn_gag)
      ) < 1
   )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   found = FALSE;
   for (scan = ch->carrying; scan != NULL; scan = scan->next_content)
   {
      if (scan->pIndexData->vnum == OBJ_VNUM_STRAP)
      {
         found = TRUE;
         break;
      }
   }
   if (found == FALSE)
   {
      send_to_char("You lack the leather strap needed to gag someone.\n\r",ch);
      return;
   }
   victim = get_char_room(ch, argument);
   if (victim == NULL)
   {
      send_to_char("Gag whom?\n\r",ch);
      return;
   }
   if (IS_AWAKE(victim))
   {
      send_to_char("They are far too alert to gag right now.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (is_affected(victim, gsn_gag))
   {
      send_to_char("They are already gagged.\n\r",ch);
      return;
   }
   extract_obj(scan, FALSE);
   WAIT_STATE(ch, 24);
   if
   (
      IS_AFFECTED(victim, AFF_SLEEP) ||
      is_affected(victim, gsn_blackjack) ||
      is_affected(victim, gsn_strangle)
   )
   {
      chance -= 5;  /* max 95% chance if forcibly asleep */
   }
   else
   {
      chance -= 10;  /* max 90% chance if normally sleeping */
   }
   if (number_percent() > chance)
   {
      check_improve(ch,gsn_gag,FALSE,1);
      send_to_char("You make a mistake and wake them up!\n\r",ch);
      sprintf(buf,"Help! %s tried to gag me!",PERS(ch,victim));
      if (!IS_NPC(victim))
      {
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] gagged [%s] at %d",
         ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      damage(ch,victim,2 + 2*number_range(2,5),gsn_gag,DAM_BASH,TRUE);
      multi_hit(victim, ch, TYPE_UNDEFINED);
      return;
   }
   if (!IS_NPC(victim))
   {
      sprintf(log_buf, "[%s] gagged [%s] at %d",
      ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }
   check_improve(ch,gsn_gag,TRUE,1);
   af.where = TO_AFFECTS;
   af.type = gsn_gag;
   af.modifier = 0;
   af.location = 0;
   af.duration = 1;
   af.bitvector = 0;
   af.level = ch->drain_level + ch->level;
   affect_to_char(victim,&af);
   send_to_char("You gag them with a leather strap.\n\r",ch);
   send_to_char("You are gagged!\n\r",victim);
   act("$n puts a leather gag on $N!",ch,0,victim,TO_ROOM);
   return;
}

void do_blindfold(CHAR_DATA *ch, char * argument)
{
   OBJ_DATA *scan;
   int found;
   CHAR_DATA *victim;
   AFFECT_DATA af;
   char buf[MAX_STRING_LENGTH];
   int chance;

   if
   (
      !has_skill(ch, gsn_blindfold) ||
      (
         chance = get_skill(ch, gsn_blindfold)
      ) < 1
   )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   found = FALSE;
   for (scan = ch->carrying; scan != NULL; scan = scan->next_content)
   {
      if (scan->pIndexData->vnum == OBJ_VNUM_STRAP)
      {
         found = TRUE;
         break;
      }
   }
   if (found == FALSE)
   {
      send_to_char("You lack the leather strap needed to blindfold someone.\n\r",ch);
      return;
   }
   victim = get_char_room(ch, argument);
   if (victim == NULL)
   {
      send_to_char("Blindfold whom?\n\r",ch);
      return;
   }
   if (IS_AWAKE(victim))
   {
      send_to_char("They are far too alert to blindfold right now.\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   if (is_affected(victim, gsn_blindfold))
   {
      send_to_char("They are already blindfolded.\n\r",ch);
      return;
   }
   extract_obj(scan, FALSE);
   WAIT_STATE(ch, 24);
   chance -= 5;  /* max 95% chance */

   if (number_percent() > chance)
   {
      check_improve(ch,gsn_blindfold,FALSE,1);
      send_to_char("You make a mistake and wake them up!\n\r",ch);
      sprintf(buf,"Help! %s tried to blindfold me!",PERS(ch,victim));
      if (!IS_NPC(victim))
      {
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] blindfolded [%s] at %d",
         ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      damage(ch,victim,2 + 2*number_range(2,5),gsn_blindfold,DAM_BASH,TRUE);
      multi_hit(victim, ch, TYPE_UNDEFINED);
      return;
   }
   if (!IS_NPC(victim))
   {
      sprintf(log_buf, "[%s] blindfolded [%s] at %d",
      ch->name, victim->name, ch->in_room->vnum);
      log_string(log_buf);
   }
   check_improve(ch,gsn_blindfold,TRUE,1);
   af.where = TO_AFFECTS;
   af.type = gsn_blindfold;
   af.modifier = 0;
   af.location = 0;
   af.duration = 2;
   af.bitvector = AFF_BLIND;
   af.level = ch->drain_level + ch->level;
   affect_to_char(victim,&af);
   send_to_char("You blindfold them with a leather strap.\n\r",ch);
   send_to_char("You are blindfolded!\n\r",victim);
   act("$n puts a leather blindfold on $N!",ch,0,victim,TO_ROOM);

   return;
}

void do_offhand_disarm( CHAR_DATA *ch, char *argument )
{
   CHAR_DATA *victim;
   OBJ_DATA *obj;
   int chance;


   if ((chance = get_skill(ch,gsn_offhand_disarm)) <= 0)
   {
      send_to_char( "You don't know how to offhand disarm.\n\r", ch );
      return;
   }

   if ( get_eq_char( ch, WEAR_WIELD ) == NULL )
   {
      send_to_char( "You must wield a weapon to disarm.\n\r", ch );
      return;
   }

   if ( ( victim = ch->fighting ) == NULL )
   {
      send_to_char( "You aren't fighting anyone.\n\r", ch );
      return;
   }

   if ( ( obj = get_eq_char( victim, WEAR_WIELD ) ) == NULL )
   {
      send_to_char( "Your opponent is not wielding a weapon.\n\r", ch );
      return;
   }
   /* skill */
   chance = get_skill(ch,gsn_offhand_disarm);

   /* dex vs. strength */
   chance += get_curr_stat(ch,STAT_DEX);
   chance -= 2 * get_curr_stat(victim,STAT_STR);
   if (check_two_hand_wield(victim))
   chance /= 2;

   /* level */
   chance += (ch->drain_level + ch->level - victim->drain_level - victim->level) * 2;

   /* and now the attack */
   if (number_percent() < chance)
   {
      WAIT_STATE( ch, skill_table[gsn_disarm].beats );
      off_disarm( ch, victim );
      check_improve(ch,gsn_offhand_disarm,TRUE,1);
   }
   else
   {
      WAIT_STATE(ch,skill_table[gsn_disarm].beats);
      act("You fail to disarm $N.",ch,NULL,victim,TO_CHAR);
      act("$n tries to disarm you, but fails.",ch,NULL,victim,TO_VICT);
      act("$n tries to disarm $N, but fails.",ch,NULL,victim,TO_NOTVICT);
      check_improve(ch,gsn_offhand_disarm,FALSE,1);
   }
   check_killer(ch,victim);
   return;
}

/*
* Disarm a creature.
* Caller must check for successful attack.
*/
void off_disarm(CHAR_DATA* ch, CHAR_DATA* victim)
{
   OBJ_DATA* obj;
   OBJ_DATA* secondary;

   obj = get_eq_char(victim, WEAR_DUAL_WIELD);
   if (obj == NULL)
   {
      obj = get_eq_char(victim, WEAR_HOLD);
   }
   if (obj == NULL)
   {
      obj = get_eq_char(victim, WEAR_WIELD);
   }

   if (obj == NULL)
   {
      return;
   }

   if (IS_OBJ_STAT(obj, ITEM_NOREMOVE))
   {
      act
      (
         "$S weapon will not budge!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n tries to disarm you, but your weapon will not budge!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n tries to disarm $N, but fails.",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      return;
   }
   if (IS_AFFECTED(ch, AFF_BLIND))
   {
      if (number_range(1, 3) == 1)
      {
         act
         (
            "$n DISARMS you and sends your $p flying!",
            ch,
            obj,
            victim,
            TO_VICT
         );
         act
         (
            "You disarm $N!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "$n disarms $N!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         obj_from_char(obj);
      }
      else
      {
         send_to_char("Your blindness inhibits the accuracy of the disarm attempt!\n\r", ch);
         return;
      }
   }
   else
   {
      if (number_range(1, 4) != 1)
      {
         act
         (
            "$n DISARMS you and sends your $p flying!",
            ch,
            obj,
            victim,
            TO_VICT
         );
         act
         (
            "You disarm $N!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "$n disarms $N!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         obj_from_char(obj);
      }
      else
      {
         send_to_char("You fail to disarm them.\n\r", ch);
         return;
      }
   }

   if
   (
      IS_OBJ_STAT(obj, ITEM_NODROP) ||
      IS_OBJ_STAT(obj, ITEM_INVENTORY)
   )
   {
      obj_to_char(obj, victim);
   }
   else
   {
      if
      (
         (
            IS_AFFECTED(ch, AFF_BLIND) &&
            !number_range(1, 5)
         ) ||
         (
            !IS_AFFECTED(ch, AFF_BLIND) &&
            !number_range(1, 3)
         )
      )
      {
         act
         (
            "$n catches $p in mid-air!",
            ch,
            obj,
            victim,
            TO_VICT
         );
         act
         (
            "You catch $p in mid-air!",
            ch,
            obj,
            victim,
            TO_CHAR
         );
         act
         (
            "$n catches $p in mid-air!",
            ch,
            obj,
            victim,
            TO_NOTVICT
         );
         obj_to_char(obj, ch);
      }
      else
      {
         obj_to_room(obj, victim->in_room);
      }
   }

   if ((secondary = get_eq_char(victim, WEAR_DUAL_WIELD)) != NULL)
   {
      unequip_char(victim, secondary);
      equip_char(victim, secondary, WEAR_WIELD);
   }
   return;
}

void do_thrust( CHAR_DATA *ch, char *argument )
{
   AFFECT_DATA af;
   char arg[MAX_INPUT_LENGTH];
   char arg2[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   int chance, dam;
   char buf[MAX_STRING_LENGTH];
   int which = 0;
   OBJ_DATA *obj;
   int dw_flag = FALSE; /* dual wield check */

   if ( (chance = get_skill(ch,gsn_thrust)) <= 0 ||
   !has_skill(ch,gsn_thrust))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   argument = one_argument(argument,arg2);
   argument = one_argument(argument,arg);

   if (arg2[0] != '\0')
   {
      if (!str_cmp(arg2, "leg"))
      which = 1;
      if (!str_cmp(arg2, "arm"))
      which = 2;
      if (!str_cmp(arg2, "shoulder"))
      which = 3;
      if (!str_cmp(arg2, "hand"))
      which = 4;
   }

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   obj = get_eq_char(ch, WEAR_WIELD);
   if (obj == NULL)
   {
      send_to_char("You can only thrust with swords.\n\r",ch);
      return;
   }
   if (obj->value[0] != WEAPON_SWORD)
   {
      obj = get_eq_char(ch, WEAR_DUAL_WIELD);
      if (obj == NULL || obj->value[0] != WEAPON_SWORD)
      {
         send_to_char("You can only thrust with swords.\n\r",ch);
         return;
      }
      dw_flag = TRUE;
   }

   if (check_peace(ch)) return;

   if (is_safe(ch,victim, 0))
   return;

   if (is_affected(victim,gsn_thrust))
   {
      AFFECT_DATA *paf;
      if (which == 0)
      {
         send_to_char("They have already been affected by thrusting. (specify a location: arm, hand, shoulder, leg)\n\r",ch);
         return;
      }
      /* have to check for individual types of maledictions */
      paf = victim->affected;
      while (paf != NULL)
      {
         if (paf->type == gsn_thrust)
         {
            if ((paf->location == APPLY_AC && which == 1) ||
            (paf->location == APPLY_STR && which == 2) ||
            (paf->location == APPLY_DEX && which == 3) ||
            (paf->location == APPLY_HITROLL && which == 4))
            {
               send_to_char("They've already been affected by a thrust there.\n\r",ch);
               return;
            }
         }
         paf = paf->next;
      }
   }
   if (which == 0)
   which = number_range(1,4);

   if (victim == ch)
   {
      send_to_char("You contemplate it but decide against it...\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /* dex */
   chance += get_curr_stat(ch,STAT_DEX);
   chance -= get_curr_stat(victim,STAT_DEX) * 3 / 2;
   if (dw_flag == TRUE)
   chance = chance - 20;

   /* speed */
   if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
   chance += 10;
   if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
   chance -= 20;

   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level) * 2;


   /* now the attack */
   if (number_percent() < chance)
   {
      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (ch->fighting == NULL || victim->fighting == NULL))
      {
         sprintf
         (
            buf,
            "Help! %s is impaling me with %s rapier!",
            PERS(ch, victim),
            (
               ch->sex == SEX_MALE ?
               "his" :
               (
                  ch->sex == SEX_FEMALE ?
                  "her" :
                  "its"
               )
            )
         );
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] thrusted [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }

      dam = ch->level + number_range(ch->level, ch->level*2) + number_range(1, 50);
      if (dw_flag == TRUE)
      dam = dam - dam/3;

      dam *= battlecry_multiplier(ch, victim, gsn_thrust);
      damage(ch, victim, dam, gsn_thrust, DAM_PIERCE, TRUE);
      if (victim == NULL || victim->hit <= 0)
      return;
      af.where     = TO_AFFECTS;
      af.type      = gsn_thrust;
      af.level     = ch->level;
      af.bitvector = 0;
      switch (which)
      {
         case 1:  /* Leg Shot */
         act
         (
            "$n thrusts $s $p into your leg!",
            ch,
            obj,
            victim,
            TO_VICT
         );
         act
         (
            "You thrust $p into $N's leg!",
            ch,
            obj,
            victim,
            TO_CHAR
         );
         act
         (
            "$n thrusts $s $p into $N's leg!",
            ch,
            obj,
            victim,
            TO_NOTVICT
         );
         af.duration  = 3;
         af.modifier  = 30;
         af.location  = APPLY_AC;
         affect_to_char(victim, &af);
         af.modifier  = -50;
         af.location  = APPLY_MOVE;
         victim->move -= 50;
         if (victim->move < 0)
         {
             victim->move = 0;
         }
         affect_to_char(victim, &af);
         break;
         case 2:  /* Arm Shot */
         act
         (
            "$n thrusts $s $p into your arm!",
            ch,
            obj,
            victim,
            TO_VICT
         );
         act
         (
            "You thrust $p into $N's arm!",
            ch,
            obj,
            victim,
            TO_CHAR
         );
         act
         (
            "$n thrusts $s $p into $N's arm!",
            ch,
            obj,
            victim,
            TO_NOTVICT
         );
         af.duration  = 3;
         af.modifier  = -2;
         af.location  = APPLY_STR;
         affect_to_char(victim, &af);
         break;
         case 3:  /* Shoulder Shot */
         act
         (
            "$n thrusts $s $p into your shoulder!",
            ch,
            obj,
            victim,
            TO_VICT
         );
         act
         (
            "You thrust $p into $N's shoulder!",
            ch,
            obj,
            victim,
            TO_CHAR
         );
         act
         (
            "$n thrusts $s $p into $N's shoulder!",
            ch,
            obj,
            victim,
            TO_NOTVICT
         );
         af.duration  = 1;
         af.modifier  = -2;
         af.location  = APPLY_DEX;
         affect_to_char(victim, &af);
         break;
         case 4:  /* Hand Shot */
         act
         (
            "$n thrusts $s $p into your hand!",
            ch,
            obj,
            victim,
            TO_VICT
         );
         act
         (
            "You thrust $p into $N's hand!",
            ch,
            obj,
            victim,
            TO_CHAR
         );
         act
         (
            "$n thrusts $s $p into $N's hand!",
            ch,
            obj,
            victim,
            TO_NOTVICT
         );
         af.duration  = 1;
         af.modifier  = -5;
         af.location  = APPLY_HITROLL;
         affect_to_char(victim, &af);
         break;
         default:
         send_to_char("Your attempt to thrust fails.\n\r", ch);
         check_improve(ch, gsn_thrust, FALSE, 1);
         return;
      }
      check_improve(ch, gsn_thrust, TRUE, 1);
      WAIT_STATE(ch, skill_table[gsn_thrust].beats);
   }
   else
   {
      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (ch->fighting == NULL || victim->fighting == NULL))
      {
         sprintf(buf,"Help! %s just tried to impale me with their rapier!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] tried to thrust [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      damage(ch,victim,0,gsn_thrust,DAM_BASH,TRUE);
      WAIT_STATE(ch,skill_table[gsn_thrust].beats*2/3);
      check_improve(ch,gsn_thrust,FALSE,1);
   }
   return;
}

void do_swing(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   OBJ_DATA* wield;
   int dam_type;
   int dam;
   int chance;
   int monk_percent;
   int group_size = 0;
   int mult;
   bool result;
   bool monk_fist = FALSE;
   CHAR_DATA *victim;
   char buf[MAX_STRING_LENGTH];

   one_argument(argument, buf);

   if
   (
      (
         chance = get_skill(ch, gsn_swing)
      ) <= 0 ||
      (
         !IS_NPC(ch) &&
         !has_skill(ch, gsn_swing)
      )
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   if (check_peace(ch))
   {
      return;
   }

   if (buf[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not in combat!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, buf)) == NULL)
   {
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (victim == ch)
   {
      send_to_char
      (
         "You cannot get the proper leverage to swing at yourself.\n\r",
         ch
      );
      return;
   }

   if (house_down(ch, HOUSE_COVENANT))
   {
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
   {
      if (is_same_group(vch, victim))
      {
         group_size++;
      }
   }

   if (number_percent() < chance)
   {
      send_to_char("You rear back and take a mighty swing!\n\r", ch);
      act("$n rears back and takes a mighty swing!", ch, NULL, NULL, TO_ROOM);
      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         vch_next = vch->next_in_room;
         if
         (
            !is_same_group(vch, victim) ||
            is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK) ||
            (
               vch != victim &&
               oblivion_blink(ch, vch)
            )
         )
         {
            continue;
         }
         /* Check to see if they should yell */
         if
         (
            !IS_NPC(vch) &&
            (
               ch->fighting == NULL ||
               vch->fighting == NULL
            ) &&
            ch != vch
         )
         {
            /* What to yell, what to yell? */
            switch (number_range(0, 1))
            {
               case (0):
               {
                  sprintf
                  (
                     buf,
                     "Argh, %s just took a mighty swing at me!",
                     PERS(ch, vch)
                  );
                  break;
               }
               default:  /* (1) */
               {
                  sprintf
                  (
                     buf,
                     "Help! I am being attacked by %s!",
                     PERS(ch, vch)
                  );
                  break;
               }
            }
            do_myell(vch, buf);
            sprintf
            (
               log_buf,
               "[%s] performed covenant swing [%s] at %d",
               ch->name,
               vch->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
         }
         /* Let's do some damage now */
         wield = get_eq_char(ch, WEAR_WIELD);
         if (wield != NULL)
         {
            dam_type = attack_table[wield->value[3]].damage;
         }
         else
         {
            dam_type = attack_table[ch->dam_type].damage;
         }
         dam = 0;
         /* Take weapon average into account */
         if (wield)
         {
            dam += dice(wield->value[1], wield->value[2]);
         }
         else
         {
            /* average level divided by 2 for fists */
            dam += dice(1, ch->level);
            if (ch->class == CLASS_MONK)
            {
               dam += dice(1, ch->level);
            }
         }
         dam -= 28;
         /*
         Assume weapon average of 28,
         group size damage before sanc:
         1: 80  (50 - 110) new: 130 (100 - 160) new again:  140 (130 - 150)
         2: 110 (80 - 140) new: 160 (130 - 190) new again:  160 (150 - 170)
         3: 140 (100 - 180) new: 190 (150 - 230) new again: 190 (150 - 230)
         4: 180 (130 - 230) new: 230 (180 - 280) new again: 225 (180 - 270)
         5: 200 (150 - 250) new: 250 (200 - 300) new again: 240 (200 - 280)
         6: Every target after 5, add extra 10 to the average.
         */
         switch (group_size)
         {
            /* 0 not possible, 1 means you are alone in your group */
            case (1):
            dam += number_range(70, 90);
            break;
            case (2):
            dam += number_range(150, 170);
            break;
            case (3):
            dam += number_range(150, 230);
            break;
            case (4):
            dam += number_range(180, 270);
            break;
            case (5):
            dam += number_range(200, 280);
            break;
            default:  /* 6+ */
            /* add up to 10 more damage for every groupmember over 5 */
            dam += number_range(1, group_size - 5) * 10;
            dam += number_range(200, 280);
            break;
         }
         /* Damroll added directly */
         dam += ch->damroll;
         if
         (
            get_skill(ch,gsn_enhanced_damage) > 0 &&
            has_skill(ch, gsn_enhanced_damage)
         )
         {
            int diceroll = number_percent();
            if (diceroll <= get_skill(ch, gsn_enhanced_damage))
            {
               check_improve(ch, gsn_enhanced_damage, TRUE, 6);
               dam += 2 * (dam * (diceroll + ch->level) / 300);
            }
         }
         if
         (
            get_skill(ch, gsn_enhanced_damage_two) > 0 &&
            has_skill(ch, gsn_enhanced_damage_two)
         )
         {
            int diceroll2 = number_percent();
            if ((diceroll2 <= get_skill(ch, gsn_enhanced_damage_two)))
            {
               check_improve(ch, gsn_enhanced_damage_two, TRUE, 3);
               diceroll2 = diceroll2 / 2;
               diceroll2 = UMAX(diceroll2, 20);
               dam += 2 * (dam * diceroll2 / 200);
            }
         }
         /*
         Modify according to strength
         changeling (17) strength will remain unchanged
         others (lower/higher) will go up or down
         but only by 1/3rd the normal strength rules
         this means 25 str will give a 15.6 percent increase
         3 str will give a 27.4 % decrease in damage
         */
         mult = get_curr_stat(ch, STAT_STR);
         /* Multiplying by 1000, to keep more significant digits */
         mult *= 1000;
         /* divide by base strength (17) */
         mult /= 17;
         /*
         take 1000 away, we now have the percentage difference
         between 17 and your str (times 1000)
         */
         mult -= 1000;
         /* divide that difference by 3 to reduce how much this changes */
         mult /= 3;
         /* add the 1000 back, 125% after this will be like this: 1250 */
         mult += 1000;
         /* multiply by the multiplier */
         dam *= mult;
         /* divide by 1000, to return to normal */
         dam /= 1000;
         /* Scale to level */
         dam *= ch->level;
         dam /= LEVEL_HERO;
         /* Skills and items */
         /* Two handed wielding (barbarian) */
         if (check_two_hand_wield(ch))
         {
            if (number_percent() <= get_skill(ch,gsn_two_hand_wield))
            {
               check_improve(ch,gsn_two_hand_wield,TRUE,3);
               dam += (ch->level + ch->drain_level) * dam / 51 / 4;
            }
         }
         /* crushing blow */
         if
         (
            wield != NULL &&
            (
               wield->value[0] == WEAPON_STAFF ||
               wield->value[0] == WEAPON_MACE ||
               wield->value[0] == WEAPON_AXE
            ) &&
            has_skill(ch, gsn_crushingblow) &&
            number_percent() <= get_skill(ch, gsn_crushingblow) / 8
         )
         {
            dam = 2 * dam + (dam * 2 * number_percent() / 100);
            send_to_char("You land a crushing blow!\n\r", ch);
            act("$n lands a crushing blow!", ch, NULL, NULL, TO_ROOM);
            check_improve(ch, gsn_crushingblow, TRUE, 1);
         }
         if (ch->class == CLASS_MONK)
         {
            monk_percent = number_percent();
            if
            (
               is_affected(ch, gsn_fists_fire) &&
               monk_percent < get_skill(ch, gsn_fists_fire) / 3
            )
            {
               send_to_char("A fiery haze surrounds your fists!\n\r", ch);
               act
               (
                  "$n's fists are surrounded by a fiery haze!",
                  ch,
                  NULL,
                  vch,
                  TO_ROOM
               );
               dam_type = DAM_FIRE;
               monk_fist = TRUE;
            }
            else if
            (
               is_affected(ch, gsn_fists_ice) &&
               monk_percent < get_skill(ch, gsn_fists_ice) / 3
            )
            {
               send_to_char("A frosty haze surrounds your fists!\n\r", ch);
               act
               (
                  "$n's fists are surrounded by a frosty haze!",
                  ch,
                  NULL,
                  vch,
                  TO_ROOM
               );
               dam_type = DAM_COLD;
               monk_fist = TRUE;
            }
            if
            (
               is_affected(ch, gsn_fists_divine) &&
               monk_percent < get_skill(ch, gsn_fists_divine) / 3
            )
            {
               send_to_char("A holy aura surrounds your fists!\n\r", ch);
               act
               (
                  "$n's fists are surrounded by a holy aura!",
                  ch,
                  NULL,
                  vch,
                  TO_ROOM
               );
               dam_type = DAM_HOLY;
               monk_fist = TRUE;
            }
            else if
            (
               is_affected(ch, gsn_open_claw) &&
               monk_percent <= get_skill(ch, gsn_open_claw) / 3
            )
            {
               send_to_char("You open your claws for a deadly slash!\n\r", ch);
               act
               (
                  "$n's claws open and he delivers a deadly slash!",
                  ch,
                  NULL,
                  vch,
                  TO_ROOM
               );
               dam_type = DAM_SLASH;
               monk_fist = TRUE;
            }
            else if
            (
               is_affected(ch, gsn_fists_poison) &&
               monk_percent < get_skill(ch, gsn_fists_poison) / 3
            )
            {
               send_to_char
               (
                  "You strike with the powerful fang fist technique!\n\r",
                  ch
               );
               act
               (
                  "$n strikes with the fang technique!",
                  ch,
                  NULL,
                  vch,
                  TO_ROOM
               );
               dam_type = DAM_PIERCE;
               monk_fist = TRUE;
            }
            if (monk_fist)
            {
               dam += 50;  /* Only change for any monk fist. */
            }
            if (check_palm(ch))
            {
               act
               (
                  "$n strikes a powerful open handed blow!",
                  ch,
                  NULL,
                  NULL,
                  TO_ROOM
               );
               act
               (
                  "You strike a powerful open handed blow!",
                  ch,
                  NULL,
                  NULL,
                  TO_CHAR
               );
               if ((ch->drain_level + ch->level) <= 39)
               {
                  dam += dam / 5;
               }
               else
               {
                  dam += dam / 3;
               }
            }
         }
         /* sharpness! */
         if (wield && IS_WEAPON_STAT(wield, WEAPON_SHARP))
         {
            int percent;
            if ((percent = number_percent()) <= (chance / 8))
            {
               dam = 2 * dam + (dam * 2 * percent / 100);
            }
         }
         /* armor piercing */
         if (wield && IS_WEAPON_STAT(wield, WEAPON_PIERCING))
         {
            dam += dam * wield->level * number_percent() / 51000;
            /* Max of 10% increase for hero level weapon */
         }
         /* DO DAMAGE */
         dam *= battlecry_multiplier(ch, vch, gsn_swing);
         result = damage(ch, vch, dam, gsn_swing, dam_type, TRUE);
         /* If not dead yet, and not immune, do weapon flags */
         if (result && wield)
         {
            if (ch->fighting == vch && IS_WEAPON_STAT(wield, WEAPON_POISON))
            {
               int level;
               AFFECT_DATA* poison;
               AFFECT_DATA af;
               AFFECT_DATA* af2;
               poison = NULL;
               if ((poison = affect_find(wield->affected, gsn_poison)) == NULL)
               {
                  level = wield->level;
               }
               else
               {
                  level = poison->level;
               }
               if (!saves_spell(ch, level / 2, vch, DAM_POISON, SAVE_BREATH))
               {
                  send_to_char
                  (
                     "You feel poison coursing through your veins.\n\r",
                     vch
                  );
                  act
                  (
                     "$n is poisoned by the venom on $p.",
                     vch,
                     wield,
                     NULL,
                     TO_ROOM
                  );
                  af.where     = TO_AFFECTS;
                  af.type      = gsn_poison;
                  af.level     = level * 3 / 4;
                  af.duration  = level / 2;
                  af.location  = APPLY_STR;
                  af.modifier  = -1;
                  af.bitvector = AFF_POISON;
                  affect_join(vch, &af, 10);
                  af2 = affect_find(vch->affected, gsn_poison);
                  if (af2 != NULL)
                  {
                     free_string(af2->caster);
                     af2->caster = str_dup(ch->name);
                  }
               }
            }
            if
            (
               ch->fighting == vch &&
               IS_WEAPON_STAT(wield, WEAPON_VAMPIRIC) &&
               number_percent() < 13
            )
            {
               dam = number_range(wield->level / 2, wield->level);
               act("$p draws life from $n.", vch, wield, NULL, TO_ROOM);
               act
               (
                  "You feel $p drawing your life away.",
                  vch,
                  wield,
                  NULL,
                  TO_CHAR
               );
               damage(ch, vch, dam, 0, DAM_NEGATIVE, FALSE);
               ch->hit = UMIN(ch->hit + dam, ch->max_hit);
            }
            if
            (
               ch->fighting == vch &&
               IS_WEAPON_STAT(wield, WEAPON_FLAMING) &&
               number_percent() < 15
            )
            {
               dam = number_range(1, wield->level / 4 + 1);
               act("$n is burned by $p.", vch, wield, NULL, TO_ROOM);
               act("$p sears your flesh.", vch, wield, NULL, TO_CHAR);
               fire_effect((void*)vch, wield->level / 2, dam, TARGET_CHAR);
               damage(ch, vch, dam, 0, DAM_FIRE, FALSE);
            }
            if
            (
               ch->fighting == vch &&
               IS_WEAPON_STAT(wield, WEAPON_FROST) &&
               number_percent() < 15
            )
            {
               dam = number_range(1, wield->level / 6 + 2);
               act("$p freezes $n.", vch, wield, NULL, TO_ROOM);
               act
               (
                  "The cold touch of $p surrounds you with ice.",
                  vch,
                  wield,
                  NULL,
                  TO_CHAR
               );
               cold_effect(vch, wield->level / 2, dam, TARGET_CHAR);
               damage(ch, vch, dam, 0, DAM_COLD, FALSE);
            }
            if
            (
               ch->fighting == vch &&
               IS_WEAPON_STAT(wield, WEAPON_SHOCKING) &&
               number_percent() < 15
            )
            {
               dam = number_range(1, wield->level/5 + 2);
               act
               (
                  "$n is struck by lightning from $p.",
                  vch,
                  wield,
                  NULL,
                  TO_ROOM
               );
               act("You are shocked by $p.", vch, wield, NULL, TO_CHAR);
               shock_effect(vch, wield->level / 2, dam, TARGET_CHAR);
               damage(ch, vch, dam, 0, DAM_LIGHTNING, FALSE);
            }
            if
            (
               ch->fighting == vch &&
               IS_WEAPON_STAT(wield, WEAPON_DROWNING) &&
               number_percent() < 15
            )
            {
               dam = number_range(1, wield->level/5 + 2);
               act
               (
                  "$n is deluged by water spouting from $p.",
                  vch,
                  wield,
                  NULL,
                  TO_ROOM
               );
               act
               (
                  "You are smothered by a deluge of water spouting from $p.",
                  vch,
                  wield,
                  NULL,
                  TO_CHAR
               );
               drowning_effect(vch, wield->level / 2, dam, TARGET_CHAR);
               damage(ch, vch, dam, 0, DAM_DROWNING, FALSE);
            }
         }
      }
      check_improve(ch, gsn_swing, TRUE, 1);
      WAIT_STATE(ch, skill_table[gsn_swing].beats);
   }
   else
   {
      send_to_char("You attempt a mighty swing but hit nothing but air!\n\r", ch);
      act("$n's mighty swing creates a mighty breeze.", ch, NULL, NULL, TO_ROOM);
      check_improve(ch, gsn_swing, FALSE, 1);
      WAIT_STATE(ch, (skill_table[gsn_swing].beats * 3 / 2));
      /*
      add a /2 right after beats to halve pulses after miss (half round lag).
      Removed for now
      */
   }
   return;
}

void do_impale( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;
   int chance, dam;
   int dam_type;
   char buf[MAX_STRING_LENGTH];
   OBJ_DATA *obj;
   int dw_flag = FALSE; /* dual wield check */

   if ( (chance = get_skill(ch,gsn_impale)) <= 0 ||
   !has_skill(ch,gsn_impale))
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }
   if (house_down(ch, HOUSE_COVENANT)) return;

   argument = one_argument(argument,arg);

   if (arg[0] == '\0')
   {
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you aren't fighting anyone!\n\r",ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch,arg)) == NULL)
   {
      send_to_char("They aren't here.\n\r",ch);
      return;
   }

   obj = get_eq_char(ch, WEAR_WIELD);
   if (obj == NULL)
   {
      send_to_char("You can only impale with swords, spears, and daggers.\n\r",ch);
      return;
   }
   if (obj->value[0] != WEAPON_SWORD && obj->value[0] != WEAPON_DAGGER
   && obj->value[0] != WEAPON_SPEAR)
   {
      obj = get_eq_char(ch, WEAR_DUAL_WIELD);
      if (obj == NULL || (obj->value[0] != WEAPON_SWORD && obj->value[0] != WEAPON_DAGGER && obj->value[0] != WEAPON_SPEAR))
      {
         send_to_char("You can only impale with swords, spears, and daggers.\n\r",ch);
         return;
      }
      dw_flag = TRUE;
   }

   if (check_peace(ch)) return;

   if (is_safe(ch,victim, 0))
   return;

   if (victim == ch)
   {
      send_to_char("You contemplate it but decide against it...\n\r",ch);
      return;
   }

   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /* dex */
   if (dw_flag == TRUE)
   chance = chance - 20;

   /* speed */
   if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
   chance += 10;
   if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
   chance -= 20;

   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level) * 2;

   act("$n attempts to brutally impale you!", ch, 0, victim, TO_VICT);
   act("You attempt to brutally impale $N!", ch, 0, victim, TO_CHAR);

   /* now the attack */
   if (number_percent() < chance)
   {
      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (ch->fighting == NULL || victim->fighting == NULL))
      {
         sprintf(buf,"Help! %s is impaling me!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] impaled [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }

      dam_type = attack_table[obj->value[3]].damage;
      dam_type = DAM_PIERCE; /* remove this line to make it weapon based */
      dam = dice(obj->value[1],obj->value[2]);
      if (get_skill(ch,gsn_enhanced_damage) > 0 )
      {
         if (number_percent() <= get_skill(ch,gsn_enhanced_damage) )
         {
            check_improve(ch,gsn_enhanced_damage,TRUE,1);
            dam += (dam*number_range(50,100)*
            (IS_NPC(ch) ? 100 : ch->pcdata->learned[gsn_enhanced_damage]))/10000;
         }
      }
      dam += GET_DAMROLL(ch);
      dam *= get_skill(ch,gsn_impale);
      dam /= 100;
      dam += number_range(25,40);
      if (dw_flag == TRUE)
      dam = dam - dam/3;
      if (number_range(1,4) == 1)
      {
         if (number_range(1,2) == 1)
         dam *= 2;
         else
         dam = 0;
      }
      damage(ch,victim,dam,gsn_impale,dam_type,TRUE);
      check_improve(ch,gsn_impale,TRUE,1);
      WAIT_STATE(ch,skill_table[gsn_impale].beats);
   }
   else
   {
      if (!IS_NPC(ch) && !IS_NPC(victim)
      && (ch->fighting == NULL || victim->fighting == NULL))
      {
         sprintf(buf,"Help! %s just tried to impale me!",PERS(ch,victim));
         do_myell(victim,buf);
         sprintf(log_buf, "[%s] tried to impale [%s] at %d", ch->name, victim->name, ch->in_room->vnum);
         log_string(log_buf);
      }
      damage(ch,victim,0,gsn_impale,DAM_BASH,TRUE);
      WAIT_STATE(ch,skill_table[gsn_impale].beats*2/3);
      check_improve(ch,gsn_impale,FALSE,1);
   }
   return;
}

void do_telekinesis(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   OBJ_DATA* obj;
   char buf[MAX_STRING_LENGTH];
   int dam, chance;

   /* make sure you have the skill */
   if
   (
      (chance = get_skill(ch, gsn_telekinesis)) <= 0 ||
      !has_skill(ch, gsn_telekinesis)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   /* allows use of arguments (like targetting) */
   argument = one_argument(argument, arg);

   /* Use whoever you are fighting as default target */
   if (arg[0] == '\0')
   {
      /* no target, nothing happens */
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (check_peace(ch) || is_safe(ch, victim, 0))
   {
      return;
   }


   if (victim == ch)
   {
      send_to_char
      (
         "You imagine slamming yourself around...and just feel something push"
         " you over.\n\r",
         ch
      );
      act
      (
         "$n closes $m eyes and suddenly falls over.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      return;
   }
   /* Can't avoid what you can't see :P
   if (oblivion_blink(ch, victim))
   {
   return;
   }*/

   /* fail and lag */
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, 12);
      send_to_char("You fail to focus your mind.\n\r", ch);
      check_improve(ch, gsn_telekinesis, FALSE, 1);
      return;
   }
   /* If this is a player (initiating combat) with another player, yell and log */
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   {
      sprintf(buf, "Help! %s is attacking me with telekinesis!", PERS(ch, victim));
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used telekinesis on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   /* the damage */
   act
   (
      "You close your eyes and lower your head slightly.\n\r"
      "You focus your telekinetic powers on $N!\n\r"
      "$N is slammed around by an unseen force!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n closes $s eyes and lowers $s head slightly.\n\r"
      "$n focuses $s telekinetic powers on you!\n\r"
      "You are slammed around by an unseen force!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n closes $s eyes and lowers $s head slightly.\n\r"
      "$n focuses $s telekinetic powers on $N!\n\r"
      "$N is slammed around by an unseen force!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );

   /* the bash */
   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your telekinetic assault has left them stunned!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's telekinetic assault has left you stunned!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's telekinetic assault has left $N stunned!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }

   /* the disarm */
   if
   (
      number_percent() < chance / 4 &&
      (obj = get_eq_char(victim, WEAR_WIELD)) != NULL
   )
   {
      disarm(ch, victim);
      if
      (
         get_eq_char(victim, WEAR_WIELD) != obj
      )
      {
         act
         (
            "Your telekinetic assault knocks $N's weapon from $S grasp!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "$n's telekinetic assault knocks your weapon from your grasp!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "$n's telekinetic assault knocks $N's weapon from $S grasp!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
      }
   }

   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   dam *= battlecry_multiplier(ch, victim, gsn_telekinesis);
   damage(ch, victim, dam, gsn_telekinesis, DAM_OTHER, TRUE);


   check_improve(ch, gsn_telekinesis, TRUE, 1);
   WAIT_STATE(ch, 18);  /* was 24 in pounce */
   return;
}


void do_wind_shear(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   char* gender;
   int startoff = FALSE;
   int chance;
   int dam;
   char buf[MAX_STRING_LENGTH];

   if
   (
      IS_NPC(ch) ||
      check_peace(ch)
   )
   {
      return;
   }

   if
   (
      (chance = get_skill(ch, gsn_wind_shear)) <= 0 ||
      !has_skill(ch, gsn_wind_shear)
   )
   {
      send_to_char
      (
         "You have not mastered that technique.\n\r",
         ch
      );
      return;
   }

   /* Now for the attack itself */
   if
   (
      number_percent() < chance
   )
   {
      send_to_char
      (
         "You draw back your enormous wings and push them\n\r"
         "forward, unleashing a massive blast of wind!\n\r",
         ch
      );
      act
      (
         "$n's enormous wings draw back and then push\n\r"
         "forward, unleashing a massive blast of wind!",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );

      if (ch->fighting == NULL)
      {
         startoff = TRUE;
      }

      switch (URANGE(0, ch->sex, 2))
      {
         default:
         {
            gender = "its";
            break;
         }
         case (1):
         {
            gender = "his";
            break;
         }
         case (2):
         {
            gender = "her";
            break;
         }
      }
      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         vch_next = vch->next_in_room;
         chance = number_percent();
         if
         (
            vch->fighting != ch &&
            (
               is_same_group(ch, vch) ||
               is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK)
            )
         )
         {
            continue;
         }

         if
         (
            !startoff &&
            vch->fighting != ch
         )
         {
            continue;
         }

         if
         (
            vch != ch &&
            !IS_NPC(ch) &&
            !IS_NPC(vch) &&
            (
               ch->fighting == NULL ||
               vch->fighting == NULL
            )
         )
         {
            switch(number_range(0, 2))
            {
               case (0):
               {
                  sprintf
                  (
                     buf,
                     "Argh, %s is blasting me with wind from %s wings!",
                     PERS(ch, vch),
                     gender
                  );
                  break;
               }
               default:  /* 1, 2 */
               {
                  sprintf(buf, "Help! %s just attacked me!", PERS(ch, vch));
                  break;
               }
            }
            do_myell(vch, buf);
            sprintf
            (
               log_buf,
               "[%s] used wind shear on [%s] at %d",
               ch->name,
               vch->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
         }
         /* the bash */
         if
         (
            (vch->daze == 0) &&
            (number_percent() < chance / 2)
         )
         {
            act
            (
               "Your wind shear has left them stunned!",
               ch,
               NULL,
               vch,
               TO_CHAR
            );
            act
            (
               "$n's wind shear has left you stunned!",
               ch,
               NULL,
               vch,
               TO_VICT
            );
            act
            (
               "$n's wind shear has left $N stunned!",
               ch,
               NULL,
               vch,
               TO_NOTVICT
            );
            DAZE_STATE(vch, 20);
         }
         dam = number_range(150, 250);
         dam += ch->size * 2;
         damage(ch, vch, dam, gsn_wind_shear, DAM_BASH, TRUE);


      }
      check_improve(ch, gsn_wind_shear, TRUE, 1);
   }
   else
   {
      send_to_char
      (
         "You flap your wings and create a pleasant breeze.\n\r",
         ch
      );
      act
      (
         "$n flaps $s wings and creates a pleasant breeze.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      check_improve(ch, gsn_wind_shear, FALSE, 1);
   }
   WAIT_STATE(ch, 12);
   return;
}

void do_purify(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   int chance;
   sh_int dex_diff;
   char buf[MAX_STRING_LENGTH];
   AFFECT_DATA* paf;

   if
   (
      (
         chance = get_skill(ch, gsn_purity)
      ) <= 0 ||
      !has_skill(ch, gsn_purity)
   )
   {
      send_to_char("Huh?\n\r",ch);
      return;
   }

   if (house_down(ch, HOUSE_CRUSADER))
   {
      return;
   }

   if
   (
      (
         (
            ch->hit * 100
         ) / ch->max_hit
      ) > 90
   )
   {
      send_to_char
      (
         "You are not bleeding enough to be able to make a mark of purity.\n\r",
         ch
      );
      return;
   }

   one_argument(argument, arg);
   if
   (
      arg[0] == '\0'
   )
   {
      victim = ch->fighting;
      if
      (
         victim == NULL
      )
      {
         send_to_char("Attempt to mark who with your blood?\n\r", ch);
         return;
      }
   }
   else if
   (
      (
         victim = get_char_room(ch, arg)
      ) == NULL
   )
   {
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if
   (
      check_peace(ch) ||
      is_safe(ch, victim, 0)
   )
   {
      return;
   }

   if (victim == ch)
   {
      send_to_char
      (
         "You do some finger painting on yourself with your blood.\n\r",
         ch
      );
      return;
   }

   if (is_affected(victim, gsn_purity))
   {
      send_to_char("They are already marked with a mark of purity!\n\r", ch);
      return;
   }
   if
   (
      IS_AFFECTED(ch, AFF_CHARM) &&
      ch->master == victim
   )
   {
      act
      (
         "But $N is such a good friend!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      return;
   }

   WAIT_STATE(ch, skill_table[gsn_purity].beats);
   if (oblivion_blink(ch, victim))
   {
      return;
   }

   /* modifiers */
   dex_diff = get_curr_stat(ch, STAT_DEX) - get_curr_stat(victim, STAT_DEX);
   /* dexterity */
   if (dex_diff < 0)
   {
      chance += dex_diff * 2;
   }
   else if (dex_diff > 0)
   {
      chance += dex_diff;
   }
   /* haste */
   if
   (
      IS_AFFECTED(ch, AFF_HASTE) ||
      (
         IS_SET(ch->off_flags, OFF_FAST) &&
         !IS_AFFECTED(ch, AFF_SLOW)
      )
   )
   {
      chance += 10;
   }
   if
   (
      IS_AFFECTED(victim, AFF_HASTE) ||
      (
         IS_SET(victim->off_flags, OFF_FAST) &&
         !IS_AFFECTED(victim, AFF_SLOW)
      )
   )
   {
      chance -= 15;
   }
   /* level */
   chance += (ch->drain_level + ch->level - victim->level - victim->drain_level) * 2;
   /* Min 30% chance of working, max 90% chance of working */
   chance = URANGE(30, chance, 90);
   /* now the attack */

   if (number_percent() <= chance)
   {
      /* Prevent immune mobs from being affected */
      check_improve(ch, gsn_purity, TRUE, 2);
      if
      (
         IS_NPC(victim) &&
         check_immune(victim, DAM_OTHER) == IS_IMMUNE
      )
      {
         act
         (
            "Your mark of purity does nothing to $N!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "$N is unaffected by $n's bloody strike!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         return;
      }
      act
      (
         "$n strikes $N with a bloody hand!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      act
      (
         "$n strikes you with a bloody hand!",
         ch,
         NULL,
         victim,
         TO_VICT
      );

      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(victim) &&
         (
            (victim->fighting == NULL) ||
            (ch->fighting == NULL)
         )
      )
      {
         sprintf
         (
            buf,
            "Help!  %s is striking me with a bloody hand!",
            PERS(ch, victim)
         );
         do_myell(victim, buf);
         sprintf
         (
            log_buf,
            "[%s] used mark of purity on [%s] at %d",
            ch->name,
            victim->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
      }

      damage
      (
         ch,
         victim,
         number_range(10, 30),
         gsn_purity,
         DAM_OTHER,
         TRUE
      );

      if (number_percent() < 85)
      {
         paf = new_affect();
         paf->where        = TO_AFFECTS;
         paf->type         = gsn_purity;
         paf->duration     = 1;
         paf->level        = ch->level + ch->drain_level;
         affect_to_char(victim, paf);
         free_affect(paf);

         act
         (
            "You smash $N hard and mark $M with your pure blood!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         if (is_clergy(victim))
         {
            send_to_char
            (
               "You are smashed to the ground and marked with a mark of purity!\n\r",
               victim
            );

            send_to_char
            (
               "You feel the blood on your body holding you to the earth.\n\r",
               victim
            );
         }
         else
         {
            send_to_char
            (
               "You are smashed to the ground and marked with a mark of purity!\n\r",
               victim
            );

            send_to_char
            (
               "You are marked with a bloody handprint and you feel your"
               " transportation magic nullified!\n\r",
               victim
            );
         }
         act
         (
            "$N is marked with a bloody mark of purity!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         if (victim->daze <= 0)
         {
            DAZE_STATE(victim, 24);
         }
      }
      return;
   }
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         victim->fighting == NULL ||
         ch->fighting == NULL
      )
   )
   {
      switch (number_range(0, 1))
      {
         default:  /* 0 */
         {
            sprintf
            (
               buf,
               "Help! %s just tried to strike me with a bloody hand!",
               PERS(ch, victim)
            );
            break;
         }
         case (1):
         {
            sprintf
            (
               buf,
               "Die, %s you gory fool!",
               PERS(ch, victim)
            );
            break;
         }
      }
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used mark of purity on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   damage(ch, victim, 0, gsn_purity, DAM_OTHER, TRUE);
   check_improve(ch, gsn_purity, FALSE, 2);
}

void check_cysts(CHAR_DATA* ch, CHAR_DATA* victim)
{
   AFFECT_DATA* paf;
   int dam;
   int level;
   int reduce;
   int dam_type = -1;
   bool plague;
   bool poison;
   bool pierce;
   bool crusader;

   if
   (
      ch == NULL ||
      victim == NULL ||
      !check_room(ch, FALSE, NULL) ||
      !check_room(victim, FALSE, NULL) ||
      ch->in_room != victim->in_room ||
      (
         paf = affect_find(victim->affected, gsn_virulent_cysts)
      ) == NULL
   )
   {
      return;
   }
   level = paf->level;
   if (check_immune(ch, DAM_DISEASE) == IS_IMMUNE)
   {
      plague = FALSE;
   }
   else
   {
      plague = TRUE;
   }
   if (check_immune(ch, DAM_POISON) == IS_IMMUNE)
   {
      poison = FALSE;
   }
   else
   {
      poison = TRUE;
   }
   if (check_immune(ch, DAM_PIERCE) == IS_IMMUNE)
   {
      pierce = FALSE;
   }
   else
   {
      pierce = TRUE;
   }
   if
   (
      !plague &&
      !poison &&
      !pierce
   )
   {
      /* Immune to all */
      return;
   }
   while (dam_type == -1)
   {
      switch (number_range(0, 2))
      {
         default:
         {
            if (plague)
            {
               dam_type = DAM_DISEASE;
            }
            break;
         }
         case (1):
         {
            if (poison)
            {
               dam_type = DAM_POISON;
            }
            break;
         }
         case (2):
         {
            if (pierce)
            {
               dam_type = DAM_PIERCE;
            }
            break;
         }
      }
   }
   if
   (
      IS_NPC(ch) &&
      ch->pIndexData->vnum == MOB_VNUM_CRUSADER
   )
   {
      crusader = TRUE;
   }
   else
   {
      crusader = FALSE;
   }
   if (check_spellcraft(victim, gsn_virulent_cysts))
   {
      dam = spellcraft_dam(2, level);
   }
   else
   {
      dam = dice(2, level);
   }
   dam += 30;  /* Up damage a little */
   if (dam_type == DAM_PIERCE)
   {
      dam += dam * number_percent() / 100;
   }
   switch (dam_type)
   {
      default:
      {
         break;
      }
      case (DAM_DISEASE):
      {
         act
         (
            "Virulent cysts surrounding $n explode, covering $N with maggots!",
            victim,
            NULL,
            ch,
            TO_NOTVICT
         );
         act
         (
            "Virulent cysts surrounding $n explode, covering you with maggots!",
            victim,
            NULL,
            ch,
            TO_VICT
         );
         act
         (
            "The virulent cysts surrounding you explode, covering $N with maggots!",
            victim,
            NULL,
            ch,
            TO_CHAR
         );
         if (number_bits(2) == 0)
         {
            act
            (
               "$n is covered in pus!",
               ch,
               NULL,
               NULL,
               TO_ROOM
            );
            act
            (
               "You are covered in pus!",
               ch,
               NULL,
               NULL,
               TO_CHAR
            );
            dam += dam / 10;
         }
         if
         (
            number_bits(2) == 0 &&
            !crusader
         )
         {
            magic_spell_vict
            (
               victim,
               ch,
               CAST_BITS_PLR_SKILL,
               level + (2 * number_range(0, 4)),
               gsn_plague
            );
         }
         break;
      }
      case (DAM_POISON):
      {
         act
         (
            "Virulent cysts surrounding $n explode, covering $N with slime!",
            victim,
            NULL,
            ch,
            TO_NOTVICT
         );
         act
         (
            "Virulent cysts surrounding $n explode, covering you with slime!",
            victim,
            NULL,
            ch,
            TO_VICT
         );
         act
         (
            "The virulent cysts surrounding you explode, covering $N with slime!",
            victim,
            NULL,
            ch,
            TO_CHAR
         );
         if
         (
            number_bits(2) == 0 ||
            number_bits(4) == 0
         )
         {
            act
            (
               "$n is covered in sticky goo!",
               ch,
               NULL,
               NULL,
               TO_ROOM
            );
            act
            (
               "You are covered in sticky goo!",
               ch,
               NULL,
               NULL,
               TO_CHAR
            );
            dam += dam / 15;
         }
         if
         (
            number_bits(2) == 0 &&
            !crusader
         )
         {
            magic_spell_vict
            (
               victim,
               ch,
               CAST_BITS_PLR_SKILL,
               level + 2 * number_range(0, 4),
               gsn_poison
            );
         }
         break;
      }
      case (DAM_PIERCE):
      {
         act
         (
            "Virulent cysts surrounding $n shatter and impale $N!",
            victim,
            NULL,
            ch,
            TO_NOTVICT
         );
         act
         (
            "Virulent cysts surrounding $n shatter and impale you!",
            victim,
            NULL,
            ch,
            TO_VICT
         );
         act
         (
            "The virulent cysts surrounding you shatter and impale $N!",
            victim,
            NULL,
            ch,
            TO_CHAR
         );
         if (number_bits(1))
         {
            if (number_bits(3) == 0)
            {
               dam *= 2;
            }
            else
            {
               dam += dam / 10;
            }
         }
         break;
      }
   }
   damage(victim, ch, dam, gsn_virulent_cysts, dam_type, TRUE);
   if (!victim->valid)
   {
      /* If died.. */
      return;
   }
   reduce = number_bits(4);
   reduce = URANGE(5, reduce, 9);
   paf->level *= reduce;
   paf->level /= 10;
   if (paf->level <= 1)
   {
      send_to_char(get_herb_spell_name(paf, FALSE, 0), victim);
      send_to_char("\n\r", victim);
      affect_strip(victim, gsn_virulent_cysts);
   }
}

void do_psistorm(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   int dam;
   int chance;
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];

   one_argument(argument, buf);
   if
   (
      !has_skill(ch, gsn_psistorm) ||
      (
         chance = get_skill(ch, gsn_psistorm)
      ) <= 0
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   if (check_peace(ch))
   {
      return;
   }
   dam = number_range(135, 175);
   if
   (
      (
         ch->fighting == NULL &&
         buf[0] == '\0'
      ) ||
      !str_cmp(buf, "all")
   )
   {
      /*
      If not in combat and untargetted (or using the all argument)
      This will be a normal area attack
      */
      /*
      do a skill check
      Number percent is never more than a 100
      chance is max 100
      if chance is 100, this will never fail.
      */
      if (number_percent() > chance)
      {
         /* Emote failure */
         send_to_char
         (
            "You attempt to hurl psychic lightning from your wings but all you"
            " get are sparks.\n\r",
            ch
         );
         act
         (
            "$n's wings spark and sputter.",
            ch,
            NULL,
            NULL,
            TO_ROOM
         );
         /*
         Check improvement on failure
         difficulty 1.  (0 does not work)
         higher number makes it harder to learn
         */
         check_improve
         (
            ch,
            gsn_psistorm,
            FALSE,
            1
         );
         /* Put lag on.  (every exit must have lag) */
         WAIT_STATE
         (
            ch,
            skill_table[gsn_psistorm].beats
         );
         return;
      }
      /* If we failed, we 'return'd.. so now success */
      send_to_char
      (
         "You strafe the room with your wings, unleashing psychic lightning"
         " everywhere!\n\r",
         ch
      );
      act
      (
         "$n's wings strafe the room, sending psychic lightning everywhere!",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      /* Normal area attack, loop through everyone in the room. */
      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         /*
         Use a temporary variable for the next person
         in case this one flees (moves to another room) or dies
         */
         vch_next = vch->next_in_room;
         if
         (
            /* Skip anyone in your group */
            is_same_group(vch, ch) ||
            /* Skip anyone who is protected by gods from you. */
            is_safe
            (
               ch,
               vch,
               IS_SAFE_SILENT |
               IS_SAFE_AREA_ATTACK
            )
         )
         {
            continue;
         }
         if
         (
            /*
            Skip wraith form or air elementals,
            they are made of lightning,
            but give an emote
            */
            (
               has_skill(vch, gsn_wraithform) &&
               get_skill(vch, gsn_wraithform) >= 75
            ) ||
            (
               IS_NPC(vch) &&
               vch->pIndexData->vnum == MOB_VNUM_AIR_ELEMENTAL
            )
         )
         {
            act
            (
               "$n seems amused by the storm.",
               vch,
               NULL,
               NULL,
               TO_ROOM
            );
            continue;
         }
         /* Yells and logs.  Only for PC-PC combat */
         if
         (
            !IS_NPC(ch) &&
            !IS_NPC(vch) &&
            (
               ch->fighting == NULL ||
               vch->fighting == NULL
            )
         )
         {
            switch(number_range(0, 1))
            {
               case (0):
               {
                  sprintf
                  (
                     buf,
                     "Argh, %s just unleashed a psi storm!",
                     PERS(ch, vch)
                  );
                  break;
               }
               default:  /* (1) */
               {
                  sprintf
                  (
                     buf,
                     "Help! I am being attacked by %s!",
                     PERS(ch, vch)
                  );
                  break;
               }
            }
            /*
            We already removed anyone in our group,
            so we know we are not yelling here ourselves.
            no need for a
            vch != ch
            check
            */
            do_myell(vch, buf);
            sprintf
            (
               log_buf,
               "[%s] used psi storm (area) on [%s] at %d",
               ch->name,
               vch->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
         }
         if
         (
            (
               is_affected(vch, gsn_fly) ||
               is_affected(vch, gsn_mass_fly)
            ) &&
            !saves_spell(ch, ch->level,vch, DAM_OTHER, SAVE_SPELL)
         )
         {
            act
            (
               "$n is thrown wildly to the ground by the psychic lightning!",
               vch,
               NULL,
               NULL,
               TO_ROOM
            );
            send_to_char("You are thrown down by the psychic lightning!\n\r", vch);
            affect_strip(vch, gsn_fly);
            affect_strip(vch, gsn_mass_fly);
         }
         damage
         (
            ch,
            vch,
            dam,
            gsn_psistorm,
            DAM_OTHER,
            TRUE
         );
      }
      /* Out of the loop.  Done with normal area */
      /*
      Check improvement on success
      difficulty 1.  (0 does not work)
      higher number makes it harder to learn
      */
      check_improve
      (
         ch,
         gsn_psistorm,
         TRUE,
         1
      );
      /* Put lag on.  (every exit must have lag) */
      WAIT_STATE
      (
         ch,
         skill_table[gsn_psistorm].beats
      );
      return;
   }
   if (buf[0] == '\0')
   {
      victim = ch->fighting;
   }
   else
   {
      victim = get_char_room(ch, buf);
   }
   if (victim == NULL)
   {
      /*
      Didn't find the person you were looking for
      Only happens if you target someone not there
      */
      send_to_char("They are not here.\n\r", ch);
      return;
   }
   if (victim == ch)
   {
      /* Don't do anything to yourself. */
      send_to_char
      (
         "Your wingtips spark and you give yourself a little jolt.\n\r",
         ch
      );
      return;
   }
   if (number_percent() > chance)
   {
      /*
      Failed. 100% skill never gets in here
      max of numberpercent is 100, chance can be 100
      100 ! > 100
      */
      send_to_char
      (
         "You attempt to hurl psychic lightning from your wings but all you get"
         " are sparks.\n\r",
         ch
      );
      act
      (
         "$n's wings spark and sputter.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      /*
      Check improvement on failure
      difficulty 1.  (0 does not work)
      higher number makes it harder to learn
      */
      check_improve
      (
         ch,
         gsn_psistorm,
         FALSE,
         1
      );
      /* Put lag on.  (every exit must have lag) */
      WAIT_STATE
      (
         ch,
         skill_table[gsn_psistorm].beats
      );
      return;
   }
   send_to_char
   (
      "You flap your wings forward and unleash lightning from the feather tips!"
      "\n\r",
      ch
   );
   act
   (
      "$n's wings flap forward and lightning roars out from the feather tips!",
      ch,
      NULL,
      NULL,
      TO_ROOM
   );
   /* Swing-type area */
   for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
   {
      vch_next = vch->next_in_room;
      if
      (
         /* Skip anyone not in victim's group (like swing) */
         !is_same_group(vch, victim) ||
         /* Skip anyone who is protected by gods from you. */
         is_safe
         (
            ch,
            vch,
            IS_SAFE_SILENT |
            IS_SAFE_AREA_ATTACK
         )
      )
      {
         continue;
      }
      if
      (
         /*
         Skip wraith form or air elementals,
         they are made of lightning,
         but give an emote
         */
         (
            has_skill(vch, gsn_wraithform) &&
            get_skill(vch, gsn_wraithform) >= 75
         ) ||
         (
            IS_NPC(vch) &&
            vch->pIndexData->vnum == MOB_VNUM_AIR_ELEMENTAL
         )
      )
      {
         act
         (
            "$n seems amused by the storm.",
            vch,
            NULL,
            NULL,
            TO_ROOM
         );
         continue;
      }
      /* Yells and logs.  Only for PC-PC combat */
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(vch) &&
         (
            ch->fighting == NULL ||
            vch->fighting == NULL
         )
      )
      {
         switch(number_range(0, 1))
         {
            case (0):
            {
               sprintf
               (
                  buf,
                  "Argh, %s just unleashed a psi storm!",
                  PERS(ch, vch)
               );
               break;
            }
            default:  /* (1) */
            {
               sprintf
               (
                  buf,
                  "Help! I am being attacked by %s!",
                  PERS(ch, vch)
               );
               break;
            }
         }
         /*
         We already removed anyone in our group,
         so we know we are not yelling here ourselves.
         no need for a
         vch != ch
         check
         */
         do_myell(vch, buf);
         sprintf
         (
            log_buf,
            "[%s] used psi storm on [%s] at %d",
            ch->name,
            vch->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
      }
      if
      (
         (
            is_affected(vch, gsn_fly) ||
            is_affected(vch, gsn_mass_fly)
         ) &&
         !saves_spell
         (
            ch,
            ch->level,
            vch,
            DAM_OTHER,
            SAVE_SPELL
         )
      )
      {
         act
         (
            "$n is thrown to the ground by the psychic lightning!",
            vch,
            NULL,
            NULL,
            TO_ROOM
         );
         send_to_char("You are thrown down by the psychic lightning!\n\r", vch);
         affect_strip(vch, gsn_fly);
         affect_strip(vch, gsn_mass_fly);
      }
      damage
      (
         ch,
         vch,
         dam,
         gsn_psistorm,
         DAM_OTHER,
         TRUE
      );
   }
   /*
   Check improvement on success
   difficulty 1.  (0 does not work)
   higher number makes it harder to learn
   */
   check_improve
   (
      ch,
      gsn_psistorm,
      TRUE,
      1
   );
   /* Put lag on.  (every exit must have lag) */
   WAIT_STATE
   (
      ch,
      skill_table[gsn_psistorm].beats
   );
   return;
}

void do_jdancestaves(CHAR_DATA* ch, char* argument)
{
   OBJ_DATA* wield;
   OBJ_DATA* dwield;
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   int startoff = FALSE;
   int chance;
   int dam;
   AFFECT_DATA af;
   char buf[MAX_STRING_LENGTH];

   if
   (
      IS_NPC(ch) ||
      check_peace(ch)
   )
   {
      return;
   }

   if
   (
      (chance = get_skill(ch, gsn_dancestaves)) <= 0 ||
      !has_skill(ch, gsn_dancestaves)
   )
   {
      check_social(ch, "dance", argument);
      return;
   }

   wield = get_eq_char(ch, WEAR_WIELD);
   dwield = get_eq_char(ch, WEAR_DUAL_WIELD);
   if
   (
      (
         (wield == NULL) ||
         (wield->value[0] != WEAPON_STAFF)
      )  ||
      (
         (dwield == NULL) ||
         (dwield->value[0] != WEAPON_STAFF)
      )
   )
   {
      send_to_char("You must be wielding two staves to perform a dance of staves.\n\r",
      ch);
      return;
   }
   /* Now for the attack itself */
   if
   (
      number_percent() < chance
   )
   {
      send_to_char
      (
         "You launch into a deadly dance of staves!\n\r",
         ch
      );
      act
      (
         "$n launches into a deadly dance of staves!",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );

      if (ch->fighting == NULL)
      {
         startoff = TRUE;
      }

      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         vch_next = vch->next_in_room;
         chance = number_percent();
         if
         (
            vch->fighting != ch &&
            (
               is_same_group(ch, vch) ||
               is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK)
            )
         )
         {
            continue;
         }

         if
         (
            !startoff &&
            vch->fighting != ch
         )
         {
            continue;
         }

         if
         (
            vch != ch &&
            !IS_NPC(ch) &&
            !IS_NPC(vch) &&
            (
               ch->fighting == NULL ||
               vch->fighting == NULL
            )
         )
         {
            switch(number_range(0, 2))
            {
               case (0):
               {
                  sprintf
                  (
                     buf,
                     "Argh, %s is attacking with a dance of staves!",
                     PERS(ch, vch)
                  );
                  break;
               }
               default:  /* 1, 2 */
               {
                  sprintf
                  (
                     buf,
                     "Help! %s just attacked me!",
                     PERS(ch, vch)
                  );
                  break;
               }
            }
            do_myell(vch, buf);
            sprintf
            (
               log_buf,
               "[%s] used dance of staves on [%s] at %d",
               ch->name,
               vch->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
         }
         /* the confusion */
         if
         (
            (number_percent() < chance / 2)
         )
         {
            act
            (
               "Your dance of staves has left them disoriented!",
               ch,
               NULL,
               vch,
               TO_CHAR
            );
            act
            (
               "$n's dance of staves has left you disoriented!",
               ch,
               NULL,
               vch,
               TO_VICT
            );
            act
            (
               "$n's dance of staves has left $N disoriented!",
               ch,
               NULL,
               vch,
               TO_NOTVICT
            );

            af.where = TO_AFFECTS;
            af.type = gsn_dancestaves;
            af.location = 0;
            af.bitvector = 0;
            af.duration = 3;
            af.modifier = 0;
            af.level = ch->level;
            affect_to_char(vch, &af);
         }
         dam = number_range(160, 290);
         dam += ch->size * 2;
         damage(ch, vch, dam, gsn_dancestaves, DAM_BASH, TRUE);


      }
      check_improve(ch, gsn_dancestaves, TRUE, 1);
   }
   else
   {
      send_to_char
      (
         "You twirl your staves around your head and look silly.\n\r",
         ch
      );
      act
      (
         "$n twirls $s staves around and looks silly.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      check_improve(ch, gsn_dancestaves, FALSE, 1);
   }
   WAIT_STATE(ch, skill_table[gsn_dancestaves].beats);
   return;
}

void do_acidfire(CHAR_DATA* ch, char* argument)
{
   int dam;
   int chance;
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA af;
   AFFECT_DATA* paf;
   if
   (
      (chance = get_skill(ch, gsn_acidfire)) <= 0 ||
      !has_skill(ch, gsn_acidfire)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   argument = one_argument(argument,arg);
   if (arg[0] == '\0')
   {
       victim = ch->fighting;
       if (victim == NULL)
       {
          send_to_char("But you are not fighting anyone!\n\r", ch);
          return;
       }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }
   if (check_peace(ch) || is_safe(ch, victim, 0))
   {
      return;
   }
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, skill_table[gsn_acidfire].beats);
      send_to_char("You fail to spew flaming acid.\n\r", ch);
      check_improve(ch, gsn_acidfire, FALSE, 1);
      return;
   }
   if (victim == ch)
   {
       send_to_char("What, and get yourself all dirty and smelly?\n\r", ch);
       return;  /* Added by Fizzy */
   }
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   {
      sprintf(buf, "Help! %s is spewing flaming acid at me!", PERS(ch, victim));
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used acidfire on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }
   /* the damage */
   act
   (
      "You puff out your chest and inhale deeply.\n\r"
      "You exhale violently and spew flaming acid all over $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n puffs out $s chest and inhales deeply.\n\r"
      "$n exhales violently and spews flaming acid all over you!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n puffs out $s chest and inhales deeply.\n\r"
      "$n exhales violently and spews flaming acid all over $N!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   if (number_percent() < chance / 2)
   {
      paf = victim->affected;
      while (paf) /* fizz segment */
      {
         /*
            Find the weaken affect if
            it exists.
         */
         if
         (
            paf->type == gsn_acidfire &&
            paf->bitvector == AFF_WEAKEN
         )
         {
            break;
         }
         paf = paf->next;
      }
      if (paf == NULL)  /* fizz segment */
      {
         /* Did NOT find a weaken effect */
         af.where = TO_AFFECTS;
         af.type = gsn_acidfire;
         af.location = APPLY_STR;
         af.duration = ((ch->drain_level + ch->level)/5);
         af.bitvector = AFF_WEAKEN;
         af.modifier = -3;
         af.level = ch->drain_level + ch->level;
         affect_to_char(victim, &af);

         act /* fizzy fixed order, want everyone but victim to see */
         ( /* $s instead of 'their' */
            "The flaming acid sears $n and atrophies $s muscles!\n\r"
            "$n appears to be weakened from the flaming acid!",
            victim,
            NULL,
            NULL,
            TO_ROOM
         );
         send_to_char
         (
            "Flaming acid sears your muscles!\n\r",
            victim
         );
      }
   }
   if
   (
      !IS_AFFECTED(victim, AFF_BLIND) && /* fizzy */
      number_percent() < chance / 2
   )
   {
      af.where = TO_AFFECTS;
      af.type = gsn_acidfire;
      af.level = ch->drain_level + ch->level;
      af.duration = (ch->drain_level + ch->level)/5;
      af.bitvector = AFF_BLIND;
      af.location = APPLY_HIT;
      af.modifier = -3;
      affect_to_char(victim, &af);

      act /* fizzy fixed order. Want everyone but victim to see */
      (
         "Flaming acid gets into $n's eyes!\n\r"
         "$n appears to be blinded!",
         victim,
         NULL,
         NULL,
         TO_ROOM
      );
      send_to_char /* fizzy */
      (
         "Flaming acid gets into your eyes!\n\r",
         victim
      );
   }
   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   damage(ch, victim, dam, gsn_acidfire, DAM_OTHER, TRUE);
   check_improve(ch, gsn_acidfire, TRUE, 1);
   WAIT_STATE(ch, skill_table[gsn_acidfire].beats);
   return;
}

void do_devour(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA *victim;
   ROOM_INDEX_DATA* room = get_room_index(ROOM_VNUM_THROAT);
   char buf[MAX_STRING_LENGTH];
   char arg[MAX_INPUT_LENGTH];
   int chance;

   /* make sure you have the skill */
   if
   (
      (chance = get_skill(ch, gsn_devour)) <= 0 ||
      !has_skill(ch, gsn_devour)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   if (room == NULL)
   {
      send_to_char("BUG: Room does not exist.\n\r", ch);
      bug("do_devour: room %d does not exist.", ROOM_VNUM_BATHROOM);
      return;
   }
   if (check_peace(ch))
   {
      return;
   }

   /* allows use of arguments (like targetting) */
   argument = one_argument(argument, arg);

   if (arg[0] == '\0')
   {
      /* no target, nothing happens */
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (get_trust(ch) <= get_trust(victim))
   {
      send_to_char("You cannot devour that divine being.\n\r", ch);
      return;
   }

   sprintf
   (
      buf,
      "Help! %s is devouring me!",
      PERS(ch, NULL)
   );
   do_myell(victim, buf);


   act
   (
      "You open your jaws wide and devour $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n opens $s jaws wide and devours you!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n opens $s jaws wide and devours $N!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );


/* Here is the actual transferring.  You only want to move the victim, and only the victim should look */
   char_from_room(victim);
   char_to_room(victim, room);
   send_to_char("You have been swallowed!\n\r", victim);

   act
   (
      "You have swallowed $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );

   do_observe(victim, "", LOOK_AUTO);
   DAZE_STATE(victim, 24);
   WAIT_STATE(ch, skill_table[gsn_devour].beats);
   return;
}

void do_carebearstare(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];
   int dam;
   int chance;

   /* make sure you have the skill */
   if
   (
      (chance = get_skill(ch, gsn_carebearstare)) <= 0 ||
      !has_skill(ch, gsn_carebearstare)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   /* allows use of arguments (like targetting) */
   argument = one_argument(argument, arg);

   /* Use whoever you are fighting as default target */
   if (arg[0] == '\0')
   {
      /* no target, nothing happens */
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (check_peace(ch) || is_safe(ch, victim, 0))
   {
      return;
   }


   if (victim == ch)
   {
      send_to_char
      (
         "You lift your shirt up...and people laugh at you.\n\r",
         ch
      );
      act
      (
         "$n lifts $m shirt up for apparently no real reason.  Laugh at $n.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      return;
   }

   /* fail and lag */
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, 12);
      send_to_char
      (
         "You lift your shirt up and push really hard...but wind up passing gas.\n\r",
         ch
      );
      act
      (
         "$n lifts up $s shirt and pushes really hard...but all $e does is pass gas!",
         ch,
         NULL,
         victim,
         TO_ROOM
      );
      check_improve(ch, gsn_carebearstare, FALSE, 1);
      return;
   }
   /* If this is a player (initiating combat) with another player, yell and log */
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   {
      sprintf(buf, "Help! %s is attacking me with a beam of belly light!", PERS(ch, victim));
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used carebearstare on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   /* the damage */
   do_say(ch, "Care Bear stare!");
   act
   (
      "You lift up your shirt and a beam of white light blasts forth from your tummy at $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n lifts up $s shirt and a beam of white light blasts forth from $s tummy at you!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n lifts up $s shirt and a beam of white light blasts forth from $s tummy at $N!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );


   /* the bash */
   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your beam of light knocks $N onto $S backside!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's beam of light knocks you onto your backside!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's beam of light knocks $N onto $S backside!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }

   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   damage(ch, victim, dam, gsn_carebearstare, DAM_OTHER, TRUE);

   check_improve(ch, gsn_carebearstare, TRUE, 1);
   WAIT_STATE(ch, 18);
   return;
}

void do_krazyeyes(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];
   int dam;
   int chance;

   /* make sure you have the skill */
   if
   (
      (chance = get_skill(ch, gsn_krazyeyes)) <= 0 ||
      !has_skill(ch, gsn_krazyeyes)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   /* allows use of arguments (like targetting) */
   argument = one_argument(argument, arg);

   /* Use whoever you are fighting as default target */
   if (arg[0] == '\0')
   {
      /* no target, nothing happens */
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (check_peace(ch) || is_safe(ch, victim, 0))
   {
      return;
   }


   if (victim == ch)
   {
      send_to_char
      (
         "You go crosseyed trying to glare at yourself.\n\r",
         ch
      );
      act
      (
         "$n goes crosseyed trying to glare at $mself.\n\r",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      return;
   }

   /* fail and lag */
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, 12);
      send_to_char
      (
         "You glare and glare but nothing happens.\n\r",
         ch
      );
      act
      (
         "$n glares and glares but nothing happens.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      check_improve(ch, gsn_krazyeyes, FALSE, 1);
      return;
   }
   /* If this is a player (initiating combat) with another player, yell and log */
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   {
      sprintf(buf, "Help! %s is attacking me bolts of energy!", PERS(ch, victim));
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used krazyeyes on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   /* the damage */
   act
   (
      "You glare at $N and bolts of energy lance forth from your eyes!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n glares at you and bolts of energy lance forth from $s eyes!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n glares at $N and bolts of energy lance forth from $s eyes!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );

   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your bolts of energy knock $N to the ground!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's bolts of energy knock you to the ground!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's bolts of energy knock $N to the ground!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }
   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   damage(ch, victim, dam, gsn_krazyeyes, DAM_OTHER, TRUE);


   check_improve(ch, gsn_krazyeyes, TRUE, 1);
   WAIT_STATE(ch, 18);
   return;
}

void do_sonic_belch(CHAR_DATA* ch, char* argument)
{
   int dam;
   int chance;
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA* paf;
   if
   (
      (chance = get_skill(ch, gsn_sonicbelch)) <= 0 ||
      !has_skill(ch, gsn_sonicbelch)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   argument = one_argument(argument,arg);
   if (arg[0] == '\0')
   {
       victim = ch->fighting;
       if (victim == NULL)
       {
          send_to_char("But you are not fighting anyone!\n\r", ch);
          return;
       }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }
   if (check_peace(ch) || is_safe(ch, victim, 0))
   {
      return;
   }
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, skill_table[gsn_sonicbelch].beats);
      send_to_char("You fail to emit a sonic belch.\n\r", ch);
      check_improve(ch, gsn_sonicbelch, FALSE, 1);
      return;
   }
   if (victim == ch)
   {
       send_to_char("You belch at yourself.  You are so easily amused.\n\r", ch);
       return;
   }
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   /* the damage */
   act
   (
      "You take a long pull of vodka moo, causing a weird rumbling in your stomach.\n\r"
      "You lean forward and unleash a deafening belch in $N's direction!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n takes a long pull of vodka moo, causing a weird rumbling in $s stomach.\n\r"
      "$n leans forward and unleashes a deafening belch in your direction!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n takes a long pull of vodka moo, causing a weird rumbling in $s stomach.\n\r"
      "$n leans forward and unleashes a deafening belch in $N's direction!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   {
      sprintf(buf, "Help! %s is belching at me!", PERS(ch, victim));
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used sonic belch on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

/* the bash */
   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your deafening belch knocks $N to the ground!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's deafening belch knocks you to the ground!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's deafening belch knocks $N to the ground!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }

   if (number_percent() < chance / 2)
   {
      paf = victim->affected;
      while (paf)
      {
         /*
            Find the poison affect if
            it exists.
         */
         if
         (
            paf->type == gsn_sonicbelch &&
            paf->bitvector == AFF_POISON
         )
         {
            break;
         }
         paf = paf->next;
      }
      if (paf == NULL)
      {
         AFFECT_DATA af;
         AFFECT_DATA *af2;
         send_to_char("You feel sick and nauseated from the foul alcohol breath.\n\r", victim);
         af.where = TO_AFFECTS;
         af.type = gsn_sonicbelch;
         af.level = ch->drain_level + ch->level;
         af.duration = (ch->drain_level + ch->level)/5;
         af.bitvector = AFF_POISON;
         af.location = APPLY_STR;
         af.modifier = -3;
         affect_join(victim, &af, 10);
         af2 = affect_find(victim->affected, gsn_poison);

         act
         (
            "$n's face gets all distorted and sickly from the nasty belch!",
            victim,
            NULL,
            NULL,
            TO_NOTVICT
         );
      }
   }

   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   damage(ch, victim, dam, gsn_sonicbelch, DAM_OTHER, TRUE);
   check_improve(ch, gsn_sonicbelch, TRUE, 1);
   WAIT_STATE(ch, skill_table[gsn_sonicbelch].beats);
   return;
}

void do_troll_fart(CHAR_DATA* ch, char* argument)
{
   int dam;
   int chance;
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];
   char arg[MAX_INPUT_LENGTH];
   AFFECT_DATA af;
   AFFECT_DATA* paf;
   if
   (
      (chance = get_skill(ch, gsn_trollfart)) <= 0 ||
      !has_skill(ch, gsn_trollfart)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   argument = one_argument(argument,arg);
   if (arg[0] == '\0')
   {
       victim = ch->fighting;
       if (victim == NULL)
       {
          send_to_char("But you are not fighting anyone!\n\r", ch);
          return;
       }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }
   if (check_peace(ch) || is_safe(ch, victim, 0))
   {
      return;
   }
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, skill_table[gsn_trollfart].beats);
      send_to_char("You fail to harness the mighty power of a troll fart.\n\r", ch);
      check_improve(ch, gsn_trollfart, FALSE, 1);
      return;
   }
   if (victim == ch)
   {
       send_to_char("You make yourself stink with a smell only trolls can create.\n\r", ch);
       return;
   }
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   /* the damage */
   act
   (
      "You call on the mighty power of your trollish nature and build up some nasty gas!\n\r"
      "You turn around, bend over, and unleash a mighty troll fart at $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n calls on the mighty power of $s trollish nature and builds up some nasty gas!\n\r"
      "$n turns around, bends over, and unleashes a mighty troll fart at you!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n calls on the mighty power of $s trollish nature and builds up some nasty gas!\n\r"
      "$n turns around, bends over, and unleashes a mighty troll fart at $N!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   {
      sprintf(buf, "Help! %s is farting at me!", PERS(ch, victim));
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used troll fart on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

/* the bash */
   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your mighty fart knocks $N over!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's mighty fart knocks you over!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's mighty fart knocks $N over!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }

   if (number_percent() < chance / 2)
   {
      paf = victim->affected;
      while (paf)
      {
         /*
            Find the plague affect if
            it exists.
         */
         if
         (
            paf->type == gsn_trollfart &&
            paf->bitvector == AFF_PLAGUE
         )
         {
            break;
         }
         paf = paf->next;
      }
      if (paf == NULL)
      {
         af.where = TO_AFFECTS;
         af.type = gsn_trollfart;
         af.level = ch->drain_level + ch->level;
         af.duration = (ch->drain_level + ch->level)/5;
         af.bitvector = AFF_PLAGUE;
         af.location = APPLY_STR;
         af.modifier = -5;
         affect_to_char(victim, &af);

         act
          (
            "$n turns an unhealthy shade of green and $s eyes begin to water.",
            victim,
            NULL,
            NULL,
            TO_ROOM
         );
         send_to_char
         (
            "That disgusting troll fart is making you sick!\n\r",
            victim
         );
      }
   }

   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   damage(ch, victim, dam, gsn_trollfart, DAM_OTHER, TRUE);
   check_improve(ch, gsn_trollfart, TRUE, 1);
   WAIT_STATE(ch, skill_table[gsn_trollfart].beats);
   return;
}

void check_drinlinda_attack_brand(CHAR_DATA* ch, CHAR_DATA* victim)
{
   int dam;

   if (number_percent() > 8)
   {
      return;
   }
   switch(number_range(1,8))
   {
      case(1):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, twin swords poised to strike!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda slashes both of her swords across $N's face!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda slashes both of her swords across your face!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda slashes both of her swords across $N's face!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(2):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, twin swords poised to strike!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda stabs both of her swords into $N's torso!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda stabs both of her swords into your torso!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda stabs both of her swords into $N's torso!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(3):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, one sword poised to strike!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda rams its sword into $N's face!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda rams its sword into your face!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda stabs its sword into $N's face!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(4):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, one sword poised to strike!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda grabs her sword with both hands and chops down on $N's head!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda grabs the sword with both hands and chops down on your head!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda grabs the sword with both hands and chops down on $N's head!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(5):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, wings spread out!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda leans forward and folds her wings forward.\n\r"
            "$N is blasted with psychic lightning!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda leans forward and folds her wings forward.\n\r"
            "You are blasted with psychic lightning!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda leans forward and folds her wings forward.\n\r"
            "$N is blasted with psychic lightning!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(6):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, standing with her arms crossed beneath her chest!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda looks at $N and $E is slammed around telekinetically!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda looks at you and you are slammed around telekinetically!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda looks at $N and $E is slammed around telekinetically!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(7):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, twin swords poised to strike!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda brings both of her swords slashing down on $N's shoulders!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda brings both of her swords slashing down on your shoulders!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda brings both of her swords slashing down on $N's shoulders!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(8):
      {
         act
         (
            "A bunny marked, white rose wreathed shield flares brightly!\n\r"
            "An avatar of Drinlinda appears, twin swords poised to strike!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The avatar of Drinlinda brings both of her swords slashing across $N's neck!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The avatar of Drinlinda brings both of her swords slashing across your neck!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The avatar of Drinlinda brings both of her swords slashing across $N's neck!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         break;
      }
   }
   dam = ch->level*2;
   dam += number_range(0,30);
   damage
   (
      ch,
      victim,
      dam,
      gsn_drinlinda_attack_brand,
      DAM_OTHER,
      TRUE
   );
   act
   (
      "The avatar of Drinlinda disappears.",
      ch,
      NULL,
      NULL,
      TO_ALL
   );
}

/*
* Check for Drinlinda Shield of Innocence phasing.
*/
bool check_drinlinda_defense_brand(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;
   bool reflects = FALSE;
   int dam;

   if (!is_affected(victim, gsn_drinlinda_defense_brand))
   {
      return FALSE;
   }

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }

   chance = 6;

   if (number_percent() >= chance)
   {
      return FALSE;
   }

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch,WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }


   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In Drinlinda Shield of Innocence blocking, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }

   dam = ch->level*2;
   dam += number_range(0,30);

   switch(number_range(0,12))
   {
      case(1):
      {
         sprintf
         (
            buf1,
            "An avatar of Drinlinda appears before you and blocks $n's %s with her holy shield!",
            attack
         );
         sprintf
         (
            buf2,
            "An avatar of Drinlinda appears before $N and blocks your %s with her holy shield!",
            attack
         );
         sprintf
         (
            buf3,
            "An avatar of Drinlinda appears before $N and blocks $n's %s with her holy shield!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         reflects = TRUE;
         sprintf
         (
            buf1,
            "The avatar of Drinlinda bashes $n with her holy shield!"
         );
         sprintf
         (
            buf2,
            "The avatar of Drinlinda bashes you with her holy shield!"
         );
         sprintf
         (
            buf3,
            "The avatar of Drinlinda bashes $n with her holy shield!"
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         damage
         (
            victim,
            ch,
            dam,
            gsn_drinlinda_attack_brand,
            DAM_OTHER,
            TRUE
         );
         act
         (
            "The avatar of Drinlinda disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(2):
      {
         sprintf
         (
            buf1,
            "A bunny marked, white rose wreathed shield appears before you and blocks $n's %s!",
            attack
         );
         sprintf
         (
            buf2,
            "A bunny marked, white rose wreathed shield appears before $N and blocks your %s!",
            attack
         );
         sprintf
         (
            buf3,
            "A bunny marked, white rose wreathed shield appears before $N and blocks $n's %s!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The bunny marked, white rose wreathed shield disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(3):
      {
         sprintf
         (
            buf1,
            "An avatar of Drinlinda appears before you and parries $n's %s with her swords!",
            attack
         );
         sprintf
         (
            buf2,
            "An avatar of Drinlinda appears before $N and parries your %s with her swords!",
            attack
         );
         sprintf
         (
            buf3,
            "An avatar of Drinlinda appears before $N and parries $n's %s with her swords!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         reflects = TRUE;
         sprintf
         (
            buf1,
            "The avatar of Drinlinda counterattacks $n with her swords!"
         );
         sprintf
         (
            buf2,
            "The avatar of Drinlinda counterattacks you with her swords!"
         );
         sprintf
         (
            buf3,
            "The avatar of Drinlinda counterattacks $n with her swords!"
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         damage
         (
            victim,
            ch,
            dam,
            gsn_drinlinda_attack_brand,
            DAM_OTHER,
            TRUE
         );
         act
         (
            "The avatar of Drinlinda disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(4):
      {
         sprintf
         (
            buf1,
            "An avatar of Drinlinda appears before you and blocks $n's %s with her wings!",
            attack
         );
         sprintf
         (
            buf2,
            "An avatar of Drinlinda appears before $N and blocks your %s with her wings!",
            attack
         );
         sprintf
         (
            buf3,
            "An avatar of Drinlinda appears before $N and blocks $n's %s with her wings!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         reflects = TRUE;
         sprintf
         (
            buf1,
            "The avatar of Drinlinda unleashes psychic lightning at $n from her wings!"
         );
         sprintf
         (
            buf2,
            "The avatar of Drinlinda unleashes psychic lightning at you from her wings!"
         );
         sprintf
         (
            buf3,
            "The avatar of Drinlinda unleashes psychic lightning at $n from her wings!"
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         damage
         (
            victim,
            ch,
            dam,
            gsn_drinlinda_attack_brand,
            DAM_OTHER,
            TRUE
         );
         act
         (
            "The avatar of Drinlinda disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(5):
      {
         sprintf
         (
            buf1,
            "An avatar of Drinlinda appears before you and parries $n's %s with her wings!",
            attack
         );
         sprintf
         (
            buf2,
            "An avatar of Drinlinda appears before $N and parries your %s with her wings!",
            attack
         );
         sprintf
         (
            buf3,
            "An avatar of Drinlinda appears before $N and parries $n's %s with her wings!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The avatar of Drinlinda disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(6):
      {
         sprintf
         (
            buf1,
            "An avatar of Drinlinda appears before you and stops $n's %s with her hand!",
            attack
         );
         sprintf
         (
            buf2,
            "An avatar of Drinlinda appears before $N and stops your %s with her hand!",
            attack
         );
         sprintf
         (
            buf3,
            "An avatar of Drinlinda appears before $N and stops $n's %s with her wings!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The avatar of Drinlinda disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(7):
      {
         sprintf
         (
            buf1,
            "An avatar of Drinlinda appears before you and deflects $n's %s with a glance!",
            attack
         );
         sprintf
         (
            buf2,
            "An avatar of Drinlinda appears before $N and deflects your %s with a glance!",
            attack
         );
         sprintf
         (
            buf3,
            "An avatar of Drinlinda appears before $N and deflects $n's %s with a glance!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         reflects = TRUE;
         sprintf
         (
            buf1,
            "The avatar of Drinlinda slams $n around with a telekinetic assault!"
         );
         sprintf
         (
            buf2,
            "The avatar of Drinlinda slams you around with a telekinetic assault!"
         );
         sprintf
         (
            buf3,
            "The avatar of Drinlinda slams $n around with a telekinetic assault!"
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         damage
         (
            victim,
            ch,
            dam,
            gsn_drinlinda_attack_brand,
            DAM_OTHER,
            TRUE
         );
         act
         (
            "The avatar of Drinlinda disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(8):
      {
         sprintf
         (
            buf1,
            "An avatar of Drinlinda appears before you and takes $n's %s in the chest!",
            attack
         );
         sprintf
         (
            buf2,
            "An avatar of Drinlinda appears before $N and takes your %s in the chest!",
            attack
         );
         sprintf
         (
            buf3,
            "An avatar of Drinlinda appears before $N and takes $n's %s in the chest!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The avatar of Drinlinda disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(9):
      {
         sprintf
         (
            buf1,
            "A pair of crossed swords appear before you and parry $n's %s!",
            attack
         );
         sprintf
         (
            buf2,
            "A pair of crossed swords appear before $N and parry your %s!",
            attack
         );
         sprintf
         (
            buf3,
            "A pair of crossed swords appear before $N and parry $n's %s!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         reflects = TRUE;
         sprintf
         (
            buf1,
            "A pair of crossed swords slash at $n's head!"
         );
         sprintf
         (
            buf2,
            "A pair of crossed swords slash at your head!"
         );
         sprintf
         (
            buf3,
            "A pair of crossed swords slash at $n's head!"
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         damage
         (
            victim,
            ch,
            dam,
            gsn_drinlinda_attack_brand,
            DAM_OTHER,
            TRUE
         );
         act
         (
            "The pair of crossed swords disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(10):
      {
         sprintf
         (
            buf1,
            "A pair of crossed swords appear before you and block $n's %s!",
            attack
         );
         sprintf
         (
            buf2,
            "A pair of crossed swords appear before $N and block your %s!",
            attack
         );
         sprintf
         (
            buf3,
            "A pair of crossed swords appear before $N and block $n's %s!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         reflects = TRUE;
         sprintf
         (
            buf1,
            "A pair of crossed swords chop down at $n's head!"
         );
         sprintf
         (
            buf2,
            "A pair of crossed swords chop down at your head!"
         );
         sprintf
         (
            buf3,
            "A pair of crossed swords chop down at $n's head!"
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         damage
         (
            victim,
            ch,
            dam,
            gsn_drinlinda_attack_brand,
            DAM_OTHER,
            TRUE
         );
         act
         (
            "The pair of crossed swords disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(11):
      {
         sprintf
         (
            buf1,
            "A delicate, feminine drow hand appears before you and stops $n's %s!",
            attack
         );
         sprintf
         (
            buf2,
            "A delicate, feminine drow hand appears before $N and stops your %s!",
            attack
         );
         sprintf
         (
            buf3,
            "A delicate, feminine drow hand appears before $N and stops $n's %s!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The delicate, feminine drow hand disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(12):
      {
         sprintf
         (
            buf1,
            "An image of a cute bunny appears before you and stops $n's %s with her teeth!",
            attack
         );
         sprintf
         (
            buf2,
            "An image of a cute bunny appears before $N and stops your %s with her teeth!",
            attack
         );
         sprintf
         (
            buf3,
            "An image of a cute bunny appears before $N and stops $n's %s with her teeth!",
             attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The image of a cute bunny disappears.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
   }
   return TRUE;
}

void do_star_shower(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   int dam;
   int chance;
   CHAR_DATA *victim;
   char buf[MAX_STRING_LENGTH];

   one_argument(argument, buf);
   if
   (
      !has_skill(ch, gsn_star_shower) ||
      (
         chance = get_skill(ch, gsn_star_shower)
      ) <= 0
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   if (check_peace(ch))
   {
      return;
   }
   dam = number_range(125, 165);
   if
   (
      (
         ch->fighting == NULL &&
         buf[0] == '\0'
      ) ||
      !str_cmp(buf, "all")
   )
   {
      /*
      If not in combat and untargetted (or using the all argument)
      This will be a normal area attack
      */
      /*
      do a skill check
      Number percent is never more than a 100
      chance is max 100
      if chance is 100, this will never fail.
      */
      if (number_percent() > chance)
      {
         /* Emote failure */
         send_to_char
         (
            "You attempt to rain stars down but you just get"
            " a meteorite falling on your head.\n\r",
            ch
         );
         act
         (
            "A meteorite falls and hits $n in the head.",
            ch,
            NULL,
            NULL,
            TO_ROOM
         );
         /*
         Check improvement on failure
         difficulty 1.  (0 does not work)
         higher number makes it harder to learn
         */
         check_improve(ch, gsn_star_shower, FALSE, 1);
         /* Put lag on.  (every exit must have lag) */
         WAIT_STATE(ch, skill_table[gsn_star_shower].beats);
         return;
      }
      /* If we failed, we 'return'd.. so now success */
      send_to_char
      (
         "You raise your arms and the sky darkens before stars come crashing down"
         " from the sky!\n\r",
         ch
      );
      act
      (
         "$n raises $s arms and the sky darkens before stars come crashing down"
         " from the sky!\n\r",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      /* Normal area attack, loop through everyone in the room. */
      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         /*
         Use a temporary variable for the next person
         in case this one flees (moves to another room) or dies
         */
         vch_next = vch->next_in_room;
         if
         (
            /* Skip anyone in your group */
            is_same_group(vch, ch) ||
            /* Skip anyone who is protected by gods from you. */
            is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK)
         )
         {
            continue;
         }
         if
         (
            /*
            Skip wraith form or air elementals,
            they are made of lightning,
            but give an emote
            */
            (
               has_skill(vch, gsn_wraithform) &&
               get_skill(vch, gsn_wraithform) >= 75
            ) ||
            (
               IS_NPC(vch) &&
               vch->pIndexData->vnum == MOB_VNUM_AIR_ELEMENTAL
            )
         )
         {
            act
            (
               "$n looks at all the pretty stars.",
               vch,
               NULL,
               NULL,
               TO_ROOM
            );
            continue;
         }
         /* Yells and logs.  Only for PC-PC combat */
         if
         (
            !IS_NPC(ch) &&
            !IS_NPC(vch) &&
            (
               ch->fighting == NULL ||
               vch->fighting == NULL
            )
         )
         {
            switch(number_range(0, 1))
            {
               case (0):
               {
                  sprintf
                  (
                     buf,
                     "Argh, %s just dropped a shower of stars!",
                     PERS(ch, vch)
                  );
                  break;
               }
               default:  /* (1) */
               {
                  sprintf
                  (
                     buf,
                     "Help! I am being attacked by %s!",
                     PERS(ch, vch)
                  );
                  break;
               }
            }
            /*
            We already removed anyone in our group,
            so we know we are not yelling here ourselves.
            no need for a
            vch != ch
            check
            */
            do_myell(vch, buf);
            sprintf
            (
               log_buf,
               "[%s] used star shower (area) on [%s] at %d",
               ch->name,
               vch->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
         }
         if
         (
            (
               is_affected(vch, gsn_fly) ||
               is_affected(vch, gsn_mass_fly)
            ) &&
            !saves_spell(ch, ch->level,vch, DAM_OTHER, SAVE_SPELL)
         )
         {
            act
            (
               "$n is knocked to the ground by the massive explosions!",
               vch,
               NULL,
               NULL,
               TO_ROOM
            );
            send_to_char("You are knocked to the ground by the massive explosions!\n\r", vch);
            affect_strip(vch, gsn_fly);
            affect_strip(vch, gsn_mass_fly);
         }
         damage(ch, vch, dam, gsn_star_shower, DAM_OTHER, TRUE);
      }
      /* Out of the loop.  Done with normal area */
      /*
      Check improvement on success
      difficulty 1.  (0 does not work)
      higher number makes it harder to learn
      */
      check_improve(ch, gsn_star_shower, TRUE, 1);
      /* Put lag on.  (every exit must have lag) */
      WAIT_STATE(ch, skill_table[gsn_star_shower].beats);
      return;
   }
   if (buf[0] == '\0')
   {
      victim = ch->fighting;
   }
   else
   {
      victim = get_char_room(ch, buf);
   }
   if (victim == NULL)
   {
      /*
      Didn't find the person you were looking for
      Only happens if you target someone not there
      */
      send_to_char("They are not here.\n\r", ch);
      return;
   }
   if (victim == ch)
   {
      /* Don't do anything to yourself. */
      send_to_char
      (
         "A small rock hits you in the head.  Ow.\n\r",
         ch
      );
      return;
   }
   if (number_percent() > chance)
   {
      /*
      Failed. 100% skill never gets in here
      max of numberpercent is 100, chance can be 100
      100 ! > 100
      */
      send_to_char
      (
         "You command the stars to rain down but all you hear is a mocking laugh"
         " from the sky.\n\r",
         ch
      );
      act
      (
         "$n commands the stars to rain down but all that is heard is a"
         " mocking laughing coming from the sky.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      /*
      Check improvement on failure
      difficulty 1.  (0 does not work)
      higher number makes it harder to learn
      */
      check_improve(ch, gsn_star_shower, FALSE, 1);
      /* Put lag on.  (every exit must have lag) */
      WAIT_STATE(ch, skill_table[gsn_star_shower].beats);
      return;
   }
   act
   (
      "You command the stars to rain down on $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n commands the stars to rain down on $N!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   act
   (
      "$n commands the stars to rain down on you!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   /* Swing-type area */
   for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
   {
      vch_next = vch->next_in_room;
      if
      (
         /* Skip anyone not in victim's group (like swing) */
         !is_same_group(vch, victim) ||
         /* Skip anyone who is protected by gods from you. */
         is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK)
      )
      {
         continue;
      }
      if
      (
         /*
         Skip flame form or fire elementals,
         they are made of fire,
         but give an emote
         */
         (
            has_skill(vch, gsn_flame_form) &&
            get_skill(vch, gsn_flame_form) >= 75
         ) ||
         (
            IS_NPC(vch) &&
            vch->pIndexData->vnum == MOB_VNUM_FIRE_ELEMENTAL
         )
      )
      {
         act
         (
            "$n is amused by the falling stars.",
            vch,
            NULL,
            NULL,
            TO_ROOM
         );
         continue;
      }
      /* Yells and logs.  Only for PC-PC combat */
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(vch) &&
         (
            ch->fighting == NULL ||
            vch->fighting == NULL
         )
      )
      {
         switch(number_range(0, 1))
         {
            case (0):
            {
               sprintf
               (
                  buf,
                  "Argh, %s just called a star shower!",
                  PERS(ch, vch)
               );
               break;
            }
            default:  /* (1) */
            {
               sprintf
               (
                  buf,
                  "Help! I am being attacked by %s!",
                  PERS(ch, vch)
               );
               break;
            }
         }
         /*
         We already removed anyone in our group,
         so we know we are not yelling here ourselves.
         no need for a
         vch != ch
         check
         */
         do_myell(vch, buf);
         sprintf
         (
            log_buf,
            "[%s] used star shower on [%s] at %d",
            ch->name,
            vch->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
      }
      if
      (
         (
            is_affected(vch, gsn_fly) ||
            is_affected(vch, gsn_mass_fly)
         ) &&
         !saves_spell(ch, ch->level,vch, DAM_OTHER, SAVE_SPELL)
      )
      {
         act
         (
            "$n is knocked to the ground by the massive explosions!",
            vch,
            NULL,
            NULL,
            TO_ROOM
         );
         send_to_char("You are knocked to the ground by the massive explosions!\n\r", vch);
         affect_strip(vch, gsn_fly);
         affect_strip(vch, gsn_mass_fly);
      }
      damage(ch, vch, dam, gsn_star_shower, DAM_OTHER, TRUE);
   }
   /*
   Check improvement on success
   difficulty 1.  (0 does not work)
   higher number makes it harder to learn
   */
   check_improve(ch, gsn_star_shower, TRUE, 1);
   /* Put lag on.  (every exit must have lag) */
   WAIT_STATE(ch, skill_table[gsn_star_shower].beats);
   return;
}

void do_davatar_assault(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   OBJ_DATA* obj;
   char buf[MAX_STRING_LENGTH];
   int dam;
   int chance;

   /* make sure you have the skill */
   if
   (
      (chance = get_skill(ch, gsn_davatar_assault)) <= 0 ||
      !has_skill(ch, gsn_davatar_assault)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   /* allows use of arguments (like targetting) */
   argument = one_argument(argument, arg);

   /* Use whoever you are fighting as default target */
   if (arg[0] == '\0')
   {
      /* no target, nothing happens */
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (check_peace(ch) || is_safe(ch, victim, 0))
   {
      return;
   }


   if (victim == ch)
   {
      send_to_char
      (
         "You try to split into multiple avatars to attack yourself "
         "but fail miserably\n\r",
         ch
      );
      act
      (
         "$n gets a strained look in $s eyes.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      return;
   }
   /* Can't avoid what you can't see :P
   if (oblivion_blink(ch, victim))
   {
   return;
   }*/

   /* fail and lag */
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, 12);
      send_to_char("You fail to split into multiple avatars.\n\r", ch);
      check_improve(ch, gsn_davatar_assault, FALSE, 1);
      return;
   }
   /* If this is a player (initiating combat) with another player, yell and log */
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   {
      sprintf(buf, "Help! %s is attacking with avatars!", PERS(ch, victim));
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used avatar assault on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   /* the damage */
   act
   (
      "You concentrate and split into four identical avatars!\n\r"
      "Your avatars quickly surround $N on four sides!\n\r"
      "You attack $N and your three avatars mirror your attacks!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n appears to concentrate and suddenly splits into four identical avatars!\n\r"
      "$n's avatars surround you on all four sides!\n\r"
      "$n attacks you and $s three avatars mirror $s attacks!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n appears to concentrate and suddenly splits into four identical avatars!\n\r"
      "$n's avatars surround $N on all four sides!\n\r"
      "$n attacks $N and $s three avatars mirror $s attacks!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   /* the bash */
   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your avatar assault has stunned and disorented $N!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's avatar assault has left you stunned and disoriented!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's avatar assault has left $N stunned and disoriented!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }

   /* the disarm */
   if
   (
      number_percent() < chance / 4 &&
      (obj = get_eq_char(victim, WEAR_WIELD)) != NULL
   )
   {
      disarm(ch, victim);
      if
      (
         get_eq_char(victim, WEAR_WIELD) != obj
      )
      {
         act
         (
            "One of your avatars knock $N's weapon from $S grasp!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "One of $n's avatars knock your weapon from your grasp!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "One of $n's avatars knock $N's weapon from $S grasp!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
      }
   }

   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   dam *= battlecry_multiplier(ch, victim, gsn_telekinesis);
   damage(ch, victim, dam, gsn_davatar_assault, DAM_OTHER, TRUE);
   act
   (
      "$n's avatars merge back together.",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );
   act
   (
      "$n's avatars merge back together.",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "You and your avatars merge back together.",
      ch,
      NULL,
      victim,
      TO_CHAR
   );

   check_improve(ch, gsn_davatar_assault, TRUE, 1);
   WAIT_STATE(ch, 18);  /* was 24 in pounce */
   return;
}

void do_field_surgery(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* victim;
   char arg[MAX_INPUT_LENGTH];

   one_argument(argument, arg);

   if
   (
      (get_skill(ch, gsn_field_surgery) <= 0) ||
      !has_skill(ch, gsn_field_surgery)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   if (house_down(ch, HOUSE_COVENANT))
   {
      return;
   }
   /*
   if (!IS_SET(ch->act,PLR_HONORBOUND) && !IS_IMMORTAL(ch)) {
   send_to_char("Only the honorbound are capable of mastering that skill.\n\r",ch);
   return;
   }
   */

   if (ch->mana < 15)
   {
      send_to_char("You do not have the mana.\n\r",ch);
      return;
   }

   if (arg[0] == '\0')
   victim = ch;
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if (number_percent() > ch->pcdata->learned[gsn_field_surgery])
   {
      act
      (
         "You fail to peform field surgery on $N.",
         ch,
         0,
         victim,
         TO_CHAR
      );
      act
      (
         "$n makes a bloody mess in an attempt to perform field surgery.",
         ch,
         0,
         0,
         TO_ROOM
      );
      ch->mana -= 7;
      check_improve
      (
         ch,
         gsn_field_surgery,
         FALSE,
         3
      );
      return;
   }
   ch->mana -= 20;

   if (victim != ch)
   {
      act
      (
         "$n performs field surgery on $N and mends some of the wounds.",
         ch,
         0,
         victim,
         TO_NOTVICT
      );
      act
      (
         "You perform field surgery on $N and mend some of the wounds.",
         ch,
         0,
         victim,
         TO_CHAR
      );
      act
      (
         "$n performs field surgery on you and mends some of the wounds.",
         ch,
         0,
         victim,
         TO_VICT
      );
   }
   else
   {
      act
      (
         "$n performs field surgery on $mself and mends some wounds.",
         ch,
         0,
         0,
         TO_ROOM
      );
      send_to_char("You perform field surgery on yourself.\n\r", ch);
   }

   if (is_affected(victim, gsn_corrupt("smite", &gsn_smite)))
   {
      send_to_char("Your wounds reopen immediately after they are mended.\n\r", victim);
      return;
   }

   send_to_char("You feel better.\n\r", victim);

   victim->hit = UMIN(victim->hit + 75, victim->max_hit);
   victim->on = NULL;

   check_improve
   (
      ch,
      gsn_field_surgery,
      TRUE,
      3
   );
   WAIT_STATE(ch, 12);
   return;
}

void do_deathfire_missiles(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];
   int dam;
   int chance;

   /* make sure you have the skill */
   if
   (
      (chance = get_skill(ch, gsn_deathfire_missiles)) <= 0 ||
      !has_skill(ch, gsn_deathfire_missiles)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   /* allows use of arguments (like targetting) */
   argument = one_argument(argument, arg);

   /* Use whoever you are fighting as default target */
   if (arg[0] == '\0')
   {
      /* no target, nothing happens */
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if
   (
      check_peace(ch) ||
      is_safe(ch, victim, 0)
   )
   {
      return;
   }


   if (victim == ch)
   {
      send_to_char
      (
         "You create several balls of cold black fire and stand there looking dumb.\n\r",
         ch
      );
      act
      (
         "$n creates several balls of cold black fire and stands there looking dumb.\n\r",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      return;
   }

   /* fail and lag */
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, 12);
      send_to_char
      (
         "You try to summon the cold of death into a ball of fire but fail.\n\r",
         ch
      );
      act
      (
         "$n looks like $e is concentrating really hard on something but nothing happens.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      check_improve
      (
         ch,
         gsn_deathfire_missiles,
         FALSE,
         1
      );
      return;
   }
   /* If this is a player (initiating combat) with another player, yell and log */
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   {
      sprintf
      (
         buf,
         "Help! %s is attacking me with deathfire missiles!",
         PERS(ch, victim)
      );
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used deathfire missiles on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   /* the damage */
   act
   (
      "You summon the cold of the grave and hurl balls of cold black fire at $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n summons the cold of the grave and hurls balls of cold black fire at you!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n summons the cold of the grave and hurls balls of cold black fire at $N!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );

   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your deathfire missiles blast $N to the ground!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's deathfire missiles blast you to the ground!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's deathfire missiles blast $N to the ground!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }
   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   damage
   (
      ch,
      victim,
      dam,
      gsn_deathfire_missiles,
      DAM_OTHER,
      TRUE
   );


   check_improve
   (
      ch,
      gsn_deathfire_missiles,
      TRUE,
      1
   );
   WAIT_STATE(ch, 18);
   return;
}

void do_abyssal_claws(CHAR_DATA* ch, char* argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];
   int dam;
   int chance;

   /* make sure you have the skill */
   if
   (
      (chance = get_skill(ch, gsn_abyssal_claws)) <= 0 ||
      !has_skill(ch, gsn_abyssal_claws)
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }

   /* allows use of arguments (like targetting) */
   argument = one_argument(argument, arg);

   /* Use whoever you are fighting as default target */
   if (arg[0] == '\0')
   {
      /* no target, nothing happens */
      victim = ch->fighting;
      if (victim == NULL)
      {
         send_to_char("But you are not fighting anyone!\n\r", ch);
         return;
      }
   }
   else if ((victim = get_char_room(ch, arg)) == NULL)
   {
      /* Target not in room, nothing */
      send_to_char("They are not here.\n\r", ch);
      return;
   }

   if
   (
      check_peace(ch) ||
      is_safe(ch, victim, 0)
   )
   {
      return;
   }

   if (victim == ch)
   {
      send_to_char
      (
         "You shape your hands into claws infused with the emptiness of the Abyss and scratch that nasty itch.\n\r",
         ch
      );
      act
      (
         "$n shapes $s hands into claws infused with the emptiness of the Abyss and scratches $mself.\n\r",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      return;
   }

   /* fail and lag */
   if (number_percent() > chance)
   {
      WAIT_STATE(ch, 12);
      send_to_char
      (
         "You fail to shape your hands into abyssal claws.\n\r",
         ch
      );
      act
      (
         "$n stares at $s hands for several long moments for no apparent reason.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      check_improve
      (
         ch,
         gsn_abyssal_claws,
         FALSE,
         1
      );
      return;
   }
   /* If this is a player (initiating combat) with another player, yell and log */
   if
   (
      !IS_NPC(ch) &&
      !IS_NPC(victim) &&
      (
         ch->fighting == NULL ||
         victim->fighting == NULL
      )
   )
   {
      sprintf
      (
         buf,
         "Help! %s is slashing me with abyssal claws!",
         PERS(ch, victim)
      );
      do_myell(victim, buf);
      sprintf
      (
         log_buf,
         "[%s] used abyssal claws on [%s] at %d",
         ch->name,
         victim->name,
         ch->in_room->vnum
      );
      log_string(log_buf);
   }

   /* the damage */
   act
   (
      "Using abyssal cold, you form your hands into claws and tear into $N!",
      ch,
      NULL,
      victim,
      TO_CHAR
   );
   act
   (
      "$n forms $s hands into abyssal claws and tears into you!",
      ch,
      NULL,
      victim,
      TO_VICT
   );
   act
   (
      "$n forms $s hands into abyssal claws and tears into $N!",
      ch,
      NULL,
      victim,
      TO_NOTVICT
   );

   if
   (
      (victim->daze == 0) &&
      (number_percent() < chance / 2)
   )
   {
      act
      (
         "Your brutal clawing knocks $N to the ground!",
         ch,
         NULL,
         victim,
         TO_CHAR
      );
      act
      (
         "$n's brutal clawing knocks you to the ground!",
         ch,
         NULL,
         victim,
         TO_VICT
      );
      act
      (
         "$n's brutal clawing knocks $N to the ground!",
         ch,
         NULL,
         victim,
         TO_NOTVICT
      );
      DAZE_STATE(victim, 20);
   }
   dam = ch->level * 5 / 2 + number_range(0, ch->level) * 3 / 2;
   damage
   (
      ch,
      victim,
      dam,
      gsn_abyssal_claws,
      DAM_OTHER,
      TRUE
   );


   check_improve
   (
      ch,
      gsn_abyssal_claws,
      TRUE,
      1
   );
   WAIT_STATE(ch, 18);
   return;
}

void do_destruction_shockwave(CHAR_DATA* ch, char* argument)
{
   CHAR_DATA* vch;
   CHAR_DATA* vch_next;
   int dam;
   int chance;
   CHAR_DATA* victim;
   char buf[MAX_STRING_LENGTH];

   one_argument(argument, buf);
   if
   (
      !has_skill(ch, gsn_destruction_shockwave) ||
      (
         chance = get_skill(ch, gsn_destruction_shockwave)
      ) <= 0
   )
   {
      send_to_char("Huh?\n\r", ch);
      return;
   }
   if (check_peace(ch))
   {
      return;
   }
   dam = number_range(135, 175);
   if
   (
      (
         ch->fighting == NULL &&
         buf[0] == '\0'
      ) ||
      !str_cmp(buf, "all")
   )
   {
      /*
      If not in combat and untargetted (or using the all argument)
      This will be a normal area attack
      */
      /*
      do a skill check
      Number percent is never more than a 100
      chance is max 100
      if chance is 100, this will never fail.
      */
      if (number_percent() > chance)
      {
         /* Emote failure */
         send_to_char
         (
            "You fail to emit a destructive shockwave.",
            ch
         );
         act
         (
            "$n glares at the ground for a while for no reason.",
            ch,
            NULL,
            NULL,
            TO_ROOM
         );
         /*
         Check improvement on failure
         difficulty 1.  (0 does not work)
         higher number makes it harder to learn
         */
         check_improve
         (
            ch,
            gsn_destruction_shockwave,
            FALSE,
            1
         );
         /* Put lag on.  (every exit must have lag) */
         WAIT_STATE
         (
            ch,
            skill_table[gsn_destruction_shockwave].beats
         );
         return;
      }
      /* If we failed, we 'return'd.. so now success */
      send_to_char
      (
         "You concentrate and emit a mighty shockwave of destruction!\n\r",
         ch
      );
      act
      (
         "$n glares and emits a powerful destructive shockwave!",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      /* Normal area attack, loop through everyone in the room. */
      for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
      {
         /*
         Use a temporary variable for the next person
         in case this one flees (moves to another room) or dies
         */
         vch_next = vch->next_in_room;
         if
         (
            /* Skip anyone in your group */
            is_same_group(vch, ch) ||
            /* Skip anyone who is protected by gods from you. */
            is_safe
            (
               ch,
               vch,
               IS_SAFE_SILENT |
               IS_SAFE_AREA_ATTACK
            )
         )
         {
            continue;
         }
         /* Yells and logs.  Only for PC-PC combat */
         if
         (
            !IS_NPC(ch) &&
            !IS_NPC(vch) &&
            (
               ch->fighting == NULL ||
               vch->fighting == NULL
            )
         )
         {
            switch(number_range(0, 1))
            {
               case (0):
               {
                  sprintf
                  (
                     buf,
                     "Help, %s just emitted a destructive shockwave!",
                     PERS(ch, vch)
                  );
                  break;
               }
               default:  /* (1) */
               {
                  sprintf
                  (
                     buf,
                     "Help! I am being attacked by %s!",
                     PERS(ch, vch)
                  );
                  break;
               }
            }
            /*
            We already removed anyone in our group,
            so we know we are not yelling here ourselves.
            no need for a
            vch != ch
            check
            */
            do_myell(vch, buf);
            sprintf
            (
               log_buf,
               "[%s] used destruction shockwave (area) on [%s] at %d",
               ch->name,
               vch->name,
               ch->in_room->vnum
            );
            log_string(log_buf);
         }
         if
         (
            (
               is_affected(vch, gsn_fly) ||
               is_affected(vch, gsn_mass_fly)
            ) &&
            !saves_spell
            (
               ch,
               ch->level,
               vch,
               DAM_OTHER,
               SAVE_SPELL
            )
         )
         {
            act
            (
               "$n is knocked to the ground from the shockwave!",
               vch,
               NULL,
               NULL,
               TO_ROOM
            );
            send_to_char("You are thrown down by the shockwave!\n\r", vch);
            affect_strip(vch, gsn_fly);
            affect_strip(vch, gsn_mass_fly);
         }
         damage
         (
            ch,
            vch,
            dam,
            gsn_destruction_shockwave,
            DAM_OTHER,
            TRUE
         );
      }
      /* Out of the loop.  Done with normal area */
      /*
      Check improvement on success
      difficulty 1.  (0 does not work)
      higher number makes it harder to learn
      */
      check_improve(ch, gsn_destruction_shockwave, TRUE, 1);
      /* Put lag on.  (every exit must have lag) */
      WAIT_STATE(ch, skill_table[gsn_destruction_shockwave].beats);
      return;
   }
   if (buf[0] == '\0')
   {
      victim = ch->fighting;
   }
   else
   {
      victim = get_char_room(ch, buf);
   }
   if (victim == NULL)
   {
      /*
      Didn't find the person you were looking for
      Only happens if you target someone not there
      */
      send_to_char("They are not here.\n\r", ch);
      return;
   }
   if (victim == ch)
   {
      /* Don't do anything to yourself. */
      send_to_char
      (
         "Your try but fail to emit a destructive shockwave.\n\r",
         ch
      );
      return;
   }
   if (number_percent() > chance)
   {
      /*
      Failed. 100% skill never gets in here
      max of numberpercent is 100, chance can be 100
      100 ! > 100
      */
      send_to_char
      (
         "You focus and focus but nothing happens",
         ch
      );
      act
      (
         "$n glares at the ground for no apparent reason.",
         ch,
         NULL,
         NULL,
         TO_ROOM
      );
      /*
      Check improvement on failure
      difficulty 1.  (0 does not work)
      higher number makes it harder to learn
      */
      check_improve(ch, gsn_destruction_shockwave, FALSE, 1);
      /* Put lag on.  (every exit must have lag) */
      WAIT_STATE(ch, skill_table[gsn_destruction_shockwave].beats);
      return;
   }
   send_to_char
   (
      "You snarl and emit a focused blast of destructive energy!\n\r",
      ch
   );
   act
   (
      "$n snarls and emits a focused blast of destructive energy!",
      ch,
      NULL,
      NULL,
      TO_ROOM
   );
   /* Swing-type area */
   for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
   {
      vch_next = vch->next_in_room;
      if
      (
         /* Skip anyone not in victim's group (like swing) */
         !is_same_group(vch, victim) ||
         /* Skip anyone who is protected by gods from you. */
         is_safe(ch, vch, IS_SAFE_SILENT | IS_SAFE_AREA_ATTACK)
      )
      {
         continue;
      }
      /* Yells and logs.  Only for PC-PC combat */
      if
      (
         !IS_NPC(ch) &&
         !IS_NPC(vch) &&
         (
            ch->fighting == NULL ||
            vch->fighting == NULL
         )
      )
      {
         switch(number_range(0, 1))
         {
            case (0):
            {
               sprintf
               (
                  buf,
                  "Argh, %s just hit me with a destructive shockwave!",
                  PERS(ch, vch)
               );
               break;
            }
            default:  /* (1) */
            {
               sprintf
               (
                  buf,
                  "Help! I am being attacked by %s!",
                  PERS(ch, vch)
               );
               break;
            }
         }
         /*
         We already removed anyone in our group,
         so we know we are not yelling here ourselves.
         no need for a
         vch != ch
         check
         */
         do_myell(vch, buf);
         sprintf
         (
            log_buf,
            "[%s] used destruction shockwave on [%s] at %d",
            ch->name,
            vch->name,
            ch->in_room->vnum
         );
         log_string(log_buf);
      }
      if
      (
         (
            is_affected(vch, gsn_fly) ||
            is_affected(vch, gsn_mass_fly)
         ) &&
         !saves_spell
         (
            ch,
            ch->level,
            vch,
            DAM_OTHER,
            SAVE_SPELL
         )
      )
      {
         act
         (
            "$n is knocked to the ground by the blast of destructive energy!",
            vch,
            NULL,
            NULL,
            TO_ROOM
         );
         send_to_char("You are knocked to the ground by the blast of destructive energy!\n\r", vch);
         affect_strip(vch, gsn_fly);
         affect_strip(vch, gsn_mass_fly);
      }
      damage
      (
         ch,
         vch,
         dam,
         gsn_destruction_shockwave,
         DAM_OTHER,
         TRUE
      );
   }
   /*
   Check improvement on success
   difficulty 1.  (0 does not work)
   higher number makes it harder to learn
   */
   check_improve
   (
      ch,
      gsn_destruction_shockwave,
      TRUE,
      1
   );
   /* Put lag on.  (every exit must have lag) */
   WAIT_STATE
   (
      ch,
      skill_table[gsn_destruction_shockwave].beats
   );
   return;
}


void check_drithentir_attack_brand(CHAR_DATA* ch, CHAR_DATA* victim)
{
   int dam;
   int chance;

   if (IS_NPC(victim) && ((ch->level) - (victim->level) >= 20))
   {
      chance = (number_range(1, 4));
      if (chance == 1)
      {
         act
         (
            "A cloaked and hooded reaper manifestation of Drithentir rips $N apart with a scythe!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "A cloaked and hooded reaper manifestation of Drithentir rips $N apart with a scythe!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "A cloaked and hooded reaper manifestation of Drithentir rips you apart with a scythe!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         raw_kill(ch, victim);
         act
         (
            "The manifestation of Drithentir blinks out of existence.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
      }
   }
   if (number_percent() > 8)
   {
      return;
   }
   switch(number_range(1,7))
   {
      case(1):
      {
         act
         (
            "A black vortex opens up and a massive fanged skull appears!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The fanged skull bites down on $N's head!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The fanged skull bites down on your head!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The fanged skull bites down on $N's head!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_BASH,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            act
            (
               "The skull grinds your head with its teeth!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            dam = ch->level/2;
            damage
            (
               ch,
               victim,
               dam,
               gsn_drithentir_attack_brand,
               DAM_OTHER,
               TRUE
            );
         }
         act
         (
            "The fanged skull shatters into a million shards of bone!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(2):
      {
         act
         (
            "$n's chest bleeds and a large scythe emerges from it!",
            ch,
            NULL,
            NULL,
            TO_ROOM
         );
         act
         (
            "Your chest bleeds and a large scythe emerges from it!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The scythe rears back and impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The scythe rears back and impales you on its tip!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The scythe rears back and impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level / 2;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_PIERCE,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "The scythe's blade oozes a foul green poison into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The scythe's blade oozes a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade oozes a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_poison;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -3;
            af.bitvector = AFF_POISON;
            affect_join(victim, &af, 10);
            af2 =affect_find(victim->affected, gsn_poison);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "The scythe burrows itself into your chest!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The scythe burrows itself into $n's chest!",
            ch,
            NULL,
            victim,
            TO_ROOM
         );
         break;
      }
      case(3):
      {
         act
         (
            "$n's chest bleeds and a large scythe emerges from it!",
            ch,
            NULL,
            victim,
            TO_ROOM
         );
         act
         (
            "Your chest bleeds and a large scythe emerges from it!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The scythe rears back and slashes $N with its edge!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The scythe rears back and slashes you with its edge!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The scythe rears back and slashes $N with its edge!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level / 2;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_SLASH,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "The scythe's blade oozes a foul purple substance into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_plague;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -5;
            af.bitvector = AFF_PLAGUE;
            affect_join(victim, &af, 10);
            af2 = affect_find(victim->affected, gsn_plague);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "The scythe burrows into your chest!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The scythe burrows into $n's chest!",
            ch,
            NULL,
            victim,
            TO_ROOM
         );
         break;
      }
      case(4):
      {
         act
         (
            "Blood erupts from $n's eyes and two scythes emerge from them!",
            ch,
            NULL,
            victim,
            TO_ROOM
         );
         act
         (
            "Blood erupts from your eyes and two scythes emerge from them!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "One scythe slashes across $N's neck!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "One scythe slashes across your neck!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "One scythe slashes across $N's neck!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level / 2;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_SLASH,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "A scythe's blade oozes a foul purple substance into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "A scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_plague;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -5;
            af.bitvector = AFF_PLAGUE;
            affect_join(victim, &af, 10);
            af2 = affect_find(victim->affected, gsn_plague);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "The second scythe impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The second scythe impales you on its tip!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The second scythe impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_PIERCE,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "A scythe's blade pumps a foul green poison into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "A scythe's blade pumps a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade pumps a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_poison;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -3;
            af.bitvector = AFF_POISON;
            affect_join(victim, &af, 10);
            af2 =affect_find(victim->affected, gsn_poison);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "The scythes plunge themselves into your eyes!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         act
         (
            "The scythes plunge themselves into $n's eyes!",
            ch,
            NULL,
            victim,
            TO_ROOM
         );
         break;
      }
      case(5):
      {
         act
         (
            "A black vortex opens up and a massive fanged skull appears!\n\r"
            "The air shimmers and a large scythe materializes!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The fanged skull bites down on $N's head!!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The fanged skull bites down on your head!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The fanged skull bites down on $N's head!!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_BASH,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {

            act
            (
               "The skull grinds your head with its teeth!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            dam = ch->level/2;
            damage
            (
               ch,
               victim,
               dam,
               gsn_drithentir_attack_brand,
               DAM_OTHER,
               TRUE
            );
         }
         act
         (
            "The scythe slashes across $N's neck!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The scythe slashes across your neck!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The scythe slashes across $N's neck!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level / 2;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_SLASH,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "The scythe's blade oozes a foul purple substance into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_plague;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -5;
            af.bitvector = AFF_PLAGUE;
            affect_join(victim, &af, 10);
            af2 = affect_find(victim->affected, gsn_plague);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "The skull and scythe shimmer and fade away.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(6):
      {
         act
         (
            "A black vortex opens up and a massive fanged skull appears!\n\r"
            "The air shimmers and a large scythe materializes!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         act
         (
            "The fanged skull bites down on $N's head!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The fanged skull bites down on your head!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The fanged skull bites down on $N's head!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_BASH,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            act
            (
               "The skull grinds your head with its teeth!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            dam = ch->level/2;
            damage
            (
               ch,
               victim,
               dam,
               gsn_drithentir_attack_brand,
               DAM_OTHER,
               TRUE
            );
         }
         act
         (
            "The scythe impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The scythe impales you on its tip!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The scythe impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level / 2;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_PIERCE,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "The scythe's blade pumps a foul green poison into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The scythe's blade pumps a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade pumps a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_poison;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -3;
            af.bitvector = AFF_POISON;
            affect_join(victim, &af, 10);
            af2 = affect_find(victim->affected, gsn_poison);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "The skull and scythe shimmer and fade away.",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
      case(7):
      {
         act
         (
            "A black vortex opens up and a massive fanged skull appears!",
            ch,
            NULL,
            victim,
            TO_ROOM
         );
         act
         (
            "The fanged skull bites down on $N's head!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The fanged skull bites down on your head!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "The fanged skull bites down on $N's head!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_BASH,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            act
            (
               "The skull grinds your head with its teeth!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The skull grinds $N's head with its teeth!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            dam = ch->level/2;
            damage
            (
               ch,
               victim,
               dam,
               gsn_drithentir_attack_brand,
               DAM_OTHER,
               TRUE
            );
         }
         act
         (
            "One scythe slashes across $N's neck!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "One scythe slashes across your neck!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "One scythe slashes across $N's neck!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level / 2;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_PIERCE,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "A scythe's blade oozes a foul purple substance into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "A scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade oozes a foul purple substance into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_plague;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -5;
            af.bitvector = AFF_PLAGUE;
            affect_join(victim, &af, 10);
            af2 = affect_find(victim->affected, gsn_plague);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "One scythe impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_NOTVICT
         );
         act
         (
            "The other scythe impales you on its tip!",
            ch,
            NULL,
            victim,
            TO_VICT
         );
         act
         (
            "One scythe impales $N on its tip!",
            ch,
            NULL,
            victim,
            TO_CHAR
         );
         dam = ch->level / 2;
         damage
         (
            ch,
            victim,
            dam,
            gsn_drithentir_attack_brand,
            DAM_PIERCE,
            TRUE
         );
         chance = (number_range(1, 3));
         if (chance == 1)
         {
            AFFECT_DATA af;
            AFFECT_DATA *af2;
            act
            (
               "The scythe's blade pumps a foul green poison into your wound!",
               ch,
               NULL,
               victim,
               TO_VICT
            );
            act
            (
               "The scythe's blade pumps a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_NOTVICT
            );
            act
            (
               "The scythe's blade pumps a foul green poison into $N's wound!",
               ch,
               NULL,
               victim,
               TO_CHAR
            );
            af.where     = TO_AFFECTS;
            af.type      = gsn_poison;
            af.level     = ch->level * 3/4;
            af.duration  = ch->level / 2;
            af.location  = APPLY_STR;
            af.modifier  = -3;
            af.bitvector = AFF_POISON;
            affect_join(victim, &af, 10);
            af2 = affect_find(victim->affected, gsn_poison);
            if (af2 != NULL)
            {
               free_string(af2->caster);
               af2->caster = str_dup(ch->name);
            }
         }
         act
         (
            "The skull and scythes disappear in a bright flash of light!",
            ch,
            NULL,
            NULL,
            TO_ALL
         );
         break;
      }
   }
}

bool check_drithentir_vampiric_brand(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int chance;
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;
   int dam;

   if (!is_affected(victim, gsn_drithentir_vampiric_brand))
   {
      return FALSE;
   }

   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }

   chance = 6;

   if (number_percent() >= chance)
   {
      return FALSE;
   }

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }


   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In Drithentir brand vampiric aura, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }

   dam = number_range(ch->level / 2, (ch->level + number_range(0, 40)));

   sprintf
   (
      buf1,
      "Your vampiric aura drains life from $n through $s %s!",
      attack
   );
   sprintf
   (
      buf2,
      "$N's vampiric aura drains your life from your %s's contact with $M!",
      attack
   );
   sprintf
   (
      buf3,
      "$N's vampiric aura drains life from $n through $n's %s!",
      attack
   );
   act
   (
      buf1,
      ch,
      0,
      victim,
      TO_VICT
   );
   act
   (
      buf2,
      ch,
      0,
      victim,
      TO_CHAR
   );
   act
   (
      buf3,
      ch,
      0,
      victim,
      TO_NOTVICT
   );
   victim->hit = UMIN(victim->hit + dam, victim->max_hit);

   damage
   (
      victim,
      ch,
      dam,
      gsn_drithentir_vampiric_brand,
      DAM_OTHER,
      FALSE
   );
   return TRUE;
}

bool check_evasive_defense(CHAR_DATA* ch, CHAR_DATA* victim, int dt)
{
   int tmp_dt;
   OBJ_DATA* wield;
   char buf1[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char buf3[MAX_STRING_LENGTH];
   char* attack;


   if (!IS_AWAKE(victim))
   {
      return FALSE;
   }

   if (house_down(ch, HOUSE_COVENANT))
   {
      return;
   }

   if (number_percent() >= 20)
   {
      return;
   }

   /* The rest is all new dual wield stuff */
   tmp_dt = TYPE_HIT;
   if (dt  == gsn_dual_wield)
   {
      wield = get_eq_char(ch, WEAR_DUAL_WIELD);
   }
   else if (dt == gsn_tertiary_wield)
   {
      wield = get_eq_char(ch, WEAR_TERTIARY_WIELD);
   }
   else
   {
      wield = get_eq_char(ch, WEAR_WIELD);
   }


   if (wield != NULL)
   {
      tmp_dt += wield->value[3];
   }
   else
   {
      tmp_dt += ch->dam_type;
   }


   if
   (
      tmp_dt > TYPE_HIT &&
      tmp_dt < TYPE_HIT + MAX_DAMAGE_MESSAGE
   )
   {
      attack = attack_table[tmp_dt - TYPE_HIT].noun;
   }
   else
   {
      bug("In evasive defense, bad dam message: dt %d.", tmp_dt);
      attack = attack_table[0].name;
   }

   switch(number_range(0, 4))
   {
      case(1):
      {
         sprintf
         (
            buf1,
            "You call upon your evasive defense training and duck and swat $n's %s aside!",
            attack
         );
         sprintf
         (
            buf2,
            "$N ducks and swats aside your %s!",
            attack
         );
         sprintf
         (
            buf3,
            "$N ducks and swats aside $n's %s!",
            attack
         );
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(2):
      {
         if
         (
            ch->in_room->sector_type == SECT_UNDERWATER ||
            (
                 ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                 IS_AFFECTED(ch, AFF_SWIM)
            )
         )
         {
            sprintf
            (
               buf1,
               "You swim upward and kick aside $n's %s!",
               attack
            );
            sprintf
            (
               buf2,
               "$N swims upward and kicks aside your %s!",
               attack
            );
            sprintf
            (
               buf3,
               "$N swims upward and kicks aside $n's %s!",
               attack
            );
         }
         else if
         (
            ch->in_room->sector_type == SECT_AIR ||
            IS_FLYING(ch)
         )
         {
            sprintf
            (
               buf1,
               "You fly up and kick aside $n's %s!",
               attack
            );
            sprintf
            (
               buf2,
               "$N flies up and kicks aside your %s!",
               attack
            );
            sprintf
            (
               buf3,
               "$N flies up and kicks aside $n's %s!",
               attack
            );
         }
         else
         {
            sprintf
            (
               buf1,
               "You jump and kick aside $n's %s!",
               attack
            );
            sprintf
            (
               buf2,
               "$N jumps and kicks aside your %s!",
               attack
            );
            sprintf
            (
               buf3,
               "$N jumps and kicks aside $n's %s!",
               attack
            );
         }
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
      case(3):
      {
         if
         (
            ch->in_room->sector_type == SECT_UNDERWATER ||
            (
                 ch->in_room->sector_type == SECT_WATER_NOSWIM &&
                 IS_AFFECTED(ch, AFF_SWIM)
            )
         )
         {
            sprintf
            (
               buf1,
               "You quickly swim close to $n and push aside $s %s!",
               attack
            );
            sprintf
            (
               buf2,
               "$N quickly swims close to you and pushes aside your %s!",
               attack
            );
            sprintf
            (
               buf3,
               "$N quickly swims close to $n and pushes aside $n's %s!",
               attack
            );
         }
         else if
         (
            ch->in_room->sector_type == SECT_AIR ||
            IS_FLYING(ch)
         )
         {
            sprintf
            (
               buf1,
               "You quickly flies close to $n and push aside $s %s!",
               attack
            );
            sprintf
            (
               buf2,
               "$N quickly flies close to you and pushes aside your %s!",
               attack
            );
            sprintf
            (
               buf3,
               "$N quickly flies close to $n and pushes aside $n's %s!",
               attack
            );
         }
         else
         {
            sprintf
            (
               buf1,
               "You quickly move close to $n and push aside $s %s!",
               attack
            );
            sprintf
            (
               buf2,
               "$N quickly moves close to you and pushes aside your %s!",
               attack
            );
            sprintf
            (
               buf3,
               "$N quickly moves close to $n and pushes aside $n's %s!",
               attack
            );
         }
         act
         (
            buf1,
            ch,
            0,
            victim,
            TO_VICT
         );
         act
         (
            buf2,
            ch,
            0,
            victim,
            TO_CHAR
         );
         act
         (
            buf3,
            ch,
            0,
            victim,
            TO_NOTVICT
         );
         break;
      }
   }
   return;
}

